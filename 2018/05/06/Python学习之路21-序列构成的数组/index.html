<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="Y0-gFMBzGnbrueUrh8PjkmnvCGItjob2oR3HjG9SVnE">
  <meta name="msvalidate.01" content="97A49017D4D536B99438C4EE0E9FBA3F">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.zuiqiangiron.xyz","root":"/","scheme":"Gemini","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="《流畅的Python》笔记。 接下来的三篇都是关于Python的数据结构，本篇主要是Python中的各序列类型">
<meta property="og:type" content="article">
<meta property="og:title" content="Python学习之路21-序列构成的数组">
<meta property="og:url" content="https://www.zuiqiangiron.xyz/2018/05/06/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF21-%E5%BA%8F%E5%88%97%E6%9E%84%E6%88%90%E7%9A%84%E6%95%B0%E7%BB%84/index.html">
<meta property="og:site_name" content="嘴强黑铁">
<meta property="og:description" content="《流畅的Python》笔记。 接下来的三篇都是关于Python的数据结构，本篇主要是Python中的各序列类型">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://res.cloudinary.com/vpointer/image/upload/v1527828468/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF21-%E5%BA%8F%E5%88%97%E6%9E%84%E6%88%90%E7%9A%84%E6%95%B0%E7%BB%84/1525593275610.png">
<meta property="article:published_time" content="2018-05-06T15:00:00.000Z">
<meta property="article:modified_time" content="2018-05-06T15:00:00.000Z">
<meta property="article:author" content="嘴强黑铁">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="Python进阶">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://res.cloudinary.com/vpointer/image/upload/v1527828468/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF21-%E5%BA%8F%E5%88%97%E6%9E%84%E6%88%90%E7%9A%84%E6%95%B0%E7%BB%84/1525593275610.png">

<link rel="canonical" href="https://www.zuiqiangiron.xyz/2018/05/06/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF21-%E5%BA%8F%E5%88%97%E6%9E%84%E6%88%90%E7%9A%84%E6%95%B0%E7%BB%84/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Python学习之路21-序列构成的数组 | 嘴强黑铁</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-161480657-1"></script>
    <script pjax>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-161480657-1');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">嘴强黑铁</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">天下事以难而废者十之一，以惰而废者十之九</h1>
      
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="search-pop-overlay">
  <div class="popup search-popup">
      <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

  </div>
</div>

  </div>
</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.zuiqiangiron.xyz/2018/05/06/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF21-%E5%BA%8F%E5%88%97%E6%9E%84%E6%88%90%E7%9A%84%E6%95%B0%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.jpg">
      <meta itemprop="name" content="嘴强黑铁">
      <meta itemprop="description" content="一顿操作猛如虎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="嘴强黑铁">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          Python学习之路21-序列构成的数组
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-06 23:00:00" itemprop="dateCreated datePublished" datetime="2018-05-06T23:00:00+08:00">2018-05-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/Python%E8%BF%9B%E9%98%B6/" itemprop="url" rel="index"><span itemprop="name">Python进阶</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2018/05/06/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF21-%E5%BA%8F%E5%88%97%E6%9E%84%E6%88%90%E7%9A%84%E6%95%B0%E7%BB%84/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/05/06/Python学习之路21-序列构成的数组/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>《流畅的Python》笔记。</p>
<p>接下来的三篇都是关于Python的数据结构，本篇主要是Python中的各序列类型</p>
</blockquote>
<a id="more"></a>
<h1 id="内置序列类型概览">1. 内置序列类型概览</h1>
<p>Python标准库用C实现了丰富的序列类型，可分为两大类：</p>
<ul>
<li>容器序列：<code>list</code>，<code>tuple</code>和<code>collections.deque</code>等这些序列能存放不同类型的数据。</li>
<li>扁平序列：<code>str</code>，<code>bytes</code>，<code>bytearray</code>，<code>memoryview</code>和<code>array.array</code>等，这些序列只能容纳一种类型。</li>
</ul>
<p>容器序列存放的是它们所包含的任意类型的对象的引用，而扁平序列存放的是值而不是引用。即，扁平序列其实是一段连续的内存空间，更加紧凑。</p>
<p>序列类型还可以按能否被修改来分来：</p>
<ul>
<li>可变序列（<code>MutableSequence</code>）：<code>list</code>，<code>bytearray</code>，<code>array.array</code>，<code>collections.deque</code>和<code>memoryview</code>；</li>
<li>不可变序列（<code>Sequence</code>）：<code>tuple</code>，<code>str</code>和<code>byte</code>。</li>
</ul>
<p>以下是这两大类的继承关系：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828468/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF21-%E5%BA%8F%E5%88%97%E6%9E%84%E6%88%90%E7%9A%84%E6%95%B0%E7%BB%84/1525593275610.png" /></p>
<p>虽然Python中内置的序列类型并不是直接从<code>Sequence</code>和<code>MutableSequence</code>这两个抽象基类继承而来，但了解这些基类可以总结出那些完整的序列类型包含了哪些功能，以及将上述两种分类方式融会贯通。</p>
<p>下面我们从最常用的列表（<code>list</code>）开始。</p>
<h1 id="列表推导和生成器表达式">2. 列表推导和生成器表达式</h1>
<p>列表推导（list comprehension，简称listcomps）是构建列表的快捷方式，而生成器表达式（generator expression, 简称genexps）则可以用来创建其它任何类型的序列。</p>
<p>有时候，比起用<code>for</code>循环，列表推导可能会更简单可读。通常的原则是，只用列表推导来创建新的列表，并且尽量保持简短。如果列表推导的代码超过了两行，应该考虑是不是得用for循环重写，不过这个度得自己把握。（句法提示：Python会忽略<code>[]</code>,<code>{}</code>,<code>()</code>中的换行，所以可以省略不太好看的换行符<code>\</code>)</p>
<p><strong>注意：</strong>在Python3中，列表推导、生成器表达式，以及和它们很相似的集合（<code>set</code>）推导和字典（<code>dict</code>）推导都有了自己的局部作用域，不会影响外部的同名变量（Python2中则可能会影响），如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = <span class="string">"a"</span></span><br><span class="line">&gt;&gt;&gt; <span class="built_in">test</span> = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">"ABC"</span>]</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line"><span class="string">"a"</span>   <span class="comment"># 在Python2中，该结果则可能是 "C"</span></span><br></pre></td></tr></table></figure>
<h2 id="列表推导同filter和map比较">2.1 列表推导同filter和map比较</h2>
<p>列表推导可以过滤或加工一个序列或其他可迭代类型中的元素，然后生成一个新列表。而Python内置的<code>filter</code>和<code>map</code>函数组合起来也能达到这一效果（一般需要借助<code>lambda</code>表达式），但可读性却比不上列表推导，比如下面的代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; symbols = <span class="string">"ABCDEFG"</span></span><br><span class="line">&gt;&gt;&gt; ascii = [ord(s) <span class="keyword">for</span> s <span class="keyword">in</span> symbols <span class="keyword">if</span> ord(s) &gt; 66]</span><br><span class="line">&gt;&gt;&gt; ascii</span><br><span class="line">[67, 68, 69, 70, 71]</span><br><span class="line">&gt;&gt;&gt; ascii = list(filter(lambda c: c &gt; 66, map(ord, symbols)))</span><br><span class="line">&gt;&gt;&gt; ascii</span><br><span class="line">[67, 68, 69, 70, 71]</span><br></pre></td></tr></table></figure>
<p>原本以为<code>map/filter</code>组合起来会比列表推导快一些，但有测试证明该结论不一定成立。对于<code>map</code>, <code>filter</code>的详细介绍将放在后面的文章中。</p>
<h2 id="笛卡尔积">2.2 笛卡尔积</h2>
<p>简单说就是简化嵌套<code>for</code>循环，例子如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">colors = [<span class="string">"black"</span>, <span class="string">"white"</span>]</span><br><span class="line">sizes = [<span class="string">"S"</span>, <span class="string">"M"</span>, <span class="string">"L"</span>]</span><br><span class="line">tshirts = [(color, size) <span class="keyword">for</span> color <span class="keyword">in</span> colors <span class="keyword">for</span> size <span class="keyword">in</span> sizes]</span><br><span class="line"></span><br><span class="line">tshirts_for = [] <span class="comment"># 最后它的内容等价于上面的tshirts</span></span><br><span class="line"><span class="keyword">for</span> color <span class="keyword">in</span> colors:</span><br><span class="line">    <span class="keyword">for</span> size <span class="keyword">in</span> sizes:</span><br><span class="line">        tshirts_for.append((color, size))</span><br></pre></td></tr></table></figure>
<p>列表推导的作用只有一个：生成列表。如果想生成其他类型的序列，则需要使用生成器表达式。</p>
<h2 id="生成器表达式">2.3 生成器表达式</h2>
<p>虽然也可以用列表推导式来初始化元组，数组或其他序列类型，但生成器表达式是更好的选择，因为生成器表达式背后<strong>遵循了迭代器协议</strong>，可以<strong>逐个生成元素</strong>（可节省内存），而不是一次性生成所有元素。</p>
<p>生成器表达式语法跟列表推导差不多，只是<strong>把方括号换成了圆括号</strong>而已，如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; symbols = <span class="string">"ABCDEFG"</span></span><br><span class="line">&gt;&gt;&gt; tuple(ord(symbol) <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols)  <span class="comment"># ①</span></span><br><span class="line">(65, 66, 67, 68, 69, 70, 71)</span><br><span class="line">&gt;&gt;&gt; import array</span><br><span class="line">&gt;&gt;&gt; array.array(<span class="string">"I"</span>, (ord(symbol) <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols))  <span class="comment"># ②</span></span><br><span class="line">array(<span class="string">'I'</span>, [65, 66, 67, 68, 69, 70, 71])</span><br></pre></td></tr></table></figure>
<p>①如果生成器表达式是一个函数调用过程中的唯一参数，则可不加括号将其围起来；</p>
<p>②array的构造方法需要两个参数，因此括号是必需的。</p>
<p>下面用生成器表达式改写上面的笛卡尔积代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">colors = [<span class="string">"black"</span>, <span class="string">"white"</span>]</span><br><span class="line">sizes = [<span class="string">"S"</span>, <span class="string">"M"</span>, <span class="string">"L"</span>]</span><br><span class="line"><span class="keyword">for</span> tshirt <span class="keyword">in</span> (<span class="string">"%s %s"</span> % (c, s) <span class="keyword">for</span> c <span class="keyword">in</span> colors <span class="keyword">for</span> s <span class="keyword">in</span> sizes):</span><br><span class="line">    print(tshirts)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">black S</span><br><span class="line">black M</span><br><span class="line">black L</span><br><span class="line">white S</span><br><span class="line">white M</span><br><span class="line">white L</span><br></pre></td></tr></table></figure>
<p>生成器表达式逐个生成元素，不会一次性生成一个含有6个元素的列表。关于生成器表达式的工作原理将在后面的文章中介绍。</p>
<h1 id="元组">3. 元组</h1>
<p>元组除了用作不可变的列表，它还可以用于没有字段名的记录，比如坐标，身份信息等，这里不再举例。</p>
<h2 id="元祖拆包">3.1 元祖拆包</h2>
<p>此概念之前涉及过，这里将其总结一下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 平行赋值</span></span><br><span class="line">a, b = (<span class="string">"test1"</span>, <span class="string">"test2"</span>)</span><br><span class="line"><span class="comment"># 不用中间变量交换两个变量的值</span></span><br><span class="line">b, a = a, b</span><br><span class="line"><span class="comment"># *号运算将可迭代对象拆开作为函数参数</span></span><br><span class="line">t = (20, 8)</span><br><span class="line">divmod(*t)  <span class="comment"># 该函数的意思是： 20 ÷ 8 = 2 …… 4， 函数返回商和余数的元组</span></span><br><span class="line"><span class="comment"># 用*来处理剩下的元素，Python3支持</span></span><br><span class="line">a, b, *rest = range(5)  <span class="comment"># rest的值为[2, 3, 4]</span></span><br><span class="line">a, b, *rest = range(3)  <span class="comment"># rest的值为[2]</span></span><br><span class="line">a, b, *rest = range(2)  <span class="comment"># rest的值为[]</span></span><br><span class="line"><span class="comment"># 在平行赋值中，*前缀只能用在一个变量前，但该变量可在任意位置</span></span><br><span class="line">&gt;&gt;&gt; a, *body, c, d = range(5) <span class="comment"># 值依次为 0, [1, 2], 3, 4</span></span><br><span class="line">&gt;&gt;&gt; *head, b, c, d = range(5) <span class="comment"># 值依次为 [0, 1], 2, 3, 4</span></span><br></pre></td></tr></table></figure>
<h2 id="嵌套元组拆包">3.2 嵌套元组拆包</h2>
<p><strong>接受表达式</strong>的元组可以是<strong>嵌套</strong>式的，例如<code>(a, b, (c, d))</code>，只要这个接受元组的嵌套结构符合表达式本身的嵌套结构，以下用嵌套元组来获取经纬度：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">metro_areas = [</span><br><span class="line">    (<span class="string">"Tokyo"</span>, <span class="string">"JP"</span>, <span class="number">36.933</span>, (<span class="number">35.689722</span>, <span class="number">139.691667</span>)),</span><br><span class="line">    (<span class="string">"Delhi NCR"</span>, <span class="string">"IN"</span>, <span class="number">21.935</span>, (<span class="number">28.613889</span>, <span class="number">77.208889</span>)),</span><br><span class="line">    (<span class="string">"Mexico City"</span>, <span class="string">"MX"</span>, <span class="number">20.142</span>, (<span class="number">19.433333</span>, <span class="number">-99.133333</span>)),</span><br><span class="line">    (<span class="string">"New York-Newark"</span>, <span class="string">"US"</span>, <span class="number">20.104</span>, (<span class="number">40.808611</span>, <span class="number">-74.020386</span>)),</span><br><span class="line">    (<span class="string">"Sao Paulo"</span>, <span class="string">"BR"</span>, <span class="number">19.649</span>, (<span class="number">-23.547778</span>, <span class="number">-46.635833</span>)),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">print(<span class="string">"&#123;:15&#125; | &#123;:^9&#125; | &#123;:^9&#125;"</span>.format(<span class="string">" "</span>, <span class="string">"lat."</span>, <span class="string">"long."</span>))</span><br><span class="line">fmt = <span class="string">"&#123;:15&#125; | &#123;:9.4f&#125; | &#123;:9.4f&#125;"</span></span><br><span class="line"><span class="comment"># 把输入元组的最后一个元素拆包到由变量构成的元组中</span></span><br><span class="line"><span class="keyword">for</span> name, cc, pop, (latitude, longitude) <span class="keyword">in</span> metro_areas:</span><br><span class="line">    <span class="keyword">if</span> longitude &lt;= <span class="number">0</span>:</span><br><span class="line">        print(fmt.format(name, latitude, longitude))</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">                |   lat.    |   long.  </span><br><span class="line">Mexico City     |   <span class="number">19.4333</span> |  <span class="number">-99.1333</span></span><br><span class="line">New York-Newark |   <span class="number">40.8086</span> |  <span class="number">-74.0204</span></span><br><span class="line">Sao Paulo       |  <span class="number">-23.5478</span> |  <span class="number">-46.6358</span></span><br></pre></td></tr></table></figure>
<h2 id="具名元组命名元组">3.3 具名元组（命名元组）</h2>
<p>上篇中有所涉及。<code>collections.namedtuple</code>是一个工厂函数，它可以创建一个带字段名的元组和一个有名字的类——这个带名字的类对调试程序有很大帮助。</p>
<p><code>namedtuple</code>构造的类的实例所消耗的内存跟元组是一样的，因为字段名都存在对于的类中。这个实例跟普通对象实例比起来要小一些，因为Python不会用<code>__dict__</code>来存放这些实例的属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">City = namedtuple(<span class="string">"City"</span>, <span class="string">"name country population coordinates"</span>)</span><br><span class="line">tokyo = City(<span class="string">"Tokyo"</span>, <span class="string">"JP"</span>, <span class="number">36.933</span>, (<span class="number">35.689722</span>, <span class="number">139.691667</span>))</span><br><span class="line">print(tokyo)</span><br><span class="line">print(tokyo.population)</span><br><span class="line">print(tokyo[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">print(City._fields)</span><br><span class="line">LatLong = namedtuple(<span class="string">"LatLong"</span>, <span class="string">"lat long"</span>)</span><br><span class="line">delhi_data = (<span class="string">"Delhi NCR"</span>, <span class="string">"IN"</span>, <span class="number">21.935</span>, LatLong(<span class="number">28.613889</span>, <span class="number">77.208889</span>))</span><br><span class="line">delhi = City._make(delhi_data)</span><br><span class="line">print(delhi._asdict())</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> delhi._asdict().items():</span><br><span class="line">    print(key + <span class="string">":"</span>, value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">City(name=<span class="string">'Tokyo'</span>, country=<span class="string">'JP'</span>, population=<span class="number">36.933</span>, coordinates=(<span class="number">35.689722</span>, <span class="number">139.691667</span>))</span><br><span class="line"><span class="number">36.933</span></span><br><span class="line">JP</span><br><span class="line">(<span class="string">'name'</span>, <span class="string">'country'</span>, <span class="string">'population'</span>, <span class="string">'coordinates'</span>)</span><br><span class="line">OrderedDict([(<span class="string">'name'</span>, <span class="string">'Delhi NCR'</span>), (<span class="string">'country'</span>, <span class="string">'IN'</span>), (<span class="string">'population'</span>, <span class="number">21.935</span>),</span><br><span class="line">             (<span class="string">'coordinates'</span>, LatLong(lat=<span class="number">28.613889</span>, long=<span class="number">77.208889</span>))])</span><br><span class="line">name: Delhi NCR</span><br><span class="line">country: IN</span><br><span class="line">population: <span class="number">21.935</span></span><br><span class="line">coordinates: LatLong(lat=<span class="number">28.613889</span>, long=<span class="number">77.208889</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>第3行：创建一个具名元组需要两个参数，一个是类名，一个是类的各字段名。后者可以是由数个字符串组成的可迭代对象，或者是由空格分隔的字符串；</li>
<li>第6,7行：可通过字段名或位置来获取一个字段的信息；</li>
<li>第9行：<code>_fields</code>属性是一个包含这个类所有字段名的元组；</li>
<li>第12行：<code>_make()</code>通过接受一个可迭代对象来生成这个类的一个实例，它的作用跟<code>City(*delhi_data)</code>是一样的。</li>
<li>第13行：<code>_asdict()</code>把具名元组以<code>collections.OrderedDict</code>的形式返回。</li>
<li>注意第10，27行！</li>
</ul>
<h2 id="作为不可变列表的元组">3.4 作为不可变列表的元组</h2>
<p>除了跟增减元素相关的方法外，元组支持列表的其他所有方法。还有一个例外就是元组没有<code>__reversed__</code>方法，但这方法只是个优化，<code>reversed(my_tuple)</code>这个方法在没有<code>__reversed__</code>的情况下也是合法的。</p>
<h1 id="切片">4. 切片</h1>
<p>切片在Python基础中介绍了一些遍历的基本操作，这里补充一些高级的用法。</p>
<h2 id="切片赋值">4.1 切片赋值</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="built_in">test</span> = list(range(6))</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">test</span></span><br><span class="line">[0, 1, 2, 3, 4, 5]</span><br><span class="line"><span class="comment"># 指定步长赋值</span></span><br><span class="line">&gt;&gt;&gt; <span class="built_in">test</span>[3::2] = [11, 22]</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">test</span></span><br><span class="line">[0, 1, 2, 11, 4, 22]</span><br><span class="line"><span class="comment"># 将列表变长（也可以变短）</span></span><br><span class="line">&gt;&gt;&gt; <span class="built_in">test</span>[1:3] = [7, 8, 9]</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">test</span></span><br><span class="line">[0, 7, 8, 9, 11, 4, 22]</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">test</span>[1:3] = 100</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;input&gt;"</span>, line 1, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: can only assign an iterable</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">test</span>[1:3] = [100]</span><br><span class="line">[0, 100, 9, 11, 4, 22]</span><br></pre></td></tr></table></figure>
<h2 id="有名字的切片">4.2 有名字的切片</h2>
<p>Python中有一个切片类（<code>slice</code>），可以用它创建切片对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">temp = <span class="string">"adfadfadfadfafasdf"</span></span><br><span class="line">TEST = slice(<span class="number">2</span>, <span class="number">8</span>)  <span class="comment"># 一般大写</span></span><br><span class="line">print(temp[TEST])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">fadfad</span><br></pre></td></tr></table></figure>
<h2 id="多维切片和省略">4.3 多维切片和省略</h2>
<p><code>[ ]</code>运算符中还可以使用以逗号分开的多个索引或者切片，比如第三方库<strong>Numpy</strong>中就用到了这个特性，二维的<code>numpy.ndarray</code>就可以用<code>a[i, j]</code>来获取值（这里的语法和C#一样，相当于C/C++中的<code>a[i][j]</code>），或者<code>a[m:n, k:l]</code>来获得二维切片。要正确处理这种语法，对象的特殊方法<code>__getitem__</code>和<code>__setitem__</code>需要以元组的形式来接收<code>a[i, j]</code>中的索引，即，如果要得到<code>a[i, j]</code>，Python会调用<code>a.__getitem__((i, j))</code>。关于多维切片的例子在本文后面演示。</p>
<p>省略（<code>ellipsis</code>）的写法是三个英语句点（<code>...</code>)，而不是Unicode码位U+2026表示的半个省略号（和前面三个句点几乎一模一样）。省略在Python解释器眼里是一个符号，而实际上它是<code>Elllipsis</code>对象的别名，而<code>Ellipsis</code>对象又是<code>ellipsis</code>类的单一实例（<code>ellipsis</code>是类名，全小写，而它的内置实例写作<code>Ellipsis</code>。这跟<code>bool</code>是小写，而它的两个实例<code>True</code>和<code>False</code>是大写一个道理）。它可以当做切片规范的一部分，也可用在函数的参数列表中，如<code>f(a,...,z)</code>，或<code>a[i: ...]</code>。在Numpy中，<code>...</code>用作多维数组切片的快捷方式，即<code>x[i, ...]</code>就是<code>x[i, :, :, :]</code>的缩写。</p>
<p>笔者暂时还没发现Python标准库中有任何<code>Ellipsis</code>或者多维索引的用法。这些句法上的特性主要是为了支持用户自定义类或者扩展，Numpy就是一个例子。</p>
<h1 id="对序列使用和">5. 对序列使用+和*</h1>
<p>通常<code>+</code>号两侧的序列由相同类型的数据所构成（当然不同类型的也可以相加），返回一个新序列。如果想把一个序列复制几份再拼接，更快捷的做法是乘一个整数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [1, 2] + [3]</span><br><span class="line">[1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; [1, 2] * 2</span><br><span class="line">[1, 2, 1, 2]</span><br><span class="line">&gt;&gt;&gt; 5 * <span class="string">"abc"</span></span><br><span class="line"><span class="string">'abcabcabcabcabc'</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：这里有深浅复制的问题，如果在<code>A * n</code>这个语句中，序列<code>A</code>中的元素<code>b</code>是对其他可变对象的引用的话，则新序列中<code>A2</code>中的<code>n</code>个元素<code>b1</code>……<code>bn</code>都指向同一个位置，即对<code>b1</code>到<code>bn</code>中任意一个赋值，都会影响其他元素。下面以一个创建多维数组的例子来说明这个情况（字符串是不可变对象，而列表是可变对象！）：</p>
<p>正确的写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">board = [[<span class="string">"_"</span>] * <span class="number">3</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line">print(board)</span><br><span class="line">board[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">"X"</span></span><br><span class="line">print(board)</span><br><span class="line"><span class="comment"># 等价于：</span></span><br><span class="line">board = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    row = [<span class="string">"_"</span>] * <span class="number">3</span></span><br><span class="line">    board.append(row)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">[[<span class="string">'_'</span>, <span class="string">'_'</span>, <span class="string">'_'</span>], [<span class="string">'_'</span>, <span class="string">'_'</span>, <span class="string">'_'</span>], [<span class="string">'_'</span>, <span class="string">'_'</span>, <span class="string">'_'</span>]]</span><br><span class="line">[[<span class="string">'_'</span>, <span class="string">'_'</span>, <span class="string">'_'</span>], [<span class="string">'_'</span>, <span class="string">'_'</span>, <span class="string">'X'</span>], [<span class="string">'_'</span>, <span class="string">'_'</span>, <span class="string">'_'</span>]]</span><br></pre></td></tr></table></figure>
<p>错误的写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">weird_board = [[<span class="string">"_"</span>] * <span class="number">3</span>] * <span class="number">3</span></span><br><span class="line">print(weird_board)</span><br><span class="line">weird_board[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">"X"</span></span><br><span class="line">print(weird_board)</span><br><span class="line"><span class="comment"># 等价于：</span></span><br><span class="line">weird_board = []</span><br><span class="line">row = [<span class="string">"_"</span>] * <span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    weird_board.append(row)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">[[<span class="string">'_'</span>, <span class="string">'_'</span>, <span class="string">'_'</span>], [<span class="string">'_'</span>, <span class="string">'_'</span>, <span class="string">'_'</span>], [<span class="string">'_'</span>, <span class="string">'_'</span>, <span class="string">'_'</span>]]</span><br><span class="line">[[<span class="string">'_'</span>, <span class="string">'_'</span>, <span class="string">'X'</span>], [<span class="string">'_'</span>, <span class="string">'_'</span>, <span class="string">'X'</span>], [<span class="string">'_'</span>, <span class="string">'_'</span>, <span class="string">'X'</span>]]</span><br></pre></td></tr></table></figure>
<h1 id="序列的增量赋值">6. 序列的增量赋值</h1>
<p>增量赋值运算符<code>+=</code>和<code>*=</code>的表现取决于它们的第一个操作对象，以<code>+=</code>为例。<code>+=</code>背后的特殊方法是<code>__iadd__</code>(用于“就地加法”)，如果一个类没有实现该方法，则会调用<code>__add__</code>。例如 <code>a += b</code>，如果<code>a</code>实现了<code>__iadd__</code>，则直接调用该方法，修改的是<code>a</code>，不会产生新对象，而如果没有实现该方法，则会调用<code>__add__</code>，执行的运算实际是 <code>a = a + b</code>，该运算会生成一个新变量，存储<code>a + b</code>的结果，然后再把该新变量赋值给<code>a</code>。</p>
<p>总体来说，可变序列一般都实现了<code>__iadd__</code>，而不可变序列根本就不支持这个操作。对不可变序列执行重复拼接操作的话，效率很低，因为每次都会生成新对象，而解释器需要把原来对象中的元素先复制到新对象中，然后再追加新元素。但<code>str</code>是个例外，因为对字符串做<code>+=</code>操作是在太普遍了，于是<code>CPython</code>对它做了优化：<code>str</code>初始化时，程序会为它预留额外的可扩展空间，因此做增量操作时不会涉及复制原有字符串到新位置的操作。</p>
<h2 id="一个关于的谜题">6.1 一个关于+=的谜题</h2>
<p>对于以下操作，大家猜想会得到什么样的结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (1, 2, [3, 4])</span><br><span class="line">&gt;&gt;&gt; t[2] += [5, 6]</span><br></pre></td></tr></table></figure>
<p>它的结果是报错，但<code>t</code>依然被改变了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 紧接上述代码</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;input&gt;"</span>, line 1, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'tuple'</span> object does not support item assignment</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">(1, 2, [3, 4, 5, 6])</span><br><span class="line"><span class="comment"># 如果是t[2].extend([5, 6])则不会报错</span></span><br></pre></td></tr></table></figure>
<p>如果我们看Python表达式 <code>s[a] += b</code>的字节码，便不难理解上述结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import dis</span><br><span class="line">&gt;&gt;&gt; dis.dis(<span class="string">"s[a] += b"</span>)</span><br><span class="line">  1           0 LOAD_NAME                0 (s)</span><br><span class="line">              2 LOAD_NAME                1 (a)</span><br><span class="line">              4 DUP_TOP_TWO</span><br><span class="line">              6 BINARY_SUBSCR</span><br><span class="line">              8 LOAD_NAME                2 (b)</span><br><span class="line">             10 INPLACE_ADD</span><br><span class="line">             12 ROT_THREE</span><br><span class="line">             14 STORE_SUBSCR</span><br><span class="line">             16 LOAD_CONST               0 (None)</span><br><span class="line">             18 RETURN_VALUE</span><br></pre></td></tr></table></figure>
<p>从上述结果可以看出：</p>
<ul>
<li>第6行：将<code>s[a]</code>的值存入<code>TOS</code>(Top Of Stack，栈顶)；</li>
<li>第8行：计算<code>TOS += b</code>， 这一步能够完成，因为<code>TOS</code>指向一个可变对象；</li>
<li>第14行：<code>s[a] = TOS</code>，报错，因为<code>s</code>是个元组，不可变。</li>
</ul>
<p>从上述操作可以得到3个教训：</p>
<ul>
<li>不要把可变对象放在元组中；</li>
<li>增量赋值不是一个原子操作。从上面的结果可以看出，它虽抛出了异常，但仍完成了操作；</li>
<li>查看Python字节码并不难，而且它对我们了解代码背后的运行机制很有帮助。</li>
</ul>
<h1 id="用bisect来管理已排序的序列">7. 用bisect来管理已排序的序列</h1>
<p><code>bisect</code>模块包含两个主要函数，<code>bisect</code>和<code>insort</code>，这两个函数都利用<strong>二分查找算法</strong>在有序列表中查找或插入元素。</p>
<p><code>bisect</code>用于查找元素的位置：<code>biisect(haystack, needle)</code>。它返回<code>needle</code>在<code>haystack</code>中的位置<code>index</code>，如果要插入元素，可以在找到位置后，再调用<code>haystack.insert(index, new_ele)</code>，但也可以用<code>bisect</code>模块中的<code>insert</code>直接插入，并且该方法速度更快。</p>
<p>Python的高产贡献者Raymond Hettinger写了一个排序集合模块<code>sortedcollection</code>，该模块集成了<code>bisect</code>功能，且比独立的<code>bisect</code>更易用。</p>
<p><code>bisect</code>需要注意两点：</p>
<ul>
<li>两个可选参数<code>lo</code>和<code>hi</code>：<code>lo</code>默认值是0，<code>hi</code>默认值是序列的长度，即<code>len()</code>作用域该序列的返回值。</li>
<li><code>bisect</code>函数其实是<code>bisect_right</code>函数的别名，它返回的位置是与<code>needle</code>相等的元素的后一个位置，而它的兄弟函数<code>bisect_left</code>则返回的是与<code>needle</code>相等的元素的位置。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import bisect</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">test</span> = [1, 2, 3, 4, 5, 6, 7]</span><br><span class="line">&gt;&gt;&gt; bisect.bisect(<span class="built_in">test</span>,1)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; bisect.bisect_left(<span class="built_in">test</span>,1)</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>相应的，模块中<code>insort</code>也有两个版本，<code>insort</code>是<code>insort_right</code>的别名，它也有两个可选参数<code>lo</code>和<code>hi</code>，<code>insort_left</code>的背后调用的就是<code>bisect_left</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bisect.insort(<span class="built_in">test</span>, 1.0)</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">test</span></span><br><span class="line">[1, 1.0, 2, 3, 4, 5, 6, 7]</span><br><span class="line">&gt;&gt;&gt; bisect.insort_left(<span class="built_in">test</span>, 1.0)</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">test</span></span><br><span class="line">[1.0, 1, 1.0, 2, 3, 4, 5, 6, 7]</span><br></pre></td></tr></table></figure>
<h1 id="当列表不是首选时">8. 当列表不是首选时</h1>
<p>当我们有特定的数据集时，<code>list</code>并不一定是首选，比如存放1000万个浮点数，数组（<code>array</code>）的效率就要高很多，因为数组的背后并不是<code>float</code>对象，而是数字的机器翻译，也就是字节表述。这点和C语言中的数组一样。再比如，如果要频繁对序列做先进先出的操作，<code>deque</code>（双端队列）的速度应该会更快。</p>
<h2 id="数组">8.1 数组</h2>
<p>如果需要一个只含数字的列表，<code>array.array</code>会比<code>list</code>更高效，它支持所有跟可变列表有关的操作，包括<code>.pop</code>，<code>.insert</code>，<code>.extend</code>等。另外数组还支持从文件读取和存入文件的更快的方法，比如<code>.frombytes</code>和<code>.tofile</code>。</p>
<p>数组跟C语言数组一样精简，创建一个数组需要指定一个类型码，这个类型码用来表示在底层的C语言应该存放怎样的数据类型，以下是<code>array.array</code>的操作例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">print(<span class="string">"\n\n"</span>)</span><br><span class="line">floats = array(<span class="string">"d"</span>, (random() <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span> ** <span class="number">7</span>)))</span><br><span class="line">print(floats[<span class="number">-1</span>])</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"floats.bin"</span>, <span class="string">"wb"</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    floats.tofile(fp)</span><br><span class="line"></span><br><span class="line">floats2 = array(<span class="string">"d"</span>)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"floats.bin"</span>, <span class="string">"rb"</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    floats2.fromfile(fp, <span class="number">10</span> ** <span class="number">7</span>)</span><br><span class="line">print(floats2[<span class="number">-1</span>])</span><br><span class="line">print(floats2 == floats)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line"><span class="number">0.8220703930498271</span></span><br><span class="line"><span class="number">0.8220703930498271</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>有人做过实验，用<code>array.fromfile</code>从一个二进制文件读出1000万个双精度浮点数只需要0.1秒（笔者电脑有点年代了，达不到这个速度），速度是从文本文件里读取的60倍，因为后者会使用内置的float方法把每一行文字转换成浮点数。另外，<code>array.tofile</code>写入二进制文件也比写入文本文件快7倍。另外，这1000万个数的bin文件只占8千万字节，如果是文本文件的话，需要181515739字节。</p>
<p>另一个快速序列化数字类型的方法是使用<code>pickle</code>模块，<code>pickle.dump</code>处理浮点数组的速度几乎和<code>array.tofile</code>一样快，而且<code>pickle</code>可以处理几乎所有的内置数字类型</p>
<h2 id="内存视图memoryview">8.2 内存视图memoryview</h2>
<p><code>memoryview</code>是个内置类，它让用户在不复制内存的情况下操作同一个数组的不同切片。<code>memoryview</code>的概念受到了Numpy的启发。</p>
<p>内存视图其实是泛化和去数学化的Numpy数组。它让你在不需要复制内容的前提下，在数据结构之间共享内存。其中数据结构可以是任何形式，比如PIL图片、SQLite数据库和Numpy数组等待。这个功能在处理大型数据集合的时候非常重要。</p>
<p><code>memoryview.cast</code>的概念跟数组模型类似，能用不同的方式读取同一块内存数据，而且内存字节不会随意移动。这有点类似于C语言的类型转换。<code>memoryview.cast</code>会把同一块内存里的内容打包成一个全新的<code>memoryview</code>对象返回。</p>
<p>下面这个例子精确地修改一个数组的某个字节：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> array</span><br><span class="line"><span class="comment"># 16位二进制整数</span></span><br><span class="line">numbers = array.array(<span class="string">"h"</span>, [<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">memv = memoryview(numbers)</span><br><span class="line">print(len(memv))</span><br><span class="line">print(memv[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 转换成8位的无符号整数</span></span><br><span class="line">memv_oct = memv.cast(<span class="string">"B"</span>)</span><br><span class="line">print(memv_oct.tolist())</span><br><span class="line"><span class="comment"># 这个坐标刚好是第3个16位二进制数的高位字节</span></span><br><span class="line">memv_oct[<span class="number">5</span>] = <span class="number">4</span></span><br><span class="line">print(numbers)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">-2</span></span><br><span class="line">[<span class="number">254</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>]</span><br><span class="line">array(<span class="string">'h'</span>, [<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1024</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<h2 id="numpy和scipy">8.3 NumPy和SciPy</h2>
<p>拼接这NumPy和SciPy提供的高阶数组和矩阵操作，Python称为科学计算应用的主流语言。NumPy实现了多维同质数组（homogeneous array）和矩阵，这些数据结构不但能处理数字，还能存放其他由用户定义的记录。SciPy是基于NumPy的另一个库，他提供了很多跟科学计算有关的算法，专为线性代数、数值积分和统计学而设计。SciPy的高校和可靠性归功于背后的C和Fortran代码，而这些跟计算有关的部分都源自于Netlib。SciPy把基于C和Fortran的工业级数学计算功能用交互式且高度抽象的Python包装起来。</p>
<p>以下是一些NumPy二维数组的基本操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import numpy</span><br><span class="line">&gt;&gt;&gt; a = numpy.arange(12)</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="built_in">type</span>(a)</span><br><span class="line">&lt;class <span class="string">'numpy.ndarray'</span>&gt;</span><br><span class="line"><span class="comment"># 数组a的维度</span></span><br><span class="line">&gt;&gt;&gt; a.shape</span><br><span class="line">(12,)</span><br><span class="line"><span class="comment"># 手动设置数组维度，3行4列</span></span><br><span class="line">&gt;&gt;&gt; a.shape = 3, 4</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">array([[ 0,  1,  2,  3],</span><br><span class="line">       [ 4,  5,  6,  7],</span><br><span class="line">       [ 8,  9, 10, 11]])</span><br><span class="line"><span class="comment"># 第2行</span></span><br><span class="line">&gt;&gt;&gt; a[2]</span><br><span class="line">array([ 8,  9, 10, 11])</span><br><span class="line"><span class="comment"># 第2行第1列元素</span></span><br><span class="line">&gt;&gt;&gt; a[2, 1]</span><br><span class="line">9</span><br><span class="line"><span class="comment"># 第1列元素</span></span><br><span class="line">&gt;&gt;&gt; a[:, 1]</span><br><span class="line">array([1, 5, 9])</span><br><span class="line"><span class="comment"># 转置</span></span><br><span class="line">&gt;&gt;&gt; a.transpose()</span><br><span class="line">array([[ 0,  4,  8],</span><br><span class="line">       [ 1,  5,  9],</span><br><span class="line">       [ 2,  6, 10],</span><br><span class="line">       [ 3,  7, 11]])</span><br><span class="line"><span class="comment"># 全部数据乘2</span></span><br><span class="line">&gt;&gt;&gt; a *= 2</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">array([[ 0,  2,  4,  6],</span><br><span class="line">       [ 8, 10, 12, 14],</span><br><span class="line">       [16, 18, 20, 22]])</span><br></pre></td></tr></table></figure>
<p>NumPy也可读取、写入文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从文本文件中读取数据</span></span><br><span class="line">floats = numpy.loadtxt(<span class="string">"filename.txt"</span>)</span><br><span class="line"><span class="comment"># 把数组存入后缀为.npy的二进制文件，会自动加后缀名</span></span><br><span class="line">numpy.save(<span class="string">"filesave"</span>, floats)</span><br><span class="line"><span class="comment"># 从.npy文件中读取数据，这次load方法利用了一种叫做内存映射的机制，它让</span></span><br><span class="line"><span class="comment"># 我们在内存不足的时候仍可以对数组切片</span></span><br><span class="line">floats2 = numpy.load(<span class="string">"filesave.npy"</span>, <span class="string">"r+"</span>)</span><br></pre></td></tr></table></figure>
<p>这两个库都异常强大，它们也是一些其他库的基础，比如Pandas和Blaze数据分析库。</p>
<h2 id="双向队列和其他形式的队列">8.4 双向队列和其他形式的队列</h2>
<p>利用<code>.append</code>和<code>.pop</code>方法，可以将列表（<code>list</code>）变成栈和队列。但删除列表的第一个元素或在第一个元素前插入元素之类的操作会很耗时，因为会移动数据。如果经常要在列表两端操作数据，推荐使用<code>collections.deque</code>类（双向队列）。它是一个线程安全、可快速从两端添加删除元素的数据类型。下面是它的操作示范：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># maxlen是个可选参数，表示队列最大长度，该属性一旦设定变不能修改</span></span><br><span class="line">&gt;&gt;&gt; dq = deque(range(10), maxlen=10)</span><br><span class="line">&gt;&gt;&gt; dq</span><br><span class="line">deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10)</span><br><span class="line"><span class="comment"># 队列旋转操作，接收参数n，当n＞0时，队列最右边n个元素移动到最左边</span></span><br><span class="line"><span class="comment"># 当n＜0时，队列最左边n个元素移动到最右边</span></span><br><span class="line">&gt;&gt;&gt; dq.rotate(3)</span><br><span class="line">&gt;&gt;&gt; dq</span><br><span class="line">deque([7, 8, 9, 0, 1, 2, 3, 4, 5, 6], maxlen=10)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; dq.rotate(-4)</span><br><span class="line">&gt;&gt;&gt; dq</span><br><span class="line">deque([1, 2, 3, 4, 5, 6, 7, 8, 9, 0], maxlen=10)</span><br><span class="line"><span class="comment"># 队列左边添加一个元素-1，由于队列长10，所以元素0被删除</span></span><br><span class="line">&gt;&gt;&gt; dq.appendleft(-1)</span><br><span class="line">&gt;&gt;&gt; dq</span><br><span class="line">deque([-1, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10)</span><br><span class="line"><span class="comment"># 队列右边添加三个元素，挤掉了最前面的三个元素</span></span><br><span class="line">&gt;&gt;&gt; dq.extend([11, 22, 33])</span><br><span class="line">&gt;&gt;&gt; dq</span><br><span class="line">deque([3, 4, 5, 6, 7, 8, 9, 11, 22, 33], maxlen=10)</span><br><span class="line"><span class="comment"># 注意添加的顺序</span></span><br><span class="line">&gt;&gt;&gt; dq.extendleft([10, 20, 30, 40])</span><br><span class="line">&gt;&gt;&gt; dq</span><br><span class="line">deque([40, 30, 20, 10, 3, 4, 5, 6, 7, 8], maxlen=10)</span><br></pre></td></tr></table></figure>
<p>该数据结构还有许多其他操作，<code>append</code>和<code>popleft</code>是原子操作，可在多线程中安全地使用，不用担心资源锁的问题。</p>
<h2 id="python标准库中的队列">8.5 Python标准库中的队列</h2>
<ul>
<li><code>queue</code>：提供了同步（线程安全）类<code>Queue</code>，<code>LifoQueue</code>和<code>PriorityQueue</code>，不同的<strong>线程</strong>可以利用这些数据类型来交换信息。这三个类在队列满的时候不会丢掉旧元素，而是被锁住，直到某线程移除了某个元素。这一特性让这些类很适合用来控制活跃线程的数量。</li>
<li><code>multiprocessing</code>：实现了自己的<code>Queue</code>，和<code>queue.Queue</code>类似，设计给<strong>进程</strong>间通信用的。同时还有一个专门的<code>multiprocessing.JoinableQueue</code>类，该类让任务管理变得方便。</li>
<li><code>asyncio</code>：从Python3.4新增的包，包含<code>Queue</code>，<code>LifoQueue</code>，<code>PriorityQueue</code>和<code>JoinableQueue</code>，这些类受<code>queue</code>和<code>multiprocessing</code>模块的影响，但是为异步编程里的任务管理提供了专门的便利。</li>
<li><code>heapq</code>：和上述三个模块不同，它没有队列类，而是提供了<code>heappush</code>和<code>heappop</code>方法，让用户可以把可变序列当作堆队列或者优先队列来使用。</li>
</ul>
<h1 id="补充">9. 补充</h1>
<ul>
<li>Python入门教材往往会强调列表可以容纳不同类型的元素，但实际上这样做并没有什么特别的好处。之所以用列表来存放东西，是期待在稍后使用它的时候，其中的元素能有一些共有的特性。Python3中，如果列表里的元素不能比较大小，则是不能对列表进行排序的。元组则恰恰相反，它经常用来存放不同类型的元素，这也符合它的本质，元组就是用作存放彼此之间没有关系的数据的记录。</li>
<li><code>list.sort</code>，<code>sorted</code>，<code>max</code>和<code>min</code>函数的<code>key</code>参数是个很棒的设计，相比于其他语言中双参数比较函数，这里的参数<code>key</code>只需提供一个单参数函数来提取或计算一个值作为比较大小的标准。说它更高效，是因为在每个元素上，<code>key</code>函数只被调用一次。诚然，在排序的时候，Python总会比较两个键（key），但那一阶段的计算发生在C语言那一层，这样会比调用用户自定义的Python比较函数更快。<code>key</code>参数也能让你对一个混有数字字符和数值的列表进行排序，只需决定到底是将字符看做数值（数值排序），还是将数值看成字符（ASCII排序），即<code>key</code>到底是等于<code>int</code>还是等于<code>str</code>。</li>
<li><code>sorted</code>和<code>list.sort</code>背后的排序算法是<code>Timsort</code>，它是一种自适应算法，会根据原始数据的顺序特点交替使用插入排序（数列基本有序时）和归并排序（没什么规律时），以达到最佳效率。这样的算法被证明是有效的，因为来自真实世界的数据通常是有一定的顺序特点的。<code>Timsort</code>在2002年的时候首次用在<code>CPython</code>中，自2009年起，Java和Android也开始使用这个算法。后来该算法被广为人知，是因为在Google对Sun的侵权案中，Oracle把<code>Timsort</code>中的一些相关代码作为了呈堂证供。<code>Timsort</code>的创始人是Tim Peters，一位高产的Python核心开发者，他也是“Python之禅”的作者之一。</li>
</ul>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>嘴强黑铁
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://www.zuiqiangiron.xyz/2018/05/06/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF21-%E5%BA%8F%E5%88%97%E6%9E%84%E6%88%90%E7%9A%84%E6%95%B0%E7%BB%84/" title="Python学习之路21-序列构成的数组">https://www.zuiqiangiron.xyz/2018/05/06/Python学习之路21-序列构成的数组/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Python/" rel="tag"># Python</a>
              <a href="/tags/Python%E8%BF%9B%E9%98%B6/" rel="tag"># Python进阶</a>
              <a href="/tags/Python%E5%BA%8F%E5%88%97/" rel="tag"># Python序列</a>
          </div>

        
  <div class="post-widgets">
    <div class="wp_rating">
      <div id="wpac-rating"></div>
    </div>
  </div>


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/05/05/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF20-Python%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/" rel="prev" title="Python学习之路20-数据模型">
      <i class="fa fa-chevron-left"></i> Python学习之路20-数据模型
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/05/13/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF22-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/" rel="next" title="Python学习之路22-字典和集合">
      Python学习之路22-字典和集合 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#内置序列类型概览"><span class="nav-number">1.</span> <span class="nav-text">1. 内置序列类型概览</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#列表推导和生成器表达式"><span class="nav-number">2.</span> <span class="nav-text">2. 列表推导和生成器表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#列表推导同filter和map比较"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 列表推导同filter和map比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#笛卡尔积"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 笛卡尔积</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#生成器表达式"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 生成器表达式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#元组"><span class="nav-number">3.</span> <span class="nav-text">3. 元组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#元祖拆包"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 元祖拆包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#嵌套元组拆包"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 嵌套元组拆包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#具名元组命名元组"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 具名元组（命名元组）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#作为不可变列表的元组"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 作为不可变列表的元组</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#切片"><span class="nav-number">4.</span> <span class="nav-text">4. 切片</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#切片赋值"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 切片赋值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#有名字的切片"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 有名字的切片</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多维切片和省略"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 多维切片和省略</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#对序列使用和"><span class="nav-number">5.</span> <span class="nav-text">5. 对序列使用+和*</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#序列的增量赋值"><span class="nav-number">6.</span> <span class="nav-text">6. 序列的增量赋值</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一个关于的谜题"><span class="nav-number">6.1.</span> <span class="nav-text">6.1 一个关于+&#x3D;的谜题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#用bisect来管理已排序的序列"><span class="nav-number">7.</span> <span class="nav-text">7. 用bisect来管理已排序的序列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#当列表不是首选时"><span class="nav-number">8.</span> <span class="nav-text">8. 当列表不是首选时</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数组"><span class="nav-number">8.1.</span> <span class="nav-text">8.1 数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存视图memoryview"><span class="nav-number">8.2.</span> <span class="nav-text">8.2 内存视图memoryview</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#numpy和scipy"><span class="nav-number">8.3.</span> <span class="nav-text">8.3 NumPy和SciPy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#双向队列和其他形式的队列"><span class="nav-number">8.4.</span> <span class="nav-text">8.4 双向队列和其他形式的队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#python标准库中的队列"><span class="nav-number">8.5.</span> <span class="nav-text">8.5 Python标准库中的队列</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#补充"><span class="nav-number">9.</span> <span class="nav-text">9. 补充</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="嘴强黑铁"
      src="/images/touxiang.jpg">
  <p class="site-author-name" itemprop="name">嘴强黑铁</p>
  <div class="site-description" itemprop="description">一顿操作猛如虎</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">76</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">76</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">嘴强黑铁</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.2
  </div>
  <div class="addthis_inline_share_toolbox">
    <script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e731fa9610694ef" async="async"></script>
  </div>

        
<div class="busuanzi-count">
  <script pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.getAttribute('pjax') !== null) {
      script.setAttribute('pjax', '');
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  



  <script pjax>
  if (CONFIG.page.isPost) {
    wpac_init = window.wpac_init || [];
    wpac_init.push({
      widget: 'Rating',
      id    : 24025,
      el    : 'wpac-rating',
      color : 'fc6423'
    });
    (function() {
      if ('WIDGETPACK_LOADED' in window) return;
      WIDGETPACK_LOADED = true;
      var mc = document.createElement('script');
      mc.type = 'text/javascript';
      mc.async = true;
      mc.src = '//embed.widgetpack.com/widget.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
    })();
  }
  </script>

  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://zuiqiangiron.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "https://www.zuiqiangiron.xyz/2018/05/06/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF21-%E5%BA%8F%E5%88%97%E6%9E%84%E6%88%90%E7%9A%84%E6%95%B0%E7%BB%84/";
    this.page.identifier = "2018/05/06/Python学习之路21-序列构成的数组/";
    this.page.title = "Python学习之路21-序列构成的数组";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://zuiqiangiron.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

    </div>
</body>
</html>
