<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="Y0-gFMBzGnbrueUrh8PjkmnvCGItjob2oR3HjG9SVnE">
  <meta name="msvalidate.01" content="97A49017D4D536B99438C4EE0E9FBA3F">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.zuiqiangiron.xyz","root":"/","scheme":"Gemini","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="《流畅的Python》笔记。 本篇将从最简单的装饰器开始，逐渐深入到闭包的概念，然后实现参数化装饰器，最后介绍标准库中常用的装饰器。">
<meta property="og:type" content="article">
<meta property="og:title" content="Python学习之路26-函数装饰器和闭包">
<meta property="og:url" content="https://www.zuiqiangiron.xyz/2018/05/31/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF26-%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8%E5%92%8C%E9%97%AD%E5%8C%85/index.html">
<meta property="og:site_name" content="嘴强黑铁">
<meta property="og:description" content="《流畅的Python》笔记。 本篇将从最简单的装饰器开始，逐渐深入到闭包的概念，然后实现参数化装饰器，最后介绍标准库中常用的装饰器。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://res.cloudinary.com/vpointer/image/upload/v1527828546/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF26-%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8%E5%92%8C%E9%97%AD%E5%8C%85/1527397649944.png">
<meta property="article:published_time" content="2018-05-31T14:00:00.000Z">
<meta property="article:modified_time" content="2018-05-31T14:00:00.000Z">
<meta property="article:author" content="嘴强黑铁">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="Python进阶">
<meta property="article:tag" content="装饰器">
<meta property="article:tag" content="闭包">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://res.cloudinary.com/vpointer/image/upload/v1527828546/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF26-%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8%E5%92%8C%E9%97%AD%E5%8C%85/1527397649944.png">

<link rel="canonical" href="https://www.zuiqiangiron.xyz/2018/05/31/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF26-%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8%E5%92%8C%E9%97%AD%E5%8C%85/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Python学习之路26-函数装饰器和闭包 | 嘴强黑铁</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-161480657-1"></script>
    <script pjax>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-161480657-1');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">嘴强黑铁</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">天下事以难而废者十之一，以惰而废者十之九</h1>
      
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="search-pop-overlay">
  <div class="popup search-popup">
      <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

  </div>
</div>

  </div>
</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.zuiqiangiron.xyz/2018/05/31/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF26-%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8%E5%92%8C%E9%97%AD%E5%8C%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.jpg">
      <meta itemprop="name" content="嘴强黑铁">
      <meta itemprop="description" content="一顿操作猛如虎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="嘴强黑铁">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          Python学习之路26-函数装饰器和闭包
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-31 22:00:00" itemprop="dateCreated datePublished" datetime="2018-05-31T22:00:00+08:00">2018-05-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/Python%E8%BF%9B%E9%98%B6/" itemprop="url" rel="index"><span itemprop="name">Python进阶</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2018/05/31/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF26-%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8%E5%92%8C%E9%97%AD%E5%8C%85/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/05/31/Python学习之路26-函数装饰器和闭包/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>《流畅的Python》笔记。</p>
<p>本篇将从最简单的装饰器开始，逐渐深入到闭包的概念，然后实现参数化装饰器，最后介绍标准库中常用的装饰器。</p>
</blockquote>
<a id="more"></a>
<h1 id="初步认识装饰器">1. 初步认识装饰器</h1>
<p>函数装饰器用于在源代码中“标记”函数，以某种方式增强函数的行为。装饰器就是函数，或者说是可调用对象，它以另一个函数为参数，最后返回一个函数，但这个返回的函数并不一定是原函数。</p>
<h2 id="装饰器基础用法">1.1 装饰器基础用法</h2>
<p>以下是装饰器最基本的用法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码1</span></span><br><span class="line"><span class="comment">#装饰器用法</span></span><br><span class="line"><span class="meta">@decorate</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">()</span>:</span> <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上述代码等价于以下代码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">()</span>:</span> <span class="keyword">pass</span></span><br><span class="line">target = decorate(target)</span><br></pre></td></tr></table></figure>
<p>即，最终的<code>target</code>函数是由<code>decorate(target)</code>返回的函数。下面这个例子说明了这一点：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"running inner()"</span>)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@deco</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"running target()"</span>)</span><br><span class="line"></span><br><span class="line">target()</span><br><span class="line">print(target)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">running inner() <span class="comment"># 输出的是装饰器内部定义的函数的调用结果</span></span><br><span class="line">&lt;function deco.&lt;locals&gt;.inner at <span class="number">0x000001AF32547D90</span>&gt;</span><br></pre></td></tr></table></figure>
<p>从上面可看出，装饰器的一大特性是能<strong>把被装饰的函数替换成其他函数</strong>。但严格说来，装饰器只是语法糖（<em>语法糖：在编程语言中添加某种语法，但这种语法对语言的功能没有影响，只是更方便程序员使用</em>）。</p>
<p><strong>装饰器还可以叠加</strong>。下面是一个说明，具体例子见后面章节：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码3</span></span><br><span class="line"><span class="meta">@d1</span></span><br><span class="line"><span class="meta">@d2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span> <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#上述代码等价于以下代码：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span> <span class="keyword">pass</span></span><br><span class="line">f = d1(d2(f))</span><br></pre></td></tr></table></figure>
<h2 id="python何时执行装饰器">1.2 Python何时执行装饰器</h2>
<p>装饰器的另一个关键特性是，<strong>它在被装饰的函数定义后立即运行</strong>，这通常是在<strong>导入时</strong>，即Python加载模块时：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码4</span></span><br><span class="line">registry = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">"running register(%s)"</span> % func)</span><br><span class="line">    registry.append(func)</span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"running f1()"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"running f2()"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(<span class="string">"running in main"</span>)</span><br><span class="line">    print(<span class="string">"registry -&gt;"</span>, registry)</span><br><span class="line">    f1()</span><br><span class="line">    f2()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">running register(&lt;function f1 at <span class="number">0x0000027745397840</span>&gt;)</span><br><span class="line">running <span class="keyword">in</span> main <span class="comment"># 进入到主程序</span></span><br><span class="line">registry -&gt; [&lt;function f1 at 0x0000027745397840&gt;]</span><br><span class="line">running f1()</span><br><span class="line">running f2()</span><br></pre></td></tr></table></figure>
<p>装饰器<code>register</code>在加载模块时就对<code>f1()</code>进行了注册，所以当运行主程序时，列表<code>registry</code>并不为空。</p>
<p><strong>函数装饰器在导入模块时立即执行，而被装饰的函数只在明确调用时运行。</strong>这突出了Python程序员常说的<strong>导入时</strong>和<strong>运行时</strong>之间的区别。</p>
<p>装饰器在真实代码中的使用方式与<code>代码4</code>中有所不同：</p>
<ul>
<li>装饰器和被装饰函数一般不在一个模块中，通常装饰器定义在一个模块中，然后应用到其他模块中的函数上；</li>
<li>大多数装饰器会在内部定义一个函数，然后将其返回。</li>
</ul>
<p><code>代码4</code>中的装饰器原封不动地返回了传入的函数。这种装饰器并不是没有用，正如<code>代码4</code>中的装饰器的名字一样，这类装饰器常充当了注册器，很多Web框架就使用了这种方法。下一小节也是该类装饰器的一个例子。</p>
<h2 id="使用装饰器改进策略模式">1.3 使用装饰器改进策略模式</h2>
<p>上一篇中我们用Python函数改进了传统的策略模式，其中，我们定义了一个<code>promos</code>列表来记录有哪些具体策略，当时的做法是用<code>globals()</code>函数来获取具体的策略函数，现在我们用装饰器来改进这一做法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码5，对之前的代码进行了简略</span></span><br><span class="line">promos = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">promotion</span><span class="params">(promo_func)</span>:</span> <span class="comment"># 只充当了注册器</span></span><br><span class="line">    promos.append(promo_func)</span><br><span class="line">    <span class="keyword">return</span> promo_func</span><br><span class="line"></span><br><span class="line"><span class="meta">@promotion</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fidelity</span><span class="params">(order)</span>:</span> <span class="keyword">pass</span>  </span><br><span class="line"></span><br><span class="line"><span class="meta">@promotion</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bulk_item</span><span class="params">(order)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@promotion</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">large_order</span><span class="params">(order)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">best_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> max(promo(order) <span class="keyword">for</span> promo <span class="keyword">in</span> promos)</span><br></pre></td></tr></table></figure>
<p>该方案相比之前的方案，有以下三个优点：</p>
<ul>
<li>促销策略函数无需使用特殊名字，即不用再以<code>_promo</code>结尾</li>
<li><code>@promotion</code>装饰器突出了被装饰函数的作用，还便于临时禁用某个促销策略（只需将装饰器注释掉）</li>
<li>促销策略函数在任何地方定义都行，只要加上装饰器即可。</li>
</ul>
<h1 id="闭包">2. 闭包</h1>
<p>正如前文所说，多数装饰器会在内部定义函数，并将其返回，已替换掉传入的函数。这个机制的实现就要靠<strong>闭包</strong>，但在理解闭包之前，先来看看Python中的变量作用域。</p>
<h2 id="变量作用域规则">2.1 变量作用域规则</h2>
<p>通过下述例子来解释局部变量和全局变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码6</span></span><br><span class="line">&gt;&gt;&gt; def f1(a):</span><br><span class="line">...     <span class="built_in">print</span>(a)</span><br><span class="line">...     <span class="built_in">print</span>(b)</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; f1(3)</span><br><span class="line">3</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  -- snip --</span><br><span class="line">NameError: name <span class="string">'b'</span> is not defined</span><br></pre></td></tr></table></figure>
<p>当代码运行到<code>print(a)</code>时，Python查找变量<code>a</code>，发现变量<code>a</code>存在于局部作用域中，于是顺利执行；当运行到<code>print(b)</code>时，python查找变量<code>b</code>，发现局部作用域中并没有变量<code>b</code>，便接着查找全局作用域，发现也没有变量<code>b</code>，最终报错。正确的调用方式相信大家也知道，就是在调用<code>f1(3)</code>之前给变量<code>b</code>赋值。</p>
<p>我们再看如下代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码7</span></span><br><span class="line">&gt;&gt;&gt; b = 6</span><br><span class="line">&gt;&gt;&gt; def f2(a):</span><br><span class="line">...     <span class="built_in">print</span>(a)</span><br><span class="line">...     <span class="built_in">print</span>(b)</span><br><span class="line">...     b = 9</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; f2(3)</span><br><span class="line">3</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  -- snip --</span><br><span class="line">UnboundLocalError: <span class="built_in">local</span> variable <span class="string">'b'</span> referenced before assignment</span><br></pre></td></tr></table></figure>
<p>按理说不应该报错，并且<code>b</code>的值应该打印为6，但结果却不是这样。</p>
<p>事实是：变量<code>b</code>本来是全局变量，但由于在<code>f2()</code>中我们为变量<code>b</code>赋了值，于是Python在局部作用域中也注册了一个名为<code>b</code>的变量（全局变量<code>b</code>依然存在，有编程基础的同学应该知道，这叫做“覆盖”）。当Python执行到<code>print(b)</code>语句时，Python先搜索局部作用域，发现其中有变量<code>b</code>，但是<code>b</code>此时还没有被赋值（全局变量<code>b</code>被覆盖，而局部变量<code>b</code>的赋值语句在该句后面），于是Python报错。</p>
<p>如果不想<code>代码7</code>报错，则需要使用<code>global</code>语句，将变量<code>b</code>声明为全局变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(a)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">global</span> b</span><br><span class="line"><span class="meta">... </span>    -- snip --</span><br></pre></td></tr></table></figure>
<h2 id="闭包的概念">2.2 闭包的概念</h2>
<p>现在开始真正接触闭包。闭包指延伸了作用域的函数，它包含函数定义体中引用，但不在定义体中定义的<strong>非全局变量</strong>，即这类函数能访问定义体之外的非全局变量。只有涉及嵌套函数时才有闭包问题。</p>
<p>下面用一个例子来说明闭包以及非全局变量。定义一个计算某商品一段时间内均价的函数<code>avg</code>，它的表现如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码9</span></span><br><span class="line">&gt;&gt;&gt; avg(10)</span><br><span class="line">10.0</span><br><span class="line">&gt;&gt;&gt; avg(11)</span><br><span class="line">10.5</span><br><span class="line">&gt;&gt;&gt; avg(12)</span><br><span class="line">11.0</span><br></pre></td></tr></table></figure>
<p>假定商品价格每天都在变化，因此需要一个变量来保存这些值。如果用类的思想，我们可以定义一个可调用对象，把这些值存到内部属性中，然后实现<code>__call__</code>方法，让其表现得像函数；但如果按装饰器的思想，可以定义一个如下的嵌套函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码10</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line">    series = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">        series.append(new_value)</span><br><span class="line">        total = sum(series)</span><br><span class="line">        <span class="keyword">return</span> total / len(series)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> averager</span><br></pre></td></tr></table></figure>
<p>然后以如下方式使用这个函数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码11</span></span><br><span class="line">&gt;&gt;&gt; avg = make_averager()</span><br><span class="line">&gt;&gt;&gt; avg(10)</span><br><span class="line">10.0</span><br><span class="line">-- snip --</span><br></pre></td></tr></table></figure>
<p>不知道大家刚接触这个内部的<code>averager()</code>函数时有没有疑惑：<code>代码11</code>中，当执行<code>avg(10)</code>时，它是到哪里去找的变量<code>series</code>？<code>series</code>是函数<code>make_averager()</code>的局部变量，当<code>make_averager()</code>返回了<code>averager()</code>后，它的局部作用域就消失了，所以按理说<code>series</code>也应该跟着消失，并且上述代码应该报错才对。</p>
<p>事实上，在<code>averager</code>函数中，<code>series</code>是<strong>自由变量</strong>（free variable），即未在局部作用域中绑定的变量。这里，自由变量<code>series</code>和内部函数<code>averager</code>共同组成了闭包，参考下图：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828546/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF26-%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8%E5%92%8C%E9%97%AD%E5%8C%85/1527397649944.png" /></p>
<p>实际上，Python在<code>averager</code>的<code>__code__</code>属性中保存了局部变量和自由变量的名称，在<code>__closure__</code>属性中保存了自由变量的值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码12，注意这些变量的单词含义，一目了然</span></span><br><span class="line">&gt;&gt;&gt; avg.__code__.co_varnames  <span class="comment"># co_varnames保存局部变量的名称</span></span><br><span class="line">(<span class="string">'new_value'</span>, <span class="string">'total'</span>)</span><br><span class="line">&gt;&gt;&gt; avg.__code__.co_freevars <span class="comment"># co_freevars保存自由变量的名称</span></span><br><span class="line">(<span class="string">'series'</span>,)</span><br><span class="line">&gt;&gt;&gt; avg.__closure__ <span class="comment"># 单词closure就是闭包的意思</span></span><br><span class="line"><span class="comment"># __closure__是一个cell对象列表，其中的元素和co_freevars元组一一对应</span></span><br><span class="line">(&lt;cell at 0x0000024EE023D7F8: list object at 0x0000024EDFE76288&gt;,)</span><br><span class="line">&gt;&gt;&gt; avg.__closure__[0].cell_contents </span><br><span class="line">[10, 11, 12] <span class="comment"># cell对象的cell_contents属性才是真正保存自由变量的值的地方</span></span><br></pre></td></tr></table></figure>
<p>综上：<strong>闭包是一种函数，它会保存定义函数时存在的自由变量的绑定，这样调用函数时，虽然外层函数的局部作用域不可用了，但仍能使用那些绑定。</strong></p>
<p>注意：只有嵌套在其他函数中的函数才可能需要处理不在全局作用域中的外部变量。</p>
<h2 id="nonlocal声明">2.3 nonlocal声明</h2>
<p><code>代码10</code>中的<code>make_averager</code>函数并不高效，因为如果只计算均值的话，其实不用保存每次的价格，我们可按如下方式改写<code>代码10</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码13</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        total += new_value</span><br><span class="line">        <span class="keyword">return</span> total / count</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> averager</span><br></pre></td></tr></table></figure>
<p>但此时直接运行<code>代码11</code>的话，则会报<code>代码7</code>中的错误：<code>UnboundLocalError</code>。</p>
<p>问题在于：由于<code>count</code>是不可变类型，在执行<code>count += 1</code>时，该语句等价于<code>count = count + 1</code>，而这就成了赋值语句，<code>count</code>不再是自由变量，而变成了<code>averager</code>的局部变量。<code>total</code>也是一样的情况。而在之前的<code>代码10</code>中没有这个问题，因为<code>series</code>是个可变类型，我们只是调用<code>series.append</code>，以及把它传给了<code>sum</code>和<code>len</code>，它并没有变为局部变量。</p>
<p><strong>对于不可变类型来说，只能读取，不能更新，否则会隐式创建局部变量。</strong>为了解决这个问题，Python3引入了<code>nonlocal</code>声明。它的作用是把变量显式标记为自由变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码14</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> count, total</span><br><span class="line">        -- snip --</span><br></pre></td></tr></table></figure>
<h1 id="装饰器">3. 装饰器</h1>
<p>了解了闭包后，现在开始正式使用嵌套函数来实现装饰器。首先来认识标准库中三个重要的装饰器。</p>
<h2 id="标准库中的装饰器">3.1 标准库中的装饰器</h2>
<h3 id="functools.wraps装饰器">3.1.1 functools.wraps装饰器</h3>
<p>来看一个简单的装饰器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码15</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">        func()</span><br><span class="line">    <span class="keyword">return</span> test</span><br><span class="line"></span><br><span class="line"><span class="meta">@deco</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""This is a test"""</span></span><br><span class="line">    print(<span class="string">"This is a test"</span>)</span><br><span class="line"></span><br><span class="line">print(Test.__name__)</span><br><span class="line">print(Test.__doc__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">test</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>我们想让装饰器来自动帮我们做一些额外的操作，但像改变函数属性这样的操作并不一定是我们想要的：从上面可以看出，<code>Test</code>现在指向了内部函数<code>test</code>，<code>Test</code>自身的属性被遮盖。如果想保留函数原本的属性，可以使用标准库中的<code>functools.wraps</code>装饰器。下面以一个更复杂的装饰器为例，它会在每次调用被装饰函数时计时，并将经过的时间，传入的参数和调用的结果打印出来：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码16</span></span><br><span class="line"><span class="comment"># clockdeco.py</span></span><br><span class="line"><span class="keyword">import</span> time, functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span><span class="params">(func)</span>:</span> <span class="comment"># 两层嵌套</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)  # 绑定属性</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clocked</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        t0 = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        elapsed = time.time() - t0</span><br><span class="line">        name = func.__name__</span><br><span class="line">        arg_lst = [] <span class="comment"># 参数列表</span></span><br><span class="line">        <span class="keyword">if</span> args:</span><br><span class="line">            arg_lst.append(<span class="string">", "</span>.join(repr(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> args))</span><br><span class="line">        <span class="keyword">if</span> kwargs:</span><br><span class="line">            pairs = [<span class="string">"%s=%r"</span> % (k, w) <span class="keyword">for</span> k, w <span class="keyword">in</span> sorted(kwargs.items())]</span><br><span class="line">            arg_lst.append(<span class="string">", "</span>.join(pairs))</span><br><span class="line">        arg_str = <span class="string">", "</span>.join(arg_lst)</span><br><span class="line">        print(<span class="string">"[%0.8fs] %s(%s) -&gt; %r"</span> % (elapsed, name, arg_str, result))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> clocked</span><br></pre></td></tr></table></figure>
<p>它的使用将和下一个装饰器一起展示。</p>
<h3 id="functools.lru_cache装饰器">3.1.2 functools.lru_cache装饰器</h3>
<p><code>functools.lru_cache</code>实现了备忘（memoization）功能，这是一项优化技术，他把耗时的函数的结果保存起来，避免传入相同参数时重复计算。以斐波那契函数为例，我们知道以递归形式实现的斐波那契函数会出现很多重复计算，此时，就可以使用这个装饰器。以下代码是没使用该装饰器时的运行情况：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码17</span></span><br><span class="line"><span class="keyword">from</span> clockdeco <span class="keyword">import</span> clock</span><br><span class="line"></span><br><span class="line"><span class="meta">@clock</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n - <span class="number">2</span>) + fibonacci(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(fibonacci.__name__)</span><br><span class="line">    print(fibonacci.__doc__)</span><br><span class="line">    print(fibonacci(<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">fibonacci  <span class="comment"># fibonacci原本的属性得到了保留</span></span><br><span class="line"><span class="literal">None</span></span><br><span class="line">[0.00000000s] fibonacci(0) -&gt; 0</span><br><span class="line">[0.00000000s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00000000s] fibonacci(2) -&gt; 1</span><br><span class="line">[0.00000000s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00000000s] fibonacci(0) -&gt; 0</span><br><span class="line">[0.00000000s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00000000s] fibonacci(2) -&gt; 1</span><br><span class="line">[0.00000000s] fibonacci(3) -&gt; 2</span><br><span class="line">[0.00000000s] fibonacci(4) -&gt; 3</span><br><span class="line">[0.00000000s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00000000s] fibonacci(0) -&gt; 0</span><br><span class="line">[0.00000000s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00000000s] fibonacci(2) -&gt; 1</span><br><span class="line">[0.00000000s] fibonacci(3) -&gt; 2</span><br><span class="line">[0.00000000s] fibonacci(0) -&gt; 0</span><br><span class="line">[0.00000000s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00000000s] fibonacci(2) -&gt; 1</span><br><span class="line">[0.00000000s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00000000s] fibonacci(0) -&gt; 0</span><br><span class="line">[0.00000000s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00049996s] fibonacci(2) -&gt; 1</span><br><span class="line">[0.00049996s] fibonacci(3) -&gt; 2</span><br><span class="line">[0.00049996s] fibonacci(4) -&gt; 3</span><br><span class="line">[0.00049996s] fibonacci(5) -&gt; 5</span><br><span class="line">[0.00049996s] fibonacci(6) -&gt; 8</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>可以看出，<code>fibonacci(1)</code>调用了8次，下面我们用<code>functools.lru_cache</code>来改进上述代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码18</span></span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">from</span> clockdeco <span class="keyword">import</span> clock</span><br><span class="line"></span><br><span class="line"><span class="meta">@functools.lru_cache()  # 注意此处有个括号！该装饰器就收参数！不能省！</span></span><br><span class="line"><span class="meta">@clock</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n - <span class="number">2</span>) + fibonacci(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(fibonacci(<span class="number">6</span>))</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">[0.00000000s] fibonacci(0) -&gt; 0</span><br><span class="line">[0.00000000s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00000000s] fibonacci(2) -&gt; 1</span><br><span class="line">[0.00000000s] fibonacci(3) -&gt; 2</span><br><span class="line">[0.00000000s] fibonacci(4) -&gt; 3</span><br><span class="line">[0.00000000s] fibonacci(5) -&gt; 5</span><br><span class="line">[0.00000000s] fibonacci(6) -&gt; 8</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<p><code>functools.lru_cache</code>装饰器可以接受参数，并且此代码还叠放了装饰器。</p>
<p><code>lru_cache</code>有两个参数：<code>functools.lru_cache(maxsize=128, typed=False)</code></p>
<ul>
<li><code>maxsize</code>指定存储多少个调用的结果，该参数最好是2的幂。当缓存满后，根据LRU算法替换缓存中的内容，这也是为什么这个函数叫<code>lru_cache</code>。</li>
<li><code>type</code>如果设置为<code>True</code>，它将把不同参数类型下得到的结果分开保存，即把通常认为相等的浮点数和整数参数分开（比如区分1和1.0）。</li>
<li><code>lru_cache</code>使用字典存储结果，字典的键是传入的参数，所以被<code>lru_cache</code>装饰的函数的所有参数都必须是<strong>可散列</strong>的！</li>
</ul>
<h3 id="functools.singledispatch装饰器">3.1.3 functools.singledispatch装饰器</h3>
<p>我们知道，C++支持函数重载，同名函数可以根据参数类型的不同而调用相应的函数。以Python代码为例，我们希望下面这个函数表现出如下行为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码19</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myprint</span><span class="params">(obj)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello~~~"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下是我们希望它拥有的行为：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myprint(<span class="number">1</span>)</span><br><span class="line">Hello~~~</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myprint([])</span><br><span class="line">Hello~~~</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myprint(<span class="string">"hello"</span>) <span class="comment"># 即，当我们传入特定类型的参数时，函数返回特定的结果</span></span><br><span class="line">This <span class="keyword">is</span> a str</span><br></pre></td></tr></table></figure>
<p>单凭这一个<code>myprint</code>还无法实现上述要求，因为Python不支持方法或函数的重载。为了实现类似的功能，一种常见的做法是将函数变为一个分派函数，使用一串<code>if/elif/elif</code>来判断参数类型，再调用专门的函数（如<code>myprint_str</code>），但这种方式不利于代码的扩展和维护，还显得没有B格。。。</p>
<p>为解决这个问题，从Python3.4开始，可以使用<code>functools.singledispath</code>装饰器，把整体方案拆分成多个模块，甚至可以为无法修改的类提供专门的函数。被<code>@singledispatch</code>装饰的函数会变成<strong>泛函数(generic function)</strong>，它会根据第一个参数的不同而调用响应的专门函数，具体用法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码20</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> singledispatch</span><br><span class="line"><span class="keyword">import</span> numbers</span><br><span class="line"></span><br><span class="line"><span class="meta">@singledispatch</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myprint</span><span class="params">(obj)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello~~~"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以叠放多个register，让同一函数支持不同类型</span></span><br><span class="line"><span class="meta">@myprint.register(str)</span></span><br><span class="line"><span class="comment"># 注册的专门函数最好处理抽象基类，而不是具体实现，这样代码支持的兼容类型更广泛</span></span><br><span class="line"><span class="meta">@myprint.register(numbers.Integral) </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(text)</span>:</span> <span class="comment"># 专门函数的名称无所谓，使用 _ 可以避免起名字的麻烦</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Special types"</span></span><br></pre></td></tr></table></figure>
<p><em>对泛函数的补充：根据参数类型的不同，以不同方式执行相同操作的一组函数。如果依据是第一个参数，则是单分派；如果依据是多个参数，则是多分派。</em></p>
<h2 id="参数化装饰器">3.2 参数化装饰器</h2>
<h3 id="简单版参数化装饰器">3.2.1 简单版参数化装饰器</h3>
<p>从上面诸多例子我们可以看到两大类装饰器：不带参数的装饰器（调用时最后没有括号）和带参数的装饰器（带括号）。Python将被装饰的函数作为第一个参数传给了装饰器函数，那装饰器函数如何接受其他参数呢？做法是：<strong>创建一个装饰器工厂函数，在这个工厂函数内部再定义其它函数作为真正的装饰器。工厂函数代为接受参数，这些参数作为自由变量供装饰器使用。然后工厂函数返回装饰器，装饰器再应用到被装饰函数上。</strong></p>
<p>我们把1.2中<code>代码4</code>的<code>@register</code>装饰器改为带参数的版本，以<code>active</code>参数来指示装饰器是否注册某函数（虽然这么做有点多余）。这里只给出<code>@register</code>装饰器的实现，其余代码参考<code>代码4</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码21</span></span><br><span class="line">registry = set()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(active=True)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span> <span class="comment"># 变量active对于decorate函数来说是自由变量</span></span><br><span class="line">        print(<span class="string">"running register(active=%s)-&gt;decorate(%s)"</span> % (active, func))</span><br><span class="line">        <span class="keyword">if</span> active: </span><br><span class="line">            registry.add(func)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            registry.discard(func)</span><br><span class="line">        <span class="keyword">return</span> func</span><br><span class="line">    <span class="keyword">return</span> decorate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用法</span></span><br><span class="line"><span class="meta">@register(active=False) # 即使不传参数也要作为函数调用@register()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上述用法相当于如下代码：</span></span><br><span class="line"><span class="comment"># register(active=False)(f)</span></span><br></pre></td></tr></table></figure>
<h3 id="多层嵌套版参数化装饰器">3.2.2 多层嵌套版参数化装饰器</h3>
<p>参数化装饰器通常会把被装饰函数替换掉，而且结构上需要多一层嵌套。下面以3.1.1中<code>代码16</code>里的<code>@clock</code>装饰器为例，让它按用户要求的格式输出数据。为了简便，不调用<code>functools.wraps</code>装饰器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码22</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">DEFAULT_FMT = <span class="string">"[&#123;elapsed:0.8f&#125;s] &#123;name&#125;(&#123;args&#125;) -&gt; &#123;result&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span><span class="params">(fmt=DEFAULT_FMT)</span>:</span>   <span class="comment"># 装饰器工厂，fmt是装饰器的参数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span>       <span class="comment"># 装饰器</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">clocked</span><span class="params">(*_args)</span>:</span>  <span class="comment"># 最终的函数</span></span><br><span class="line">            t0 = time.time()</span><br><span class="line">            _result = func(*_args)</span><br><span class="line">            elapsed = time.time() - t0</span><br><span class="line">            name = func.__name__</span><br><span class="line">            args = <span class="string">", "</span>.join(repr(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> _args)</span><br><span class="line">            result = repr(_result)</span><br><span class="line">            print(fmt.format(**locals())) <span class="comment">#locals()函数以字典形式返回clocked的局部变量</span></span><br><span class="line">            <span class="keyword">return</span> _result</span><br><span class="line">        <span class="keyword">return</span> clocked</span><br><span class="line">    <span class="keyword">return</span> decorate</span><br></pre></td></tr></table></figure>
<p>可以得到如下结论：装饰器函数有且只有一个参数，即被装饰器的函数；如果装饰器要接受其他参数，请在原本的装饰器外再套一层函数（工厂函数），由它来接受其余参数；而你最终使用的函数应该定义在装饰器函数中，且它的参数列表应该和被装饰的函数一致。</p>
<h1 id="总结">4. 总结</h1>
<p>本篇首先介绍了最简单装饰器如何定义和使用，介绍了装饰器在什么时候被执行，以及用最简单的装饰器改造了上一篇的策略模式；随后更进一步，介绍了与闭包相关的概念，包括变量作用域，闭包和nonlocal声明；最后介绍了更复杂的装饰器，包括标准库中的装饰器的用法，以及如何定义带参数的装饰器。</p>
<p>但上述对装饰器的描述都是基本的， 更复杂、工业级的装饰器还需要更深入的学习。</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>嘴强黑铁
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://www.zuiqiangiron.xyz/2018/05/31/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF26-%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8%E5%92%8C%E9%97%AD%E5%8C%85/" title="Python学习之路26-函数装饰器和闭包">https://www.zuiqiangiron.xyz/2018/05/31/Python学习之路26-函数装饰器和闭包/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Python/" rel="tag"># Python</a>
              <a href="/tags/Python%E8%BF%9B%E9%98%B6/" rel="tag"># Python进阶</a>
              <a href="/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/" rel="tag"># 装饰器</a>
              <a href="/tags/%E9%97%AD%E5%8C%85/" rel="tag"># 闭包</a>
          </div>

        
  <div class="post-widgets">
    <div class="wp_rating">
      <div id="wpac-rating"></div>
    </div>
  </div>


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/05/25/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF25-%E4%BD%BF%E7%94%A8%E4%B8%80%E7%AD%89%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="prev" title="Python学习之路25-使用一等函数实现设计模式">
      <i class="fa fa-chevron-left"></i> Python学习之路25-使用一等函数实现设计模式
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/06/02/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF27-%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E3%80%81%E5%8F%AF%E5%8F%98%E6%80%A7%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" rel="next" title="Python学习之路27-对象引用、可变性和垃圾回收">
      Python学习之路27-对象引用、可变性和垃圾回收 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#初步认识装饰器"><span class="nav-number">1.</span> <span class="nav-text">1. 初步认识装饰器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#装饰器基础用法"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 装饰器基础用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#python何时执行装饰器"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 Python何时执行装饰器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用装饰器改进策略模式"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 使用装饰器改进策略模式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#闭包"><span class="nav-number">2.</span> <span class="nav-text">2. 闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#变量作用域规则"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 变量作用域规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#闭包的概念"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 闭包的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#nonlocal声明"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 nonlocal声明</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#装饰器"><span class="nav-number">3.</span> <span class="nav-text">3. 装饰器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#标准库中的装饰器"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 标准库中的装饰器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#functools.wraps装饰器"><span class="nav-number">3.1.1.</span> <span class="nav-text">3.1.1 functools.wraps装饰器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#functools.lru_cache装饰器"><span class="nav-number">3.1.2.</span> <span class="nav-text">3.1.2 functools.lru_cache装饰器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#functools.singledispatch装饰器"><span class="nav-number">3.1.3.</span> <span class="nav-text">3.1.3 functools.singledispatch装饰器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参数化装饰器"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 参数化装饰器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简单版参数化装饰器"><span class="nav-number">3.2.1.</span> <span class="nav-text">3.2.1 简单版参数化装饰器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多层嵌套版参数化装饰器"><span class="nav-number">3.2.2.</span> <span class="nav-text">3.2.2 多层嵌套版参数化装饰器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">4.</span> <span class="nav-text">4. 总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="嘴强黑铁"
      src="/images/touxiang.jpg">
  <p class="site-author-name" itemprop="name">嘴强黑铁</p>
  <div class="site-description" itemprop="description">一顿操作猛如虎</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">83</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">94</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">嘴强黑铁</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.2
  </div>

        
<div class="busuanzi-count">
  <script pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.getAttribute('pjax') !== null) {
      script.setAttribute('pjax', '');
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  



  <script pjax>
  if (CONFIG.page.isPost) {
    wpac_init = window.wpac_init || [];
    wpac_init.push({
      widget: 'Rating',
      id    : 24025,
      el    : 'wpac-rating',
      color : 'fc6423'
    });
    (function() {
      if ('WIDGETPACK_LOADED' in window) return;
      WIDGETPACK_LOADED = true;
      var mc = document.createElement('script');
      mc.type = 'text/javascript';
      mc.async = true;
      mc.src = '//embed.widgetpack.com/widget.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
    })();
  }
  </script>

  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://zuiqiangiron.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "https://www.zuiqiangiron.xyz/2018/05/31/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF26-%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8%E5%92%8C%E9%97%AD%E5%8C%85/";
    this.page.identifier = "2018/05/31/Python学习之路26-函数装饰器和闭包/";
    this.page.title = "Python学习之路26-函数装饰器和闭包";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://zuiqiangiron.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

    </div>
</body>
</html>
