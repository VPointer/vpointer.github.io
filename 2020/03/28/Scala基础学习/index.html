<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="Y0-gFMBzGnbrueUrh8PjkmnvCGItjob2oR3HjG9SVnE">
  <meta name="msvalidate.01" content="97A49017D4D536B99438C4EE0E9FBA3F">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.zuiqiangiron.xyz","root":"/","scheme":"Gemini","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Scala语法学习。。。谁让Spark，Kafka都是用它来写的呢。。。">
<meta property="og:type" content="article">
<meta property="og:title" content="Scala学习">
<meta property="og:url" content="https://www.zuiqiangiron.xyz/2020/03/28/Scala%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="嘴强黑铁">
<meta property="og:description" content="Scala语法学习。。。谁让Spark，Kafka都是用它来写的呢。。。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-03-28T15:00:00.000Z">
<meta property="article:modified_time" content="2020-04-14T07:59:02.365Z">
<meta property="article:author" content="嘴强黑铁">
<meta property="article:tag" content="Scala">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://www.zuiqiangiron.xyz/2020/03/28/Scala%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Scala学习 | 嘴强黑铁</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-161480657-1"></script>
    <script pjax>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-161480657-1');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">嘴强黑铁</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">天下事以难而废者十之一，以惰而废者十之九</h1>
      
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="search-pop-overlay">
  <div class="popup search-popup">
      <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

  </div>
</div>

  </div>
</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.zuiqiangiron.xyz/2020/03/28/Scala%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.jpg">
      <meta itemprop="name" content="嘴强黑铁">
      <meta itemprop="description" content="一顿操作猛如虎">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="嘴强黑铁">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          Scala学习
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-28 23:00:00" itemprop="dateCreated datePublished" datetime="2020-03-28T23:00:00+08:00">2020-03-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 15:59:02" itemprop="dateModified" datetime="2020-04-14T15:59:02+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Scala/" itemprop="url" rel="index"><span itemprop="name">Scala</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/03/28/Scala%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/03/28/Scala基础学习/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>Scala语法学习。。。谁让Spark，Kafka都是用它来写的呢。。。</p>
</blockquote>
<a id="more"></a>
<h1 id="scala数据类型">Scala数据类型</h1>
<ul>
<li><p><code>Any</code>是所有类型的父类</p>
<ul>
<li><code>Null</code>是所有<code>AnyRef</code>的子类，它只有<code>null</code>这一个值，只能给<code>AnyRef</code>，不能给<code>AnyVal</code>；</li>
<li><code>Nothing</code>类型是所有类型的子类，它可以作为返回值返回给所有变量或函数，常用于抛出异常。它表示该方法没有正常的返回值</li>
<li><code>Unit</code>表示空类型，相当于java中的<code>void</code>，只能用作表示方法不返回任何类型，它的值为<code>()</code></li>
</ul></li>
<li><p>数据类型字节数：</p>
<ul>
<li><p><code>Byte</code>：1</p></li>
<li><p><code>Boolean</code>：1</p></li>
<li><p><code>Short</code>：2</p></li>
<li><p><code>Char</code>：2，无符号，对应的是Unicode，而不是ASCII</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当把一个字面量赋值给变量时，只判断范围是否超过</span></span><br><span class="line"><span class="keyword">var</span> a: <span class="type">Char</span> = <span class="number">98</span> <span class="comment">// 不报错</span></span><br><span class="line"><span class="comment">// 当把一个计算结果赋值给变量时，不光要判断范围，还要判断类型</span></span><br><span class="line"><span class="keyword">var</span> b: <span class="type">Char</span> = <span class="number">97</span> + <span class="number">1</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>Int</code>：4，字面整数值的默认数据类型</p></li>
<li><p><code>Float</code>：4，大致保留小数点后7位</p></li>
<li><p><code>Long</code>：8</p></li>
<li><p><code>Double</code>：8，字面小数值的默认类型</p></li>
<li><p><code>Byte</code>和<code>Short</code>不能转换成<code>Char</code></p></li>
<li><p><code>Byte</code>，<code>Short</code>和<code>Char</code>三者运算时会转换成<code>Int</code></p></li>
</ul></li>
</ul>
<h1 id="scala零散要点">Scala零散要点</h1>
<ul>
<li><p>Scala中所有数据类型都是对象！没有Java中的原生类型。</p></li>
<li><p>Scala中数据类型也分为：值类型（<code>AnyVal</code>），引用类型（<code>AnyRef</code>），但都是对象！</p></li>
<li><p>在Scala中，如果一个方法没有型参，则可以省略括号。</p></li>
<li><p>标识符</p>
<ul>
<li>标识符首字符可以是运算符，但后面也必须跟至少一个标识符（第二位，而不是最末尾）</li>
<li>用反引号包起来的字符串也可以做标识符，反引号中可以是关键字</li>
<li><strong><code>Int</code>在Scala中并不是关键字！它是预定义标识符，可以用作变量名，但最好不要！其它也一样</strong></li>
</ul></li>
<li><p><code>trait</code>等价于java中的<code>interface + abstract class</code></p></li>
<li><p>Scala中任何表达式都有返回值，返回值为满足条件的代码块中的最后一行</p></li>
<li><p>Scala中，任何语法结构都可以嵌套其它语法结构</p></li>
<li><p>当继承了<code>App</code>这个类后，就可以在这个类中执行代码，而不需要再写<code>main</code>主函数作为入口</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyTest</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 直接在这里写执行代码即可，不用再写main函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Scala中创建对象的几种方式（形式上是这几种，但归根结底还是JVM创建）：</p>
<ul>
<li><code>new</code> 对象</li>
<li><code>apply</code> 创建</li>
<li>匿名子类的方式</li>
<li>动态混入</li>
</ul></li>
<li><p>高阶函数：可以接受以函数为参数的函数，或者返回函数的函数（这种情况叫做闭包）。</p></li>
<li><p>Scala中函数可以作为参数传递给另一个函数，那么也就是说，函数其实也是有类型的：如果函数只有一个参数，那么该函数的类型就是<code>function1</code>，有两个参数则是<code>function2</code>。</p></li>
</ul>
<h1 id="scala中的循环">Scala中的循环</h1>
<h2 id="scala中的for循环">Scala中的<code>for</code>循环：</h2>
<ul>
<li><p><code>to</code>是闭区间<code>[starrt, end]</code></p></li>
<li><p><code>until</code>是左闭右开区间<code>[start, end)</code></p></li>
<li><p>循环守卫<code>if</code>：相当于<code>continue</code></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">3</span> <span class="keyword">if</span> i != <span class="number">2</span>)&#123; <span class="comment">// 跳过！</span></span><br><span class="line">	.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>引人变量：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">3</span>; j = <span class="number">4</span> - i)&#123;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>嵌套循环：可以写在一行</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">3</span>; j &lt;- <span class="number">1</span> to <span class="number">3</span>) &#123;</span><br><span class="line">	<span class="comment">// 其实是两层循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这么写只能用于一些简单的情况</p></li>
<li><p>循环返回值<code>yield</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rst = <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">10</span>) <span class="keyword">yield</span> &#123;i * i&#125;</span><br></pre></td></tr></table></figure>
<p>将10个返回结果存放到集合<code>Vector</code>中，并将该<code>Vector</code>返回给<code>rst</code></p>
<p><strong>这也体现了该语言在大数据处理中的应用。</strong></p></li>
<li><p>小括号变大括号：使用大括号可以实现分行</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">	i &lt;- <span class="number">1</span> to <span class="number">3</span></span><br><span class="line">	j &lt;- <span class="number">1</span> to <span class="number">3</span>&#125; &#123;</span><br><span class="line">	<span class="comment">// 其实是两层循环</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于下方代码</span></span><br><span class="line"><span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">3</span>; j &lt;- <span class="number">1</span> to <span class="number">3</span>) &#123;</span><br><span class="line">	<span class="comment">// 其实是两层循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>控制步长<code>Range</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i &lt;- <span class="type">Range</span>(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>)) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价写法</span></span><br><span class="line"><span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">10</span> <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">1</span>) &#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="while循环和do...while循环"><code>while</code>循环和<code>do...while</code>循环：</h2>
<p>它们的返回值是<code>Unit</code>，即本身没有返回值，Scala不推荐使用<code>while</code></p>
<h2 id="如何中断循环">如何中断循环</h2>
<p>Scala中没有<code>continue</code>和<code>break</code>这两个关键字！它是通过<strong>函数式的风格</strong>来实现这两个关键字的效果。</p>
<h3 id="如何实现break效果">如何实现break效果</h3>
<p>Scala将<code>break</code>关键字替换成了<code>util.control.Breaks</code>中的<code>break()</code>函数以及<code>breakable()</code>函数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">breakable( <span class="comment">// 它是一个高阶函数</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123; </span><br><span class="line">        <span class="keyword">break</span>() <span class="comment">// 它通过抛出breakException异常来实现中断，所以，需要捕获异常来处理</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 补充：高阶函数是指能够接受函数作为参数的函数。</span></span><br></pre></td></tr></table></figure>
<p>但是，由于传入的是代码块，<code>breakable()</code>使用小括号让代码看起来比较怪，所以又会将小括号改为大括号：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">breakable&#123; </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123; </span><br><span class="line">        <span class="keyword">break</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="如何实现continue效果">如何实现<code>continue</code>效果</h3>
<p>使用循环守卫或者<code>if...else...</code>结构</p>
<h1 id="scala中下划线_的含义">Scala中下划线<code>_</code>的含义：</h1>
<ul>
<li>引包的时候，表示将某个包中的内容全部引入</li>
<li>将方法转换成函数</li>
<li>给当前数据类型的默认值</li>
</ul>
<h1 id="scala函数式编程">Scala函数式编程</h1>
<ol type="1">
<li><p>scala中，方法和函数是两个概念，但是，这<strong>两者几乎等同</strong>。</p>
<p>方法/函数的定义：关键字<code>def</code></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMath</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(x:<span class="type">Int</span>, y:<span class="type">Int</span>):<span class="type">Int</span> = &#123; <span class="comment">// 这里是等号</span></span><br><span class="line">		x + y</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi</span></span>(x:<span class="type">Int</span>, y:<span class="type">Int</span>):<span class="type">Int</span> = &#123;</span><br><span class="line">    x * y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>匿名函数的定义如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> f = (x:<span class="type">Int</span>, y:<span class="type">Int</span>) =&gt; &#123; <span class="comment">// 注意符号</span></span><br><span class="line">	x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法转换到函数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> fromDef = <span class="type">MyMath</span>.sum _ <span class="comment">// 不带括号，然后空格接一个下划线</span></span><br></pre></td></tr></table></figure></li>
<li><p>方法或函数定义中，等号的含义：</p>
<ul>
<li>明确声明了返回值，此时必须有等号</li>
<li>可以不声明返回值，此时也必须有等号，表示返回值类型需要推导</li>
<li>没有等号，表示代码块没有返回值，或者返回值为<code>Unit</code></li>
</ul></li>
<li><p>如果函数没有型参，则调用时可以不带括号</p></li>
<li><p>Scala中，如果函数中使用了<code>return</code>，编译器将不能自行推断函数返回类型；如果函数没有返回值（也就是没有加等号），那么即使有了<code>return</code>，也没有返回值</p></li>
<li><p>形参默认是<code>val</code></p></li>
<li><p>形参可以有默认值</p></li>
<li><p>支持命名参数，类似Python的参数，默认从左到右依次覆盖</p></li>
<li><p>递归不能使用自动类型推导返回值，必须明确指定</p></li>
<li><p>支持可变参数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(args:<span class="type">Int</span>*):<span class="type">Int</span>=&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>可变参数必须写在最后。</p></li>
<li><p>函数懒加载<code>lazy</code></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> rst = sum(<span class="number">10</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<p>当<code>rst</code>后续被用到的时候，再去计算。</p>
<p><code>lazy</code>不能修饰<code>var</code> 。</p>
<p><code>lazy</code>也可以用于变量的声明：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> t = <span class="number">10</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="scala异常">Scala异常</h1>
<ul>
<li><p>语法：</p>
<p>抛出异常依然是使用<code>throw</code>，任何异常都是<code>Throwable</code>的子类，<code>throw</code>表达式的返回值就是<code>Nothing</code>类型！</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">catch</span>&#123; <span class="comment">// 只能有1个catch！</span></span><br><span class="line">    <span class="keyword">case</span> ex:<span class="type">ArithmeticException</span> =&gt; &#123;...&#125;</span><br><span class="line">    <span class="keyword">case</span> ex:<span class="type">Exceptioin</span> =&gt; &#123;...&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>Scala中，大范围的异常可以写到小范围的异常之前，而Java中不行。但Scala并不推荐这种做法。</p></li>
<li><p>Scala只有运行时异常。</p></li>
<li><p>Scala中使用模式匹配来匹配异常。</p></li>
<li><p>可以使用<code>@throws</code>注解申明可能抛出的异常。</p></li>
</ul>
<h1 id="scala面向对象">Scala面向对象</h1>
<ul>
<li><p><code>class</code>关键字定义的类，经过编译后只有一个<code>.class</code>文件（这一点不共于<code>object</code>关键字），且生成的类是<code>public</code>的。</p></li>
<li><p>Scala只支持单继承。</p></li>
<li><p>类中的属性经过编译后，默认是<code>private</code>的，但会生成一个同名的<code>public</code>方法以及名为<code>属性名_$eq</code>的<code>public</code>方法，前者相当于java中的<code>get()</code>方法，后者相当于<code>set()</code>方法。</p>
<p>例如属性<code>name:String</code>经过变异后会变成<code>private String name</code>，同时生成一个<code>public String name()</code>方法和一个<code>public void name_$eq()</code>方法。</p></li>
<li><p>属性必须要<strong>显示初始化</strong>！否则报错。</p></li>
<li><p>下划线<code>_</code>表示给该类型数据的默认值。</p></li>
<li><p>类的属性默认是<code>private</code>，但是会自动在底层自动生成<code>public</code>的<code>get()/set()</code>方法。</p></li>
<li><p><code>class</code>关键字前不要写<code>public</code></p></li>
<li><p>一个Scala源文件可以包含多个类，而且全是<code>public</code></p></li>
<li><p>如果要将一个属性的初始值设置为<code>null</code>，请指定数据类型！否则该属性的类型就为<code>Null</code></p></li>
<li><p>Scala中类和对象的内存布局和Java一样！</p></li>
<li><p>Bean属性：在属性前加上<code>@BeanProperty</code>将会给该属性自动生成标准的<code>getXXX()/setXXX()</code>方法，和底层自动生成的<code>get()/set()</code>方法共存，没有冲突：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params">inName:<span class="type">String</span></span>) </span>&#123;</span><br><span class="line">	<span class="meta">@BeanProperty</span> <span class="keyword">var</span> name: <span class="type">String</span> = inName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Scala中重写一个非抽象方法需要显示使用<code>override</code>关键字</p></li>
</ul>
<h2 id="封装继承和多态的回顾">封装、继承和多态的回顾</h2>
<h3 id="封装encapsulation">封装Encapsulation</h3>
<p>把抽象出来的数据和对数据的操作组合在一起，数据被保护在内部，程序的其他部分只能通过被授权的操作（成员方法）来控制数据。</p>
<h4 id="封装的好处">封装的好处</h4>
<ul>
<li>隐藏实现细节</li>
<li>可以对数据进行验证，保证安全合理</li>
<li>可以加入业务逻辑</li>
</ul>
<h4 id="封装的步骤">封装的步骤</h4>
<ol type="1">
<li>将属性私有化</li>
<li>提供<code>getXXX()/setXXX()</code>方法</li>
</ol>
<h3 id="继承">继承</h3>
<p>解决代码复用</p>
<h4 id="继承的好处">继承的好处</h4>
<ul>
<li>提高了代码的复用性</li>
<li>代码的扩展性和维护性提高了：当我们修改父类时，它对应的子类就会得到相应的修改</li>
</ul>
<h2 id="scala中的抽象类">Scala中的抽象类</h2>
<p>使用<code>abstract</code>关键字标记的类就是抽象类：</p>
<ul>
<li>方法不用标记<code>abstract</code>，不要写方法体即可（也不要写大括号）；</li>
<li>Scala中抽象类不一定要有抽象方法；</li>
<li>抽象类可以拥有抽象字段，抽象字段就是没有初始值的字段：
<ul>
<li>对于抽象属性，在底层并不会生成对应的属性，而是生成两个抽象方法（抽象的<code>get/set</code>方法）；</li>
<li>子类重写父类的抽象属性，可以不用<code>override</code>关键字。底层本质上就是实现那两个抽象方法。</li>
</ul></li>
<li>子类必须实现父类中的所有抽象方法和抽象属性，除非它自己也声明为<code>abstract</code></li>
</ul>
<h2 id="scala类构造器">Scala类构造器</h2>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">类名</span>(<span class="params">形参列表</span>) <span class="keyword">extends</span> <span class="title">父类</span>(<span class="params">形参列表</span>) </span>&#123; <span class="comment">// 主构造器，没有看错，就是放在类名后面</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(形参列表)&#123;&#125; <span class="comment">// 辅助构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(形参列表)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>构造器的作用不是创建对象，而是初始化！</strong></p></li>
<li><p>Scala构造球也支持重载，它分为<strong>主构造器</strong>和<strong>辅助构造器</strong></p>
<ul>
<li><p>主构造器：</p>
<ul>
<li><p><strong>与类名相同，它会执行类定义体中除方法体之外的所有语句</strong></p></li>
<li><p>如果要让主构造器变成<code>private</code>，需要在小括号之前加上<code>private</code></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">类名</span> <span class="title">private</span>(<span class="params">形参列表</span>)</span>&#123; &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如果主构造器中的形参没有任何修饰符修饰，那么它就是<strong>局部变量</strong>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> (<span class="params">inName: <span class="type">String</span></span>)</span>&#123;&#125; <span class="comment">// inName是局部变量</span></span><br></pre></td></tr></table></figure></li>
<li><p>如果主构造器中的形参被<code>val</code>修饰，该形参将会成为一个<strong>只读属性</strong>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> (<span class="params">val inName: <span class="type">String</span></span>) </span>&#123;&#125; <span class="comment">// inName将会成为A的一个只读属性</span></span><br></pre></td></tr></table></figure></li>
<li><p>如果主构造器中的形参被<code>var</code>修饰，该形参将会成为一个<strong>一般属性</strong>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> (<span class="params">var inName: <span class="type">String</span></span>) </span>&#123; <span class="comment">// A将会多一个inName属性，它的地位等同于其中的name</span></span><br><span class="line">	<span class="keyword">var</span> name = inName</span><br><span class="line">&#125; <span class="comment">// inName将会成为A的一个一般属性</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>辅助构造器：</p>
<ul>
<li>全部命名为<code>this</code>，底层就是Java构造函数的重载</li>
<li><strong>辅助构造器要求第一行必须显式调用主构造器（为了实现对父类的初始化）。可以间接调用主构造器（调用其他辅助构造器），但必须显式调用</strong></li>
</ul></li>
</ul></li>
<li><p>对象创建的流程：</p>
<ol type="1">
<li><p>加载类信息（加载属性信息和方法信息）</p></li>
<li><p>在内存（堆）中开辟空间</p></li>
<li><p>对父类（主副构造器）进行初始化</p>
<p><strong>在Java中可以在子类的构造函数中隐式或者显式地调用<code>super</code>构造父类，但在Scala中只有主构造器才可以调用父类的构造器，而且是默认调用，不能使用<code>super</code>关键字。</strong></p></li>
<li><p>使用主构造器对属性进行初始化</p></li>
<li><p>调用辅助构造器对属性进行初始化（如果调用的是辅助构造器的话）</p></li>
</ol></li>
<li><p>覆写字段：</p>
<p>Java中没有属性/字段的覆写，准确的说是隐藏字段代替了重写（子类编译后重命名了与父类的同名字段），但是Scala中可以（因为底层调用的是同名的<code>get()</code>方法，动态绑定机制）。</p>
<ul>
<li><code>def</code>只能重写<code>def</code>，即方法只能重写另一个方法</li>
<li><code>val</code>只能重写<code>val</code>，或者不带参数的同名<code>def</code></li>
<li><code>var</code>只能重写另一个抽象的<code>var</code></li>
</ul></li>
<li><p>匿名子类：语法跟Java一样</p></li>
</ul>
<h2 id="伴生类与伴生对象">伴生类与伴生对象</h2>
<p>如果一个文件中出现了上述这样同名的<code>class</code>和<code>object</code>，那么，对应的<code>class</code>叫做伴生类，对应的<code>object</code>叫做伴生对象。</p>
<p>以代码为例：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.learn.myscala</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Learning</span> </span>&#123;&#125;	<span class="comment">// 伴生类</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Learning</span> </span>&#123;&#125;	<span class="comment">// 伴生对象</span></span><br></pre></td></tr></table></figure>
<p>由于Scala设计者舍弃了<code>static</code>关键字，而由于Scala运行在JVM中，于是他创建了更复杂的伴生类伴生对象来实现<code>static</code>的效果（一种否定全部的思想[假笑]）：</p>
<ul>
<li>将非静态的内容放在<strong>伴生类</strong>中；</li>
<li>将”静态“的内容放在<strong>伴生对象</strong>中，这里的”静态“只是一种模拟（伴生类中定义的属性和方法其实都是<code>public</code>的，只是伴生类在底层会为自己创建一个单例<code>public static final MODULES$</code>，这个单例是<code>static</code>的，对伴生类所有属性和方法的调用都将通过<code>MODULES$</code>进行，所以，“静态”只是一种模拟）；</li>
</ul>
<h3 id="apply方法">apply方法</h3>
<p>对于以下代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = <span class="type">TestApply</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p>这种“不伦不类”的没有用<code>new</code>关键字的调动，其实就是通过在<strong>伴生对象</strong>中添加<code>apply</code>方法实现的：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestApply</span>(<span class="params">inName: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> name:<span class="type">String</span> = inName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestApply</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(inName: <span class="type">String</span>): <span class="type">TestApply</span> = <span class="keyword">new</span> <span class="type">TestApply</span>(inName)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(): <span class="type">TestApply</span> = <span class="keyword">new</span> <span class="type">TestApply</span>(<span class="string">"匿名"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="scala包">Scala包</h2>
<h3 id="回顾java包">回顾：Java包</h3>
<ul>
<li><p>Java包的3大作用：</p>
<ul>
<li>区分相同名字的类</li>
<li>当类很多时，方便管理类</li>
<li>控制访问范围</li>
</ul></li>
<li><p>Java打包的命令：</p>
<ul>
<li><code>package com.kevin</code></li>
<li>打包的本质：实际上就是创建不同的文件夹来存放类文件</li>
</ul></li>
<li><p>Java中访问修饰符的作用域：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">访问级别</th>
<th style="text-align: center;">访问修饰符</th>
<th style="text-align: center;">同类</th>
<th style="text-align: center;">同包</th>
<th style="text-align: center;">子类</th>
<th style="text-align: center;">不同包</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">公开</td>
<td style="text-align: center;"><code>public</code></td>
<td style="text-align: center;">✔️</td>
<td style="text-align: center;">✔️</td>
<td style="text-align: center;">✔️</td>
<td style="text-align: center;">✔️</td>
</tr>
<tr class="even">
<td style="text-align: center;">受保护</td>
<td style="text-align: center;"><code>protected</code></td>
<td style="text-align: center;">✔️</td>
<td style="text-align: center;">✔️</td>
<td style="text-align: center;">✔️</td>
<td style="text-align: center;">❌</td>
</tr>
<tr class="odd">
<td style="text-align: center;">默认</td>
<td style="text-align: center;">没有修饰符</td>
<td style="text-align: center;">✔️</td>
<td style="text-align: center;">✔️</td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">❌</td>
</tr>
<tr class="even">
<td style="text-align: center;">私有</td>
<td style="text-align: center;"><code>private</code></td>
<td style="text-align: center;">✔️</td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">❌</td>
<td style="text-align: center;">❌</td>
</tr>
</tbody>
</table></li>
</ul>
<h3 id="scala中包的可见性和访问修饰符的使用">Scala中包的可见性和访问修饰符的使用</h3>
<ul>
<li><p>Scala中没有<code>public</code>关键字！</p></li>
<li><p>Scala包中的作用域问题：</p>
<ul>
<li><p><strong><em>可以直接向上访问父包中的内容。</em></strong></p></li>
<li><p><strong><em>如果类重名时，则采用就近原则。如果要使用特定的类，则需要明确指定包名（使用路径）。</em></strong></p></li>
<li><p><strong><em>父类要使用子包的内容，则必须要<code>import</code>（<code>import</code>不必在文件开头写，可以在用到的地方写，与Python类似）</em></strong></p></li>
<li><p>引入的包的作用域只在当前代码块！</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">import</span> scala.beans.<span class="type">BeanProperty</span></span><br><span class="line">    <span class="meta">@BeanProperty</span> <span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="meta">@BeanProperty</span> <span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">""</span> <span class="comment">// 报错！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>属性的默认权限相当于<code>public</code>，但并不是<code>public</code>，从底层源码来讲，属性是<code>private</code>的，但编译器自动为其创建了<code>getXXX()/setXXX()</code>方法，使其看起来像是<code>public</code>；</p></li>
<li><p>方法的默认权限也相当于是<code>public</code>的，底层使用<code>public</code>来修饰的；</p></li>
<li><p><code>private</code>只能在<strong>类的内部</strong>和<strong>伴生对象</strong>中使用！会将属性的<code>get/set</code>方法设置为<code>private</code>；</p></li>
<li><p><code>protected</code>为受保护权限，Scala中受保护权限比Java中<strong>更严格</strong>，只能子类访问，同包不能访问（但是编译后，在底层依然是<code>public</code>，只是语法不让你访问）；</p></li>
<li><p>权限总结:</p>
<ul>
<li>默认权限：相当于主管对外，其他代码可以访问</li>
<li><code>ptotected</code>：相当于主管继承树之内，整个继承树之内可以访问</li>
<li><code>private</code>：相当于主管本类，只在本类之中可以访问（包括伴生类）</li>
</ul></li>
<li><p>包访问权限（表示属性有了限制，同时包也有了限制），比Java更灵活：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.learn.myscala</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> person = <span class="keyword">new</span> <span class="type">Person</span>()</span><br><span class="line">        person.name <span class="comment">// 在这个包中，可以访问private属性，</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; <span class="comment">// 中括号中的内容为myscala这个包名，也就是当前的包</span></span><br><span class="line">    <span class="keyword">private</span>[myscala] <span class="keyword">var</span> name:<span class="type">String</span> = <span class="string">"test"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果去掉中括号中的内容，<code>main</code>中是无法访问<code>person</code>的<code>name</code>属性的，而<code>private[myscala]</code>择表示<code>myscala</code>这个包（及其子包）中的其他方法，类可以访问该属性。</p></li>
</ul>
<h3 id="scala包的作用">Scala包的作用</h3>
<ul>
<li>区分相同名字的类</li>
<li>当类很多时，方便管理类</li>
<li>控制访问范围</li>
<li>可以对类的功能进行扩展</li>
</ul>
<h3 id="scala包的使用">Scala包的使用</h3>
<ul>
<li><p>包的命名规范：<code>com.公司名.项目名.模块名</code></p></li>
<li><p>Scala中类的源文件和包的路径可以不一致，但是，编译后的字节码文件的路径会和包一致（由编译器实现）</p></li>
<li><p>Scala会自动引入常用的包（但并不表示可以使用子包中的内容，跟Java一样）：</p>
<ul>
<li><code>java.lang.*</code></li>
<li><code>scala包</code></li>
<li><code>Predef包</code></li>
</ul></li>
<li><p>Scala包的引入：</p>
<ul>
<li><p>可以用到时再引入；</p></li>
<li><p>用下划线<code>_</code>表示引入某个包中的所有内容，等价于Java中的<code>*</code></p></li>
<li><p>如果只想引入某个包中的部分内容，可以使用选择器<code>{}</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection.mutable.&#123;<span class="type">HashMap</span>, <span class="type">HashSet</span>&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>可以为引入的类重命名：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.&#123;<span class="type">HashMap</span>=&gt;<span class="type">JavaHashMap</span>, <span class="type">List</span>&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如果某个冲突的类根本用不到，可以使用下划线隐藏该类<code>_</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.&#123;<span class="type">HashMap</span>=&gt;_, _&#125;</span><br></pre></td></tr></table></figure>
<p>第一个下划线表示隐藏<code>java.util.HashMap</code>这个类，第二个下划线表示引入该包中剩余的所有类。</p></li>
</ul></li>
<li><p>Scala中打包的3种方式：</p>
<ul>
<li><p>传统方式</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.learn.myscala</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>分行方式：和传统方式完全等价</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.learn</span><br><span class="line"><span class="keyword">package</span> myscala</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>块方式</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.learn &#123; <span class="comment">// 表示创建了包com.learn</span></span><br><span class="line">	<span class="keyword">package</span> myscala &#123;</span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第一个大括号中，我们可以：</p>
<ul>
<li>继续写它的子包</li>
<li>写类</li>
<li>写特质</li>
<li>写<code>object</code></li>
</ul>
<p>也就是说，<strong>scala中，同一个文件中，可以创建多个包！</strong></p></li>
</ul></li>
<li><p>当包名冲突时，需要使用绝对路径引入：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种方式：相对路径</span></span><br><span class="line"><span class="keyword">import</span> scala.beans.<span class="type">BeanProperty</span></span><br><span class="line"><span class="meta">@BeanProperty</span></span><br><span class="line"><span class="comment">// 第二种方式：相对路径</span></span><br><span class="line"><span class="meta">@scala</span>.beans.<span class="type">BeanProperty</span></span><br><span class="line"><span class="comment">// 第三种方式：绝对路径</span></span><br><span class="line">@_root_.scala.beans.<span class="type">BeanProperty</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="包对象">包对象</h3>
<p>包中可以写子包、类、特质、<code>object</code>，但是由于java虚拟机的限制，不能创建常量和函数。为了解决这个问题，scala引入了包对象的概念。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.learn &#123; <span class="comment">// 表示创建了包com.learn</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">package</span> <span class="class"><span class="keyword">object</span> <span class="title">myscala</span> </span>&#123; <span class="comment">// 注意这里有一个object关键字</span></span><br><span class="line">		<span class="keyword">val</span> name1: <span class="type">String</span> = <span class="string">"name1"</span></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">test</span></span>():<span class="type">Unit</span> = &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">package</span> myscala &#123;</span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述的<code>package object myscala</code>是<code>com.learn.myscala</code>包对应的包对象。</p>
<p>每一个包都可以且只可以对应一个包对象，包对象的名字必须和对应的包名相同，且包对象必须定义在父包中，而不是定义在对应的包中。</p>
<p>包对象中的内容只能被对应的包使用。</p>
<p><strong><em>底层详解</em></strong>：底层会为包对象生成两个文件<code>package.class</code>和<code>package$.class</code>，类似于<code>object</code>对象</p>
<h2 id="scala中类型检查和转换">Scala中类型检查和转换</h2>
<ul>
<li><code>classOf[T]</code>：获取类的完整类名
<ul>
<li>也可以通过<code>对象.getClass.getName</code>获取类名<br />
</li>
</ul></li>
<li><code>isInstanceOf[T]</code>：相当于java中的<code>isinstanceof</code></li>
<li><code>asInstanceOf[T]</code>：强制类型转换（不会影响调用类，而是返回一个引用）</li>
</ul>
<h2 id="特质trait">特质trait</h2>
<ol type="1">
<li><p>从面向对象来看，接口并不属于面向对象的范畴，Scala是纯面相对象的语言，在Scala中，并没有接口，而是使用特质<code>trait</code>来代替接口的概念，也就是说，多个类如果具有相同的特质（特征）时，就可以将这个特质提取出来，采用关键字<code>trait</code>声明。</p></li>
<li><p>可以简单理解成Scala的<code>trait</code>相当于Java中的<code>interface + abstract</code>。</p></li>
<li><p>特质的语法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">类名</span> <span class="keyword">extends</span> <span class="title">特质1</span> <span class="keyword">with</span> <span class="title">特质2</span></span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">有父类</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="keyword">extends</span> <span class="title">父类</span> <span class="keyword">with</span> <span class="title">特质1</span> <span class="keyword">with</span> <span class="title">特质2</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>Scala有两种方式来使用<code>trait</code>：</p>
<ul>
<li>传统方式，直接继承（因为Scala是纯面相对象，所以没有了“实现”这个概念）；</li>
<li>动态混入MixIn</li>
</ul></li>
<li><p>在Scala中，<strong>Java中的所有接口都可以当成特质来使用</strong>。</p></li>
<li><p><strong>特质可以同时拥有抽象方法和具体方法</strong>。</p>
<ul>
<li>当特质(以<code>trait007</code>为例)只有抽象方法时，它的底层只对应一个文件<code>trait007.class</code>，它是一个接口文件；</li>
<li>当特质中既有抽象方法，还有具体方法的时候，这种特征叫做<strong>富接口</strong>，它在底层将对应两个文件：
<ul>
<li>特质中的所有方法都会放到接口文件<code>trait007.class</code>中（不管这个方法是不是抽象方法）；</li>
<li>特质中的具体方法还会集中放到一个抽象类文件<code>trait007$class.class</code>文件中。</li>
</ul></li>
</ul></li>
<li><p>特质中也可以有字段：</p>
<ul>
<li>如果初始化了字段，则该字段是具体字段，否则就是抽象字段；</li>
<li>对于具体字段而言，混入了该特质的类则具有了该字段，但从底层来看，它并不是通过继承方法，而是通过直接加入的方式来加入该字段</li>
</ul></li>
<li><p>当一个类继承了某<code>trait</code>，那么该类的实例可以传递给这个<code>trait</code>引用，和Java中的接口一样。</p></li>
</ol>
<h3 id="动态混入">动态混入</h3>
<p>除了可以在类声明时继承特质以外，还可以在<strong>构建对象时</strong>混入特质，扩展目标类的功能。</p>
<p>动态混入是Scala特有的，Java没有该功能。它可以在不修改类声明/定义的情况下，扩展类的功能，耦合性低，符合闭合原则（OCP原则）。</p>
<p>动态混入可以在不影响原有的继承关系上，在创建对象时扩展该类的功能（也就是说可以不影响子类，只单独给一个类的对象扩展功能）。</p>
<p>以下是动态混入的示例：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyTest</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123; <span class="comment">// 构建对象时！</span></span><br><span class="line">    <span class="comment">// 一般类的动态混入</span></span><br><span class="line">    <span class="keyword">val</span> oracleDB = <span class="keyword">new</span> <span class="type">OracleDB</span> <span class="keyword">with</span> <span class="type">InsertOpt</span> </span><br><span class="line">    <span class="comment">// 空抽象类的动态混入（相当于在混入之前先创建一个匿名子类）</span></span><br><span class="line">    <span class="comment">// 相当于 val mySqlDB = new MySQL with InsertOpt &#123;&#125;</span></span><br><span class="line">    <span class="keyword">val</span> mySqlDB = <span class="keyword">new</span> <span class="type">MySQL</span> <span class="keyword">with</span> <span class="type">InsertOpt</span> </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> mongoDB = <span class="keyword">new</span> <span class="type">MongoDB</span> <span class="keyword">with</span> <span class="type">InsertOpt</span> &#123; <span class="comment">// 非空抽象类的动态混入</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">say</span></span>()&#123;</span><br><span class="line">            println(<span class="string">"This is mongodb insert!"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">InsertOpt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span></span>(id: <span class="type">Int</span>) &#123;</span><br><span class="line">        println(<span class="string">"Insert data = "</span> + id)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OracleDB</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MySqlDB</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MongoDB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span></span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="叠加特质">叠加特质</h3>
<h4 id="混入时叠加">混入时叠加</h4>
<p>同时混入多个特质叫做叠加特质。</p>
<p>Scala在叠加特质的时候：</p>
<ul>
<li><strong>创建对象</strong>是按照特质声明顺序<strong>从左到右</strong>初始化（如果有相同的父特质，父特质只初始化一次，后续的子特质将跳过父特质的初始化）；</li>
<li>然而在<strong>调用特质中的方法</strong>时：是按特质声明顺序<strong>从右到左</strong>执行，当执行到<code>super</code>时，执行的是左边特质中的方法，如果左边没有特质了，则执行父特质中的相应方法。</li>
</ul>
<p>整个过程有点像<strong>栈</strong>。以下是举例：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyTest</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123; <span class="comment">// 构建对象时！</span></span><br><span class="line">    <span class="comment">// 初始化输出如下（从左到右的初始化）：</span></span><br><span class="line">    <span class="comment">// 1. InsertOpt</span></span><br><span class="line">    <span class="comment">// 2. InsertData</span></span><br><span class="line">    <span class="comment">// 3. InsertDB</span></span><br><span class="line">    <span class="comment">// 4. InsertFile</span></span><br><span class="line">    <span class="keyword">val</span> myTry = <span class="keyword">new</span> <span class="type">MyTry</span> <span class="keyword">with</span> <span class="type">InsertDB</span> <span class="keyword">with</span> <span class="type">InsertFile</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出顺序如下（按上述声明顺序从右到左的调用！）：</span></span><br><span class="line">    <span class="comment">// InsertFile.insert -&gt; InsertDB.insert -&gt; InsertData.insert</span></span><br><span class="line">    <span class="comment">// 1. Insert fileData = 123</span></span><br><span class="line">    <span class="comment">// 2. Insert dbData = 123 注意此处！第2个输出的并不是 Insert data = 123</span></span><br><span class="line">    <span class="comment">// 3. Insert data = 123 这里才是调用InserData中的insert方法。</span></span><br><span class="line">    myTry.insert(<span class="number">123</span>)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTry</span> </span>&#123;&#125; <span class="comment">// 用于测试</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">InsertOpt</span> </span>&#123;</span><br><span class="line">    println(<span class="string">"InsertOpt"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span></span>(num: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">InsertData</span> <span class="keyword">extends</span> <span class="title">InsertOpt</span> </span>&#123;</span><br><span class="line">    println(<span class="string">"InsertData"</span>)</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">insert</span></span>(data: <span class="type">Int</span>)&#123;</span><br><span class="line">        println(<span class="string">"Insert data = "</span> + data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">InsertDB</span> <span class="keyword">extends</span> <span class="title">InsertData</span> </span>&#123;</span><br><span class="line">    println(<span class="string">"InsertDB"</span>)</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">insert</span></span>(dbData: <span class="type">Int</span>)&#123;</span><br><span class="line">        println(<span class="string">"Insert dbData = "</span> + dbData)</span><br><span class="line">        <span class="keyword">super</span>.insert(dbData)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">InsertFile</span> <span class="keyword">extends</span> <span class="title">InsertData</span> </span>&#123;</span><br><span class="line">    println(<span class="string">"InsertFile"</span>)</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">insert</span></span>(fileData: <span class="type">Int</span>)&#123;</span><br><span class="line">        println(<span class="string">"Insert fileData = "</span> + fileData)</span><br><span class="line">        <span class="keyword">super</span>.insert(fileData)</span><br><span class="line">        <span class="comment">// 可以直接指定父类</span></span><br><span class="line">        <span class="comment">// super[InsertData].insert(fileData)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用<code>myTry.insert(123)</code>时之所以输出顺序是这样的，其实是因为在构建动态混入对象时，底层是用栈类实现的，详细来说就是：<strong><code>MyTry</code>相当于是<code>MyTry+InsertDB</code>的父类，而<code>MyTry+InsertDB</code>相当于最终类<code>MyTry+InsertDB+InsertFile</code>的父类</strong>。</p>
<p>也可以在子特质中直接指定父特质，但只能直接指定<strong>直接父特质</strong>。</p>
<h4 id="abstract-override">abstract override</h4>
<p>示例：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyTest</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123; <span class="comment">// 构建对象时！</span></span><br><span class="line">    <span class="keyword">val</span> myTry = <span class="keyword">new</span> <span class="type">MyTry</span> <span class="keyword">with</span> <span class="type">InsertData2</span> <span class="keyword">with</span> <span class="type">InsertData</span> <span class="comment">// 可以创建</span></span><br><span class="line">    <span class="comment">// 输出的顺序如下：</span></span><br><span class="line">    <span class="comment">// 1. Insert data = 123</span></span><br><span class="line">    <span class="comment">// 2. Insert data2 = 123，也就是说，</span></span><br><span class="line">    <span class="comment">// super.insert(123)调用的不是InsertOpt中的方法，而是InsertData2中的方法</span></span><br><span class="line">    myTry.insert(<span class="number">123</span>) <span class="comment">// 也可以调用</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 运行时报错！</span></span><br><span class="line">    <span class="keyword">val</span> myTry2 = <span class="keyword">new</span> <span class="type">MyTry</span> <span class="keyword">with</span> <span class="type">InsertData</span> <span class="keyword">with</span> <span class="type">InsertData2</span></span><br><span class="line">    myTry2.insert(<span class="number">123</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTry</span> </span>&#123;&#125; <span class="comment">// 用于测试</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">InsertOpt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span></span>(num: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">InsertData</span> <span class="keyword">extends</span> <span class="title">InsertOpt</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 因为调用了super，而父特质实际上是抽象的，所以必须要加abstract，</span></span><br><span class="line">    <span class="comment">// 然而又因为是实现父类方法，所以还得加上override</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">insert</span></span>(data: <span class="type">Int</span>)&#123;</span><br><span class="line">        println(<span class="string">"Insert data = "</span> + data)</span><br><span class="line">        <span class="comment">// 调用了super，但并不是调用的InsertOpt.insert，毕竟父类是抽象类，该方法没有实现</span></span><br><span class="line">        <span class="keyword">super</span>.insert(data) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">InsertData2</span> <span class="keyword">extends</span> <span class="title">InsertOpt</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里就只是单纯的实现父特质中的方法，所以不用加abstract</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">insert</span></span>(data: <span class="type">Int</span>)&#123;</span><br><span class="line">        println(<span class="string">"Insert data2 = "</span> + data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述对<code>super</code>的调用和混入顺序密切相关！并不一定指的是父特质！</p>
<h3 id="特质构造流程">特质构造流程</h3>
<p>以下方代码为例：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">A</span> </span>&#123;println(<span class="string">"trait A..."</span>)&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;println(<span class="string">"trait B..."</span>)&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;println(<span class="string">"trait C..."</span>)&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;println(<span class="string">"trait D..."</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span> </span>&#123; println(<span class="string">"class E..."</span>) &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span> <span class="keyword">extends</span> <span class="title">E</span> <span class="keyword">with</span> <span class="title">C</span> <span class="keyword">with</span> <span class="title">D</span> </span>&#123; println(<span class="string">"class F..."</span>)&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">G</span> <span class="keyword">extends</span> <span class="title">E</span> </span>&#123;println(<span class="string">"class G..."</span>)&#125;</span><br></pre></td></tr></table></figure>
<p>两种方式的流程：</p>
<ol type="1">
<li><p>声明类的同时混入特质：</p>
<p>此时特质和父类处于同一级别，相当于把特质也当成了父类。顺序如下：</p>
<p>1）调用父类构造器</p>
<p>2）第一个特质的父特质构造器</p>
<p>3）第一个特质的构造器</p>
<p>4）第二个特质的父特质构造器</p>
<p>5）第二个特质的构造器</p>
<p>...</p>
<p>n）当前类构造器</p>
<p>例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">A</span> </span>&#123;println(<span class="string">"trait A..."</span>)&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;println(<span class="string">"trait B..."</span>)&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;println(<span class="string">"trait C..."</span>)&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;println(<span class="string">"trait D..."</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span> </span>&#123; println(<span class="string">"class E..."</span>) &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span> <span class="keyword">extends</span> <span class="title">E</span> <span class="keyword">with</span> <span class="title">C</span> <span class="keyword">with</span> <span class="title">D</span> </span>&#123; println(<span class="string">"class F..."</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyTest</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123; <span class="comment">// 构建对象时！</span></span><br><span class="line">    <span class="comment">// 输出如下：</span></span><br><span class="line">    <span class="comment">// class E... 初始化父类E</span></span><br><span class="line">    <span class="comment">// trait A... </span></span><br><span class="line">    <span class="comment">// trait B...</span></span><br><span class="line">    <span class="comment">// trait C...</span></span><br><span class="line">    <span class="comment">// trait D...</span></span><br><span class="line">    <span class="comment">// class F... 最后才初始化自身</span></span><br><span class="line">    <span class="keyword">val</span> testF = <span class="keyword">new</span> <span class="type">F</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>可以理解成，混入特质时，对象还在创建过程中。</strong></p></li>
<li><p>在构造对象时混入特质：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">A</span> </span>&#123;println(<span class="string">"trait A..."</span>)&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;println(<span class="string">"trait B..."</span>)&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;println(<span class="string">"trait C..."</span>)&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;println(<span class="string">"trait D..."</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span> </span>&#123; println(<span class="string">"class E..."</span>) &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">G</span> <span class="keyword">extends</span> <span class="title">E</span> </span>&#123;println(<span class="string">"class G..."</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyTest</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123; <span class="comment">// 构建对象时！</span></span><br><span class="line">    <span class="comment">// 输出如下：</span></span><br><span class="line">    <span class="comment">// class E... 初始化父类E</span></span><br><span class="line">    <span class="comment">// class G... 初始化自身</span></span><br><span class="line">    <span class="comment">// trait A... </span></span><br><span class="line">    <span class="comment">// trait B...</span></span><br><span class="line">    <span class="comment">// trait C...</span></span><br><span class="line">    <span class="comment">// trait D...</span></span><br><span class="line">    <span class="keyword">val</span> testG = <span class="keyword">new</span> <span class="type">G</span> <span class="keyword">with</span> <span class="type">C</span> <span class="keyword">with</span> <span class="type">D</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>可以理解成，混入特质前，对象已经创建完成。</strong></p></li>
</ol>
<h3 id="特质从类继承">特质从类继承</h3>
<p>可以扩展继承的类的功能</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">LoggedException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>&#123;&#125; &#123;</span><br><span class="line">        println(getMessage())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>特质TA</code>继承自<code>类A</code>，那么，所有混入了<code>特质TA</code>的类，都将自动成为<code>类A</code>的子类。这一点体现了传递性，同时也说明了Scala中，特质和类非常像。</p>
<p>如果混入了<code>特质TA</code>的类还继承了<code>类B</code>，那么<code>类B</code>必须是<code>类A</code>的子类，否则将发生<strong>多继承现象</strong>。</p>
<h3 id="自身类型">自身类型</h3>
<p>主要是为了<strong>解决特质的循环依赖问题</strong>，同时可以确保特质在不扩展某个类的时候，依然可以做到<strong>限制混入该特质的类的类型</strong>。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 明确告诉编译器，我就是Exception，如果没有这句话，下面的getMessage无法使用，除非显式继承</span></span><br><span class="line">    <span class="keyword">this</span>: <span class="type">Exception</span> =&gt;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>()&#123;</span><br><span class="line">        println(getMessage)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Console</span> <span class="keyword">extends</span> <span class="title">Logger</span> </span>&#123;&#125; <span class="comment">// 报错！</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Console</span> <span class="keyword">extends</span> <span class="title">Exception</span> <span class="keyword">with</span> <span class="title">Logger</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内部类">内部类</h2>
<p>声明内部类的语法和Java相同，但创建内部类的语法和Java有区别</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterA</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明内部类</span></span><br><span class="line">    <span class="keyword">var</span> firstName = <span class="string">"123"</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> lastName = <span class="string">"456"</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerA</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fullName</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 访问外部类中属性的方式：外部类名.this.属性名</span></span><br><span class="line">            <span class="type">OuterA</span>.<span class="keyword">this</span>.lastName + <span class="type">OuterA</span>.<span class="keyword">this</span>.firstName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">OuterA</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerA</span></span>&#123;&#125; <span class="comment">// 静态内部类</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> outerA = <span class="keyword">new</span> <span class="type">OuterA</span></span><br><span class="line"><span class="keyword">val</span> innerA = <span class="keyword">new</span> testA.<span class="type">InnerA</span> <span class="comment">// Java的语法则是 var testAA = A.new AA();</span></span><br><span class="line"><span class="keyword">val</span> staticInnerA = <span class="keyword">new</span> <span class="type">OuterA</span>.<span class="type">StaticInnerA</span> <span class="comment">// 创建内部静态类</span></span><br></pre></td></tr></table></figure>
<p>从这个创建内部类实例的语法可以看出，Scala中内部类和外部对象其实是绑定的。</p>
<h3 id="内部类访问外部类的属性">内部类访问外部类的属性</h3>
<p>有两种方法：</p>
<h4 id="方法1外部类名.this.属性名">方法1：外部类名.this.属性名</h4>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> firstName = <span class="string">"123"</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> lastName = <span class="string">"456"</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerA</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fullName</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 访问外部类中属性的方式：外部类名.this.属性名</span></span><br><span class="line">            <span class="type">OuterA</span>.<span class="keyword">this</span>.lastName + <span class="type">OuterA</span>.<span class="keyword">this</span>.firstName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法2为外部类创建别名">方法2：为外部类创建别名</h4>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterA</span> </span>&#123;</span><br><span class="line">    myOuterA=&gt; <span class="comment">// 别名，请写在第一行，相当于创建了一个名为myOuterA的外部内实例</span></span><br><span class="line">    <span class="keyword">var</span> firstName = <span class="string">"123"</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> lastName = <span class="string">"456"</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerA</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fullName</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 访问外部类中属性的方式：外部类名.this.属性名</span></span><br><span class="line">            myOuterA.lastName + myOuterA.firstName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类型投影">类型投影</h3>
<p>由于Scala中，<strong>内部类</strong>和<strong>外部对象（不是外部类）</strong>是绑定的，如果内部类中某些方法需要以内部类对象作为参数，那么此时就会出现问题，如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterA</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerA</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">printInner</span></span>(inner: <span class="type">InnerA</span>)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> outer1 = <span class="keyword">new</span> <span class="type">OuterA</span></span><br><span class="line"><span class="keyword">val</span> outer2 = <span class="keyword">new</span> <span class="type">OuterA</span></span><br><span class="line"><span class="keyword">val</span> inner1 = <span class="keyword">new</span> outer1.<span class="type">InnerA</span></span><br><span class="line"><span class="keyword">val</span> inner2 = <span class="keyword">new</span> outer2.<span class="type">InnerA</span></span><br><span class="line">inner1.printInner(inner1) <span class="comment">// 没有问题</span></span><br><span class="line">inner1.printInner(inner2) <span class="comment">// 报错！</span></span><br></pre></td></tr></table></figure>
<p>为了解决上述问题，需要将上述<code>printInner</code>的参数改为如下形式：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterA</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerA</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">printInner</span></span>(inner: <span class="type">OuterA</span>#<span class="type">InnerA</span>)&#123;&#125; <span class="comment">// 表示不要再考虑外部对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述语法即为<strong>类型投影</strong>：屏蔽外部实例对内部类的影响。</p>
<h2 id="操作符重载">操作符重载</h2>
<p>跟C++中的操作符重载很类似：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monster</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span>: <span class="type">Int</span> money</span><br><span class="line">    <span class="comment">// 中置操作符</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">+</span></span>(n:<span class="type">Int</span>):<span class="type">Monster</span> =&#123;</span><br><span class="line">        <span class="keyword">this</span>.money += n</span><br><span class="line">        <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置操作符</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">++</span></span>():<span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">this</span>.money += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前置操作符：+，-，！，~，它们等同于 A.unary_操作符，</span></span><br><span class="line">    <span class="comment">// 例如取反操作：！</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unary_!</span></span>():<span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">this</span>.monty = -<span class="keyword">this</span>.monty</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="隐式转换和隐式值">隐式转换和隐式值</h1>
<h2 id="隐式转换函数">隐式转换函数</h2>
<p>以<code>implicit</code>关键字声明的<strong>有且只有单个参数</strong>的函数，这种函数将会自动的把一种类型的值转换为另一种类型（例如将<code>Double</code>转换成<code>Int</code>）</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyTest</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">f1</span></span>(d:<span class="type">Double</span>): <span class="type">Int</span> = &#123; <span class="comment">// 底层会生成一个名为f1$1的函数</span></span><br><span class="line">        d.toInt</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果没有f1，该行代码将报错，但是有了f1, f1将被自动调用</span></span><br><span class="line">    <span class="comment">// 底层其实是 int temp = f1$1(3.6)</span></span><br><span class="line">    <span class="keyword">var</span> temp:<span class="type">Int</span> = <span class="number">3.6</span> <span class="comment">// idea中，3.6将会有一条下划线，表示此处应用了隐式转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>隐式函数可以有多个，但必须保证能被<strong>唯一识别</strong>。</p>
<h3 id="利用隐式函数的功能丰富类库">利用隐式函数的功能丰富类库</h3>
<p>可以为某个类“添加”其他类的功能：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyTest</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">f1</span></span>(mysql:<span class="type">MySQL</span>): <span class="type">DB</span> = &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="type">DB</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> mysql = <span class="keyword">new</span> <span class="type">MySQL</span></span><br><span class="line">    mysql.insert()</span><br><span class="line">    mysql.delete() <span class="comment">// 相当于为mysql“添加”了一个delete方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySQL</span> </span>&#123; <span class="function"><span class="keyword">def</span> <span class="title">insert</span></span>()&#123;&#125; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DB</span> </span>&#123; <span class="function"><span class="keyword">def</span> <span class="title">delete</span></span>()&#123;&#125; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="隐式值">隐式值</h2>
<p>也称为隐式变量。如果某函数只有一个形参，且将其标记为<code>implicit</code>，那么编译器将会在方法省略该参数的情况下，自动去搜寻作用域内的隐式值作为其缺省参数。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyTest</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">val</span> str1:<span class="type">String</span> = <span class="string">"Jack"</span>   <span class="comment">// 隐式值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span>(<span class="keyword">implicit</span> name: <span class="type">String</span>= “test”)&#123; println(name) &#125;</span><br><span class="line">    <span class="comment">// 调用hello函数，自动传入str1。</span></span><br><span class="line">    <span class="comment">// 输出Jack</span></span><br><span class="line">    hello <span class="comment">// 不要写小括号，否则报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和函数默认值的区别：默认值只能作用在一个函数，而隐式值可以作用在多个函数。</p>
<p>编译器的优先级：<strong>传入值 》隐式值 》默认值</strong></p>
<h2 id="隐式类">隐式类</h2>
<p>它比之前通过定义隐式函数来丰富类库更加方便，在集合中隐式类发挥的作用更大。</p>
<p>特点：</p>
<ul>
<li>构造器的构造参数有且只能有1个；</li>
<li>隐式类只能被定义在“类”或“伴生对象”或“包对象”中，即<strong>隐式类不能是顶级的</strong>；</li>
<li>隐式类不能是<code>case class</code>；</li>
<li>作用域内不能有与之同名的标识符。</li>
</ul>
<p>例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyTest</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">DB</span>(<span class="params">val m: <span class="type">MySQL</span></span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">addSuffix</span></span>() &#123;</span><br><span class="line">            println(<span class="string">"addSuffix"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> m = <span class="keyword">new</span> <span class="type">MySQL</span></span><br><span class="line">    m.sayOK()</span><br><span class="line">    m.addSuffix()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySQL</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sayOK</span></span>()&#123; </span><br><span class="line">        println(<span class="string">"OK"</span>) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="隐式转换机制总结">隐式转换机制总结</h2>
<p>隐式转换的<strong>前提</strong>：</p>
<ul>
<li><p>不能存在二义性</p></li>
<li><p>隐式操作不能嵌套：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyTest</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">f1</span></span>(d:<span class="type">Double</span>): <span class="type">Int</span> = &#123; <span class="comment">// 底层会生成一个名为f1$1的函数</span></span><br><span class="line">        d.toInt</span><br><span class="line">        <span class="keyword">val</span> num:<span class="type">Int</span> = <span class="number">5.6</span> <span class="comment">// 产生了嵌套</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>隐式转换<strong>时机</strong>：</p>
<ul>
<li>当方法中参数的类型与目标类型不一致时；</li>
<li>当对象调用本身不存在的方法或成员时；</li>
</ul>
<p>隐式转换的<strong>搜索范围</strong>如下：</p>
<ol type="1">
<li><strong>编译器首先会在当前代码作用域中去查找隐式实体；</strong></li>
<li><strong>如果没找到，会继续在隐式参数的类型的作用域中查找。</strong>（该情况范围广且复杂，应该尽量避免）</li>
</ol>
<h1 id="模式匹配">模式匹配</h1>
<h2 id="match模式匹配">match模式匹配</h2>
<p>对应于Java中的<code>switch</code>，例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> opt = '#'</span><br><span class="line"><span class="keyword">val</span> left = <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> right = <span class="number">2</span></span><br><span class="line"><span class="keyword">val</span> rst = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">opt <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> '+' =&gt; rst = left + right	<span class="comment">// 不需要break</span></span><br><span class="line">    <span class="keyword">case</span> '-' =&gt; </span><br><span class="line">        rst = left - right</span><br><span class="line">        println(<span class="string">"减号"</span>) <span class="comment">// 虽然可以这样写，但推荐使用大括号</span></span><br><span class="line">    <span class="keyword">case</span> '*' =&gt; rst = left * right</span><br><span class="line">    <span class="keyword">case</span> '/' =&gt; rst = left / right</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span> =&gt; println(<span class="string">"匹配到1"</span>)</span><br><span class="line">    <span class="keyword">case</span> _ <span class="keyword">if</span> 条件 =&gt; println(<span class="string">"条件守卫"</span>)</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; println(<span class="string">"没有匹配到相应的操作符！"</span>)	<span class="comment">// 默认</span></span><br><span class="line">    <span class="keyword">case</span> _ =&gt; println(<span class="string">"永远不会被匹配到这一行，但是并不会有提示，需要自行检查"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有匹配到，且也没有写默认匹配，则会抛出异常（Java中不会抛出异常）。</p>
<p>虽然每一个<code>case</code>可以多行且不被大括号括起来，但最好还是用大括号扩起来。</p>
<h3 id="match中的变量">match中的变量</h3>
<p>可以将输入的变量赋值给<code>match</code>中的<code>case</code>，但这样的话，永远只会匹配到一个，如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ch = <span class="string">"test"</span></span><br><span class="line">ch <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"+"</span> =&gt; println(<span class="string">"ok, +"</span>)</span><br><span class="line">    <span class="comment">// 将ch赋值给了mychar，但此时只会匹配到这一项</span></span><br><span class="line">    <span class="keyword">case</span> mychar = println(<span class="string">"OK, "</span> + mychar)</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; println(<span class="string">"default"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码将<code>ch</code>的值赋值给了<code>mychar</code>，并且这种匹配永远只会匹配到<code>mychar</code>那一个<code>case</code>。</p>
<h3 id="match返回值">match返回值</h3>
<p>Scala中，<code>match</code>是有返回值的，它的返回值是匹配到的<code>case</code>块中的最后一行代码的值。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ch = <span class="string">"test"</span></span><br><span class="line"><span class="keyword">val</span> rst = ch <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"test"</span> =&gt; ch + <span class="string">" hello"</span></span><br><span class="line">    <span class="keyword">case</span> _ =&gt; println(<span class="string">"default"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "test hello"</span></span><br><span class="line">println(rst)</span><br></pre></td></tr></table></figure>
<h3 id="match匹配">match匹配</h3>
<h4 id="match类型匹配">match类型匹配</h4>
<p>可以根据变量的类型来匹配。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rst = obj <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> a:<span class="type">Int</span> =&gt; a</span><br><span class="line">    <span class="keyword">case</span> b:<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>] =&gt; <span class="string">"这是一个Map[String, Int]类型的对象！"</span></span><br><span class="line">    <span class="comment">// 和case b并不是同一个类型！</span></span><br><span class="line">    <span class="keyword">case</span> c:<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">String</span>] =&gt; <span class="string">"这是一个Map[Int, String]类型的对象！"</span></span><br><span class="line">    <span class="keyword">case</span> _:<span class="type">BigInt</span> =&gt; <span class="type">Int</span>.<span class="type">MaxValue</span> <span class="comment">// 这并不是默认匹配！而是表示后续用不到obj对象</span></span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="string">"没有匹配到"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意上述的<code>case _:BigInt</code>这个匹配，它并不是默认匹配！而是表示对应的<code>case</code>代码块中不会用到输入的对象，故在此隐藏变量名。</p>
<h4 id="match数组匹配">match数组匹配</h4>
<p><code>match</code>还可以根据数组结构匹配数组<code>Array</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> arr = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> result = arr <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Array</span>(<span class="number">0</span>) =&gt; <span class="number">0</span> <span class="comment">// 匹配只有一个元素0的数组</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Array</span>(x, y, z) =&gt; <span class="type">Array</span>(y, x) <span class="comment">// 匹配有3个元素的数组，并且x,y,z会被赋值！</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Array</span>(<span class="number">0</span>, _*) =&gt; <span class="string">"以0开头的数组"</span></span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="string">"什么都没有匹配到"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="match列表匹配">match列表匹配</h4>
<p>上述是匹配索引序列<code>Array</code> ，match还可以匹配有序序列<code>List</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">val</span> rst = list <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>::<span class="type">Nil</span> =&gt; <span class="string">"0"</span></span><br><span class="line">    <span class="keyword">case</span> x::<span class="type">Nil</span> =&gt; x <span class="comment">// 原值返回</span></span><br><span class="line">    <span class="keyword">case</span> x::y::<span class="type">Nil</span> =&gt; <span class="string">"该列表只有两个元素"</span> + x + <span class="string">" "</span> + y</span><br><span class="line">    <span class="comment">// rest将会是一个List，用于保留剩余的元素</span></span><br><span class="line">    <span class="keyword">case</span> first::second::rest =&gt; println(rest.length)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>::tail =&gt; <span class="string">"0, ..."</span></span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="string">"Nothing to match"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="match元组匹配">match元组匹配</h4>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> tuple = (<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">val</span> rst = tuple <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> (<span class="number">0</span>, _) =&gt; <span class="string">"(0, x)"</span></span><br><span class="line">    <span class="keyword">case</span> (y, <span class="number">0</span>) =&gt; y</span><br><span class="line">    <span class="keyword">case</span> (x, y) =&gt; x * y</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="string">"Other"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="match对象匹配">match对象匹配</h4>
<p><code>case</code>中对象的<code>unapply</code>方法（对象提取器）返回<code>Some</code>集合则为匹配成功，返回<code>None</code>则匹配失败：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(z:<span class="type">Double</span>):<span class="type">Double</span> = z * z</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unapply</span></span>(z:<span class="type">Double</span>):<span class="type">Option</span>[<span class="type">Double</span>] = <span class="type">Some</span>(math.sqrt(z))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unapplySeq</span></span>(str:<span class="type">String</span>):<span class="type">Option</span>[<span class="type">Seq</span>[<span class="type">String</span>]] = &#123;</span><br><span class="line">        <span class="keyword">if</span> (seq.contains(<span class="string">","</span>)) </span><br><span class="line">            <span class="type">Some</span>(str.split(<span class="string">","</span>))</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="type">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> num = <span class="number">36.0</span></span><br><span class="line">num <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="comment">// 会调用unapply方法去解析出当初构造对象时传入的参数，而不是apply方法！</span></span><br><span class="line">    <span class="comment">// 如果匹配成功，它将返回Some(x)，并且，它还会将其中的x赋值给下方Square(n)中的n</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Test</span>(n) =&gt; println(n)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Test</span>(first, second, third) =&gt;</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="string">"Other"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上述的<code>num</code>进入<code>case Square(n)</code>时，<code>match</code>会去调用<code>Square</code>的<code>unapply(对应单参数构造器)</code>或者<code>unapplySeq(对应多参数构造器)</code>方法去解析出当初构造对象时传入的参数，不过这个机制由用户决定，而不是去真的倒推当初真正传入的参数。</p>
<p>这种情景常用于根据已知对象，反推当初对象是怎么构建的，尤其是对象构建时的初始值。</p>
<h2 id="变量声明中的模式">变量声明中的模式</h2>
<p>这里有点类似于Python中的解包：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> (x, y) = (<span class="number">1</span>, <span class="number">2</span>)	<span class="comment">// x = 1, y = 2</span></span><br><span class="line"><span class="keyword">val</span> (q, r) = <span class="type">BigInt</span>(<span class="number">10</span>) /% <span class="number">3</span>	<span class="comment">// q = 3, r = 1</span></span><br><span class="line"><span class="keyword">val</span> <span class="type">Array</span>(first, second, _*) = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)	<span class="comment">// first = 1, second = 2</span></span><br></pre></td></tr></table></figure>
<h2 id="for表达式中的模式">for表达式中的模式</h2>
<p>除了之前已经提到过的遍历<code>Map</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map = <span class="type">Map</span>(<span class="string">"A"</span> -&gt; <span class="number">1</span>, <span class="string">"B"</span> -&gt; <span class="number">2</span>, <span class="string">"C"</span> -&gt; <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> ((k, v) &lt;- map) &#123;</span><br><span class="line">    println(k + <span class="string">"-&gt;"</span> + v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以直接筛选满足条件的值，例如，只输出<code>value</code>为<code>0</code>的值：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((k, <span class="number">0</span>) &lt;- map) &#123;</span><br><span class="line">    println(k + <span class="string">"-&gt;"</span> + v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">for</span> ((k, v) &lt;- map <span class="keyword">if</span> v == <span class="number">0</span>) &#123;</span><br><span class="line">    println(k + <span class="string">"-&gt;"</span> + v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="样例类case-class">样例类case class</h2>
<ul>
<li><p>样例类任然是类</p></li>
<li><p>样例类使用<code>case</code>关键字进行声明</p></li>
<li><p>样例类是为模式匹配而优化的类</p></li>
<li><p>构造器中的每一个参数都将成为该类的一个<code>val</code>属性（也可以显式的声明为<code>var</code>，但不建议这样做）</p></li>
<li><p>提供<code>unapply</code>方法让模式匹配可以工作</p></li>
<li><p>将自动生成<code>toString</code>，<code>equals</code>，<code>hashCode</code>和<code>copy</code>等方法（有点类似于模板类）</p></li>
<li><p>除上述外，样例类和普通类完全一样，可以添加方法和字段对其进行扩展</p></li>
</ul>
<p>以下是样例类的声明方式：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTestCaseClass</span>(<span class="params">name: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">abstract</span> <span class="title">class</span> <span class="title">Amount</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Dollar</span>(<span class="params">value: <span class="type">Double</span></span>) <span class="keyword">extends</span> <span class="title">Amount</span></span></span><br></pre></td></tr></table></figure>
<h3 id="样例类的用途">样例类的用途</h3>
<ol type="1">
<li><p>样例类的主要用途之一就是前方的<code>match</code>对象匹配，将对象中的属性值提取到变量中。</p></li>
<li><p>通过样例类自带的<code>copy</code>方法赋值对象，同时还可以在copy时修改某些属性 <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dollar = <span class="type">Dollar</span>(<span class="number">100</span>)</span><br><span class="line"><span class="keyword">val</span> otherDollar = dollar.copy(value = <span class="number">1000</span>)</span><br></pre></td></tr></table></figure></p></li>
<li><p>匹配嵌套结构 <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyTest</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> sale = <span class="type">Bundle</span>(<span class="string">"书籍"</span>, <span class="number">10</span>, <span class="type">Book</span>(<span class="string">"海贼王"</span>, <span class="number">40</span>), <span class="type">Bundle</span>(<span class="string">"文学作品"</span>, <span class="number">20</span>, <span class="type">Book</span>(<span class="string">"围城"</span>, <span class="number">30</span>), <span class="type">Book</span>(<span class="string">"羊脂球"</span>, <span class="number">50</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 绑定单个变量</span></span><br><span class="line">    <span class="keyword">val</span> rst = sale <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Bundle</span>(_, _, <span class="type">Book</span>(desc, _), _*) =&gt; desc</span><br><span class="line">    &#125; <span class="comment">// rst == "海贼王"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过@表示法将嵌套的值绑定到变量</span></span><br><span class="line">    <span class="comment">// art == Book("海贼王", 40),</span></span><br><span class="line">    <span class="comment">// rest == WrappedArray(Bundle("文学作品", 20, WrappedArray(Book("围城", 30), Book("羊脂球", 50))))</span></span><br><span class="line">    <span class="keyword">val</span> rst2 = sale <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Bundle</span>(_, _, art<span class="meta">@Book</span>(_, _), rest@_*) =&gt; (art, rest)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.不使用_*绑定剩余对象</span></span><br><span class="line">    <span class="comment">// art == Book("海贼王", 40),</span></span><br><span class="line">    <span class="comment">// rest == Bundle("文学作品", 20, WrappedArray(Book("围城", 30), Book("羊脂球", 50)))</span></span><br><span class="line">    <span class="keyword">val</span> rst3 = sale <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Bundle</span>(_, _, art<span class="meta">@Book</span>(_, _), rest) =&gt; (art, rest)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 应用案例：商品捆绑打折销售</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calPrice</span></span>(it: <span class="type">Item</span>): <span class="type">Double</span> = &#123;</span><br><span class="line">        it <span class="keyword">match</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="type">Book</span>(_, p) =&gt; p</span><br><span class="line">            <span class="keyword">case</span> <span class="type">Bundle</span>(_, discount, its@_*) =&gt; its.map(calPrice).sum - discount</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Book</span>(<span class="params">desc: <span class="type">String</span>, price: <span class="type">Double</span></span>) <span class="keyword">extends</span> <span class="title">Item</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Bundle</span>(<span class="params">desc: <span class="type">String</span>, discount: <span class="type">Double</span>, items: <span class="type">Item</span>*</span>) <span class="keyword">extends</span> <span class="title">Item</span></span></span><br></pre></td></tr></table></figure></p></li>
</ol>
<h3 id="密封类">密封类</h3>
<p>如果想让case类的所有子类都必须在申明该类的源文件中定义，可以将样例类的通用超类声明为<code>sealed</code>，这个超类称之为密封类：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Amount</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Dollar</span>(<span class="params">v:<span class="type">Double</span></span>) <span class="keyword">extends</span> <span class="title">Amount</span></span></span><br></pre></td></tr></table></figure>
<h1 id="类型约束">类型约束</h1>
<h2 id="范型">范型</h2>
<p>使用中括号<code>[]</code>来指定范型：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 范型类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span>[<span class="type">T</span>](<span class="params">s: <span class="type">T</span></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span></span>: <span class="type">T</span> = s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntMessage</span>[<span class="type">Int</span>](<span class="params">v: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Message</span>(<span class="params">v</span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">IntMessage</span>[<span class="type">String</span>](<span class="params">v: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Message</span>(<span class="params">v</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">范型函数</span></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">midList</span>[<span class="type">E</span>](<span class="params">list: <span class="type">List</span>[<span class="type">E</span>]</span>)</span>: <span class="type">E</span> = &#123;</span><br><span class="line">    list(list.length / <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="上界upper-bounds和下界lower-bounds">上界(Upper Bounds)和下界(Lower bounds)</h2>
<h3 id="上界">上界</h3>
<p>在Scala范型中，要表示某个类是<code>A</code>类的子类（也就是上界或上限，即<code>T</code>的上界是<code>A</code>），使用的是<code>&lt;:</code>关键字：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">T</span> &lt;: <span class="type">A</span>]</span><br><span class="line">[_ &lt;: <span class="type">A</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommonCompare</span>[<span class="type">T</span> &lt;: <span class="type">Comparable</span>[<span class="type">T</span>]](<span class="params">obj1: <span class="type">T</span>, obj2: <span class="type">T</span></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">greater</span> </span>= <span class="keyword">if</span> (obj1.compareTo(obj2) &gt; <span class="number">0</span>) obj1 <span class="keyword">else</span> obj2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比，在Java中，上界的表示形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;T extends A&gt;</span><br><span class="line">&lt;? extends A&gt;</span><br></pre></td></tr></table></figure>
<h3 id="下界">下界</h3>
<p>在Scala范型中，要表示某个类是<code>A</code>类的父类（也就是下界或下限，即<code>T</code>的下界是<code>A</code>），使用的是<code>&gt;:</code>关键字：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">T</span> &gt;: <span class="type">A</span>]</span><br><span class="line">[_ &gt;: <span class="type">A</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="comment">// 可以调用！但有些地方需要注意！</span></span><br><span class="line">        <span class="comment">// 即使当作Animal，依然输出的是 bird sounds，因为方法覆盖</span></span><br><span class="line">        biophony(<span class="type">Seq</span>(<span class="keyword">new</span> <span class="type">Bird</span>)).map(_.sound())</span><br><span class="line">        <span class="comment">// 此时输出的则是 animal sound</span></span><br><span class="line">        biophony(<span class="type">Seq</span>(<span class="keyword">new</span> <span class="type">Cat</span>)).map(_.sound())</span><br><span class="line">        biophony(<span class="type">Seq</span>(<span class="keyword">new</span> <span class="type">Moon</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">biophony</span></span>[<span class="type">T</span> &gt;: <span class="type">Animal</span>](things: <span class="type">Seq</span>[<span class="type">T</span>]): <span class="type">Seq</span>[<span class="type">T</span>] = things</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Earth</span> </span>&#123; <span class="comment">//Earth 类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sound</span></span>() &#123; <span class="comment">//方法</span></span><br><span class="line">        println(<span class="string">"hello !"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="keyword">extends</span> <span class="title">Earth</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">sound</span></span>() = &#123; <span class="comment">//重写了Earth的方法sound()</span></span><br><span class="line">        println(<span class="string">"animal sound"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">sound</span></span>() = &#123; <span class="comment">//将Animal的方法重写</span></span><br><span class="line">        print(<span class="string">"bird sounds"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Moon</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，<code>Bird</code>和<code>Moon</code>都不是<code>Animal</code>的父类，但是却可以调用，这是因为：</p>
<ul>
<li><p>当传入的类和<code>Animal</code>是直系的时，如果是<code>Animal</code>的父类，则正常处理；如果是<code>Animal</code>的子类，则按照<code>Animal</code>处理，但如果有方法覆盖，依然调用的是子类的方法；</p></li>
<li><p>如果传入的类和<code>Animal</code>无关，则一律按照<code>Object</code>类处理！</p></li>
</ul>
<p>也就是说，Scala中，对于下界，可以传入任意类型，但是不能使用上界的思路来类推下界的含义。</p>
<p>对比，在Java中，下界的表示形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;T <span class="keyword">super</span> A&gt;</span><br><span class="line">&lt;? <span class="keyword">super</span> A&gt;</span><br></pre></td></tr></table></figure>
<h2 id="视图界定view-bounds">视图界定(View bounds)</h2>
<p>Scala中还有一个关键字<code>&lt;%</code>，它的意思是视界(view bounds)，它比上界<code>&lt;:</code>适用的范围更广，除了包含所有的子类，还允许隐式转换类型。它除了可以用在方法中之外，还可以用在<code>class</code>声明类型参数中：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用在方法中：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">method</span></span>[<span class="type">A</span> &lt;% <span class="type">B</span>](args) = &#123;&#125; </span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">method</span></span>[<span class="type">A</span>](args)(<span class="keyword">implicit</span> viewAB:<span class="type">A</span> =&gt; <span class="type">B</span>) = &#123;&#125;</span><br><span class="line"><span class="comment">// 也等价于：</span></span><br><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">conver</span></span>(a: <span class="type">A</span>): <span class="type">B</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用在类声明中：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>[<span class="type">T</span> &lt;% <span class="type">Int</span>]</span></span><br></pre></td></tr></table></figure>
<p>视图界定主要针对隐式函数和隐式类。</p>
<p>依旧使用上界中的例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyTest</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用了隐式转换，如果上界中这么写，将会报错</span></span><br><span class="line">    <span class="keyword">val</span> compareComm1 = <span class="keyword">new</span> <span class="type">CompareComm</span>(<span class="number">1</span>, <span class="number">20</span>)</span><br><span class="line">    <span class="keyword">val</span> compareComm2 = <span class="keyword">new</span> <span class="type">CompareComm</span>(<span class="number">201.9</span>f, <span class="number">310.1</span>f)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下是上界中的写法：</span></span><br><span class="line">    <span class="keyword">val</span> compareComm3 = <span class="keyword">new</span> <span class="type">CompareComm</span>(<span class="type">Integer</span>.valueOf(<span class="number">20</span>), <span class="type">Integer</span>.valueOf(<span class="number">30</span>))</span><br><span class="line">    <span class="keyword">val</span> compareComm4 = <span class="keyword">new</span> <span class="type">CompareComm</span>[java.lang.<span class="type">Float</span>](<span class="number">201.9</span>f, <span class="number">30.1</span>f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompareComm</span>[<span class="type">T</span> &lt;% <span class="type">Comparable</span>[<span class="type">T</span>]](<span class="params">obj1: <span class="type">T</span>, obj2: <span class="type">T</span></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">greater</span> </span>= <span class="keyword">if</span> (obj1.compareTo(obj2) &gt; <span class="number">0</span>) obj1 <span class="keyword">else</span> obj2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看一个自定义类隐式转换的例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ViewBoundsDemo</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> p1 = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"汤姆"</span>, <span class="number">13</span>)</span><br><span class="line">    <span class="keyword">val</span> p2 = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"杰克"</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发生了隐式转换</span></span><br><span class="line">    <span class="keyword">val</span> compareComm = <span class="keyword">new</span> <span class="type">CompareComm</span>(p1, p2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式转换一般单独放一个文件，这里是为了方便</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyImplicit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">person2OrderedPerson</span></span>(p3: <span class="type">Person</span>): <span class="type">Ordered</span>[<span class="type">Person</span>] = <span class="keyword">new</span> <span class="type">Ordered</span>[<span class="type">Person</span>] &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(that: <span class="type">Person</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">            p3.age - that.age</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">val name: <span class="type">String</span>, val age: <span class="type">Int</span></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompareComm</span>[<span class="type">T</span> &lt;% <span class="type">Ordered</span>[<span class="type">T</span>]](<span class="params">obj1: <span class="type">T</span>, obj2: <span class="type">T</span></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getter</span> </span>= <span class="keyword">if</span> (obj1 &gt; obj2) obj1 <span class="keyword">else</span> obj2</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里调用的compareTo方法是T这个类型的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">geatter2</span> </span>= <span class="keyword">if</span> (obj1.compareTo(obj2) &gt; <span class="number">0</span>) obj1 <span class="keyword">else</span> obj2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="上下文界定context-bounds">上下文界定(Context bounds)</h2>
<p>与视图界定一样，上下文界定也是隐式参数的语法糖。它的关键字是就是冒号<code>:</code>。</p>
<p>与视图界定不同的是，上下文界定主要针对的是隐式值。</p>
<p>以下是上下文界定的示例：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ContextBoundsDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里定义一个隐式值，它是Ordering[Person]类型</span></span><br><span class="line">    <span class="keyword">implicit</span> <span class="keyword">val</span> personCmptor = <span class="keyword">new</span> <span class="type">Ordering</span>[<span class="type">Person</span>] &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(p1: <span class="type">Person</span>, p2: <span class="type">Person</span>): <span class="type">Int</span> =</span><br><span class="line">            p1.age - p2.age</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">val</span> p1 = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"mary"</span>, <span class="number">30</span>)</span><br><span class="line">        <span class="keyword">val</span> p2 = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"smith"</span>, <span class="number">35</span>)</span><br><span class="line">        <span class="keyword">val</span> compareComm1 = <span class="keyword">new</span> <span class="type">CompareComm1</span>(p1, p2)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> compareComm2 = <span class="keyword">new</span> <span class="type">CompareComm2</span>(p1, p2)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 验证是同一个cmptor</span></span><br><span class="line">        println(<span class="string">"personCmptor hashcode="</span> + personCmptor.hashCode())</span><br><span class="line">        <span class="keyword">val</span> compareComm3 = <span class="keyword">new</span> <span class="type">CompareComm3</span>(p1, p2)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个普通的Person类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">val name: <span class="type">String</span>, val age: <span class="type">Int</span></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式1</span></span><br><span class="line"><span class="comment">//1. [T: Ordering] 泛型</span></span><br><span class="line"><span class="comment">//2. obj1: T, obj2: T 接受T类型的对象</span></span><br><span class="line"><span class="comment">//3. implicit cmptor: Ordering[T] 是一个隐式参数</span></span><br><span class="line"><span class="comment">//4. 柯里化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompareComm1</span>[<span class="type">T</span>: <span class="type">Ordering</span>](<span class="params">obj1: <span class="type">T</span>, obj2: <span class="type">T</span></span>)(<span class="params">implicit cmptor: <span class="type">Ordering</span>[<span class="type">T</span>]</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">greater</span> </span>= <span class="keyword">if</span> (cmptor.compare(obj1, obj2) &gt; <span class="number">0</span>) obj1 <span class="keyword">else</span> obj2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2,将隐式参数放到方法内</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompareComm2</span>[<span class="type">T</span>: <span class="type">Ordering</span>](<span class="params">o1: <span class="type">T</span>, o2: <span class="type">T</span></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">greater</span> </span>= &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f1</span></span>(<span class="keyword">implicit</span> cmptor: <span class="type">Ordering</span>[<span class="type">T</span>]) = cmptor.compare(o1, o2) <span class="comment">//返回一个数字</span></span><br><span class="line">        <span class="comment">//如果f1返回的值&gt;0,就返回o1,否则返回o2</span></span><br><span class="line">        <span class="keyword">if</span> (f1 &gt; <span class="number">0</span>) o1 <span class="keyword">else</span> o2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式3,使用implicitly语法糖，最简单(推荐使用)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompareComm3</span>[<span class="type">T</span>: <span class="type">Ordering</span>](<span class="params">o1: <span class="type">T</span>, o2: <span class="type">T</span></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">greater</span> </span>= &#123;</span><br><span class="line">        <span class="comment">// 这句话就是会发生隐式转换，获取到隐式值 personCmptor</span></span><br><span class="line">        <span class="comment">// 底层仍然使用编译器来完成绑定(赋值的)工作</span></span><br><span class="line">        <span class="keyword">val</span> cmptor = implicitly[<span class="type">Ordering</span>[<span class="type">T</span>]]</span><br><span class="line">        <span class="comment">// 验证是同一个cmptor</span></span><br><span class="line">        println(<span class="string">"cmptor hashcode="</span> + cmptor.hashCode())</span><br><span class="line">        <span class="keyword">if</span> (cmptor.compare(o1, o2) &gt; <span class="number">0</span>) o1 <span class="keyword">else</span> o2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="协变covariant逆变contravariant和不变invariant">协变covariant、逆变contravariant和不变invariant</h2>
<p>对于范型<code>Test[T]</code>:</p>
<ul>
<li><p>协变<code>Test[+T]</code>：如果<code>B</code>是<code>A</code>的子类，且<code>Test[B]</code>也是<code>Test[A]</code>的子类，则称为协变，它的关键字是加号<code>+</code>。</p></li>
<li><p>逆变<code>Test[-T]</code>：如果<code>B</code>是<code>A</code>的子类，但<code>Test[B]</code>却是<code>Test[A]</code>的父类，则称为逆变，它的关键字是减号<code>-</code>。协变与逆变统称为可变。</p></li>
<li><p>不可变<code>Test[T]</code>：无论<code>A</code>和<code>B</code>是什么关系，<code>Test[A]</code>和<code>Test[B]</code>都没有继承关系，这称之为不可变。</p></li>
</ul>
<p>与Java对比：Java中所有但范型都是不可变的，即<code>Test[String]</code>并不是<code>Test[Object]</code>的子类。但是在Scala中，可以在定义类型时声明，例如：<code>trait Test[+T]</code>，这样，<code>Test[String]</code>将作为<code>Test[Any]</code>的子类。</p>
<p>代码示例如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不变</span></span><br><span class="line">    <span class="keyword">val</span> t1: <span class="type">Invariant</span>[<span class="type">Sub</span>] = <span class="keyword">new</span> <span class="type">Invariant</span>[<span class="type">Sub</span>](<span class="string">"hello"</span>);</span><br><span class="line">    <span class="comment">// 报错！</span></span><br><span class="line">    <span class="comment">// val t2: Invariant[Sub] = new Invariant[Super]("hello")</span></span><br><span class="line">    <span class="comment">// val t3: Invariant[Super] = new Invariant[Sub]("hello")</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 协变</span></span><br><span class="line">    <span class="keyword">val</span> t4: <span class="type">Covariant</span>[<span class="type">Super</span>] = <span class="keyword">new</span> <span class="type">Covariant</span>[<span class="type">Sub</span>](<span class="string">"hello"</span>); <span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逆变</span></span><br><span class="line">    <span class="keyword">val</span> t5: <span class="type">Contravariant</span>[<span class="type">Sub</span>] = <span class="keyword">new</span> <span class="type">Contravariant</span>[<span class="type">Super</span>](<span class="string">"hello"</span>); <span class="comment">//ok</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">//不变</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Invariant</span>[<span class="type">A</span>](<span class="params">title: <span class="type">String</span></span>) </span>&#123; <span class="comment">//Temp3[+A] //Temp[-A]</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>: <span class="type">String</span> = title</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//协变</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Covariant</span>[+<span class="type">A</span>](<span class="params">title: <span class="type">String</span></span>) </span>&#123; <span class="comment">//Temp3[+A] //Temp[-A]</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>: <span class="type">String</span> = title</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//逆变</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contravariant</span>[-<span class="type">A</span>](<span class="params">title: <span class="type">String</span></span>) </span>&#123; <span class="comment">//Temp3[+A] //Temp[-A]</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>: <span class="type">String</span> = title</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>嘴强黑铁
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://www.zuiqiangiron.xyz/2020/03/28/Scala%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/" title="Scala学习">https://www.zuiqiangiron.xyz/2020/03/28/Scala基础学习/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Scala/" rel="tag"># Scala</a>
          </div>

        
  <div class="post-widgets">
    <div class="wp_rating">
      <div id="wpac-rating"></div>
    </div>
  </div>


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/03/28/LeetCode%201111.%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%B5%8C%E5%A5%97%E6%B7%B1%E5%BA%A6/" rel="prev" title="LeetCode 1111.有效括号的嵌套深度">
      <i class="fa fa-chevron-left"></i> LeetCode 1111.有效括号的嵌套深度
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/03/29/LeetCode%201079.%E6%B4%BB%E5%AD%97%E5%8D%B0%E5%88%B7/" rel="next" title="LeetCode 1079.活字印刷">
      LeetCode 1079.活字印刷 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#scala数据类型"><span class="nav-number">1.</span> <span class="nav-text">Scala数据类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#scala零散要点"><span class="nav-number">2.</span> <span class="nav-text">Scala零散要点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#scala中的循环"><span class="nav-number">3.</span> <span class="nav-text">Scala中的循环</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#scala中的for循环"><span class="nav-number">3.1.</span> <span class="nav-text">Scala中的for循环：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#while循环和do...while循环"><span class="nav-number">3.2.</span> <span class="nav-text">while循环和do...while循环：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何中断循环"><span class="nav-number">3.3.</span> <span class="nav-text">如何中断循环</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#如何实现break效果"><span class="nav-number">3.3.1.</span> <span class="nav-text">如何实现break效果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何实现continue效果"><span class="nav-number">3.3.2.</span> <span class="nav-text">如何实现continue效果</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#scala中下划线_的含义"><span class="nav-number">4.</span> <span class="nav-text">Scala中下划线_的含义：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#scala函数式编程"><span class="nav-number">5.</span> <span class="nav-text">Scala函数式编程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#scala异常"><span class="nav-number">6.</span> <span class="nav-text">Scala异常</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#scala面向对象"><span class="nav-number">7.</span> <span class="nav-text">Scala面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#封装继承和多态的回顾"><span class="nav-number">7.1.</span> <span class="nav-text">封装、继承和多态的回顾</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#封装encapsulation"><span class="nav-number">7.1.1.</span> <span class="nav-text">封装Encapsulation</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#封装的好处"><span class="nav-number">7.1.1.1.</span> <span class="nav-text">封装的好处</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#封装的步骤"><span class="nav-number">7.1.1.2.</span> <span class="nav-text">封装的步骤</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#继承"><span class="nav-number">7.1.2.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#继承的好处"><span class="nav-number">7.1.2.1.</span> <span class="nav-text">继承的好处</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#scala中的抽象类"><span class="nav-number">7.2.</span> <span class="nav-text">Scala中的抽象类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#scala类构造器"><span class="nav-number">7.3.</span> <span class="nav-text">Scala类构造器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#伴生类与伴生对象"><span class="nav-number">7.4.</span> <span class="nav-text">伴生类与伴生对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#apply方法"><span class="nav-number">7.4.1.</span> <span class="nav-text">apply方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#scala包"><span class="nav-number">7.5.</span> <span class="nav-text">Scala包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#回顾java包"><span class="nav-number">7.5.1.</span> <span class="nav-text">回顾：Java包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#scala中包的可见性和访问修饰符的使用"><span class="nav-number">7.5.2.</span> <span class="nav-text">Scala中包的可见性和访问修饰符的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#scala包的作用"><span class="nav-number">7.5.3.</span> <span class="nav-text">Scala包的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#scala包的使用"><span class="nav-number">7.5.4.</span> <span class="nav-text">Scala包的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#包对象"><span class="nav-number">7.5.5.</span> <span class="nav-text">包对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#scala中类型检查和转换"><span class="nav-number">7.6.</span> <span class="nav-text">Scala中类型检查和转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#特质trait"><span class="nav-number">7.7.</span> <span class="nav-text">特质trait</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#动态混入"><span class="nav-number">7.7.1.</span> <span class="nav-text">动态混入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#叠加特质"><span class="nav-number">7.7.2.</span> <span class="nav-text">叠加特质</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#混入时叠加"><span class="nav-number">7.7.2.1.</span> <span class="nav-text">混入时叠加</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#abstract-override"><span class="nav-number">7.7.2.2.</span> <span class="nav-text">abstract override</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特质构造流程"><span class="nav-number">7.7.3.</span> <span class="nav-text">特质构造流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特质从类继承"><span class="nav-number">7.7.4.</span> <span class="nav-text">特质从类继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自身类型"><span class="nav-number">7.7.5.</span> <span class="nav-text">自身类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内部类"><span class="nav-number">7.8.</span> <span class="nav-text">内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内部类访问外部类的属性"><span class="nav-number">7.8.1.</span> <span class="nav-text">内部类访问外部类的属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#方法1外部类名.this.属性名"><span class="nav-number">7.8.1.1.</span> <span class="nav-text">方法1：外部类名.this.属性名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法2为外部类创建别名"><span class="nav-number">7.8.1.2.</span> <span class="nav-text">方法2：为外部类创建别名</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型投影"><span class="nav-number">7.8.2.</span> <span class="nav-text">类型投影</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作符重载"><span class="nav-number">7.9.</span> <span class="nav-text">操作符重载</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#隐式转换和隐式值"><span class="nav-number">8.</span> <span class="nav-text">隐式转换和隐式值</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#隐式转换函数"><span class="nav-number">8.1.</span> <span class="nav-text">隐式转换函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#利用隐式函数的功能丰富类库"><span class="nav-number">8.1.1.</span> <span class="nav-text">利用隐式函数的功能丰富类库</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#隐式值"><span class="nav-number">8.2.</span> <span class="nav-text">隐式值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#隐式类"><span class="nav-number">8.3.</span> <span class="nav-text">隐式类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#隐式转换机制总结"><span class="nav-number">8.4.</span> <span class="nav-text">隐式转换机制总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#模式匹配"><span class="nav-number">9.</span> <span class="nav-text">模式匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#match模式匹配"><span class="nav-number">9.1.</span> <span class="nav-text">match模式匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#match中的变量"><span class="nav-number">9.1.1.</span> <span class="nav-text">match中的变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#match返回值"><span class="nav-number">9.1.2.</span> <span class="nav-text">match返回值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#match匹配"><span class="nav-number">9.1.3.</span> <span class="nav-text">match匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#match类型匹配"><span class="nav-number">9.1.3.1.</span> <span class="nav-text">match类型匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#match数组匹配"><span class="nav-number">9.1.3.2.</span> <span class="nav-text">match数组匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#match列表匹配"><span class="nav-number">9.1.3.3.</span> <span class="nav-text">match列表匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#match元组匹配"><span class="nav-number">9.1.3.4.</span> <span class="nav-text">match元组匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#match对象匹配"><span class="nav-number">9.1.3.5.</span> <span class="nav-text">match对象匹配</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变量声明中的模式"><span class="nav-number">9.2.</span> <span class="nav-text">变量声明中的模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#for表达式中的模式"><span class="nav-number">9.3.</span> <span class="nav-text">for表达式中的模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#样例类case-class"><span class="nav-number">9.4.</span> <span class="nav-text">样例类case class</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#样例类的用途"><span class="nav-number">9.4.1.</span> <span class="nav-text">样例类的用途</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#密封类"><span class="nav-number">9.4.2.</span> <span class="nav-text">密封类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类型约束"><span class="nav-number">10.</span> <span class="nav-text">类型约束</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#范型"><span class="nav-number">10.1.</span> <span class="nav-text">范型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#上界upper-bounds和下界lower-bounds"><span class="nav-number">10.2.</span> <span class="nav-text">上界(Upper Bounds)和下界(Lower bounds)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#上界"><span class="nav-number">10.2.1.</span> <span class="nav-text">上界</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#下界"><span class="nav-number">10.2.2.</span> <span class="nav-text">下界</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#视图界定view-bounds"><span class="nav-number">10.3.</span> <span class="nav-text">视图界定(View bounds)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#上下文界定context-bounds"><span class="nav-number">10.4.</span> <span class="nav-text">上下文界定(Context bounds)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#协变covariant逆变contravariant和不变invariant"><span class="nav-number">10.5.</span> <span class="nav-text">协变covariant、逆变contravariant和不变invariant</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="嘴强黑铁"
      src="/images/touxiang.jpg">
  <p class="site-author-name" itemprop="name">嘴强黑铁</p>
  <div class="site-description" itemprop="description">一顿操作猛如虎</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">77</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">77</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">嘴强黑铁</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.2
  </div>
  <div class="addthis_inline_share_toolbox">
    <script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e731fa9610694ef" async="async"></script>
  </div>

        
<div class="busuanzi-count">
  <script pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.getAttribute('pjax') !== null) {
      script.setAttribute('pjax', '');
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  



  <script pjax>
  if (CONFIG.page.isPost) {
    wpac_init = window.wpac_init || [];
    wpac_init.push({
      widget: 'Rating',
      id    : 24025,
      el    : 'wpac-rating',
      color : 'fc6423'
    });
    (function() {
      if ('WIDGETPACK_LOADED' in window) return;
      WIDGETPACK_LOADED = true;
      var mc = document.createElement('script');
      mc.type = 'text/javascript';
      mc.async = true;
      mc.src = '//embed.widgetpack.com/widget.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
    })();
  }
  </script>

  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://zuiqiangiron.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "https://www.zuiqiangiron.xyz/2020/03/28/Scala%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/";
    this.page.identifier = "2020/03/28/Scala基础学习/";
    this.page.title = "Scala学习";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://zuiqiangiron.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

    </div>
</body>
</html>
