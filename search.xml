<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LeetCode刷题记之《1266. 访问所有点的最小时间》</title>
    <url>/2020/03/11/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8B%E3%80%8A1266.%20%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E6%97%B6%E9%97%B4%E3%80%8B/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode刷题记。</p>
<p><a href="https://leetcode-cn.com/problems/minimum-time-visiting-all-points/" target="_blank" rel="noopener">1266. 访问所有点的最小时间</a></p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述">题目描述</h1>
<p>平面上有 <code>n</code> 个点，点的位置用整数坐标表示<code>points[i] = [xi, yi]</code>。请你计算访问所有这些点需要的最小时间（以秒为单位）。</p>
<p>你可以按照下面的规则在平面上移动：</p>
<p>每一秒沿水平或者竖直方向移动一个单位长度，或者跨过对角线（可以看作在一秒内向水平和竖直方向各移动一个单位长度）。 必须按照数组中出现的顺序来访问这些点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2019/11/14/1626_example_1.PNG" /></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：points &#x3D; [[1,1],[3,4],[-1,0]]</span><br><span class="line">输出：7</span><br><span class="line">解释：一条最佳的访问路径是： [1,1] -&gt; [2,2] -&gt; [3,3] -&gt; [3,4] -&gt; [2,3] -&gt; [1,2] -&gt; [0,1] -&gt; [-1,0]   </span><br><span class="line">从 [1,1] 到 [3,4] 需要 3 秒 </span><br><span class="line">从 [3,4] 到 [-1,0] 需要 4 秒</span><br><span class="line">一共需要 7 秒</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：points &#x3D; [[3,2],[-2,2]]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">points.length &#x3D;&#x3D; n</span><br><span class="line">1 &lt;&#x3D; n &lt;&#x3D; 100</span><br><span class="line">points[i].length &#x3D;&#x3D; 2</span><br><span class="line">-1000 &lt;&#x3D; points[i][0], points[i][1] &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure>
<h1 id="解题思路">解题思路</h1>
<p>切比雪夫距离问题，两点之间的最小花费其实就是<code>max(|x0 - x1|, |y0 - y1|)</code></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeSumBST2</span><span class="params">(TreeNode root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; points.length; ++i) &#123;</span><br><span class="line">            times += Math.max(Math.abs(points[i][<span class="number">0</span>] - points[i - <span class="number">1</span>][<span class="number">0</span>]), Math.abs(points[i][<span class="number">1</span>] - points[i - <span class="number">1</span>][<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> times;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>切比雪夫距离</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题记之《938. 二叉搜索树的范围和》</title>
    <url>/2020/03/11/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8B%E3%80%8A938.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8C%83%E5%9B%B4%E5%92%8C%E3%80%8B/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode刷题记。</p>
<p><a href="https://leetcode-cn.com/problems/range-sum-of-bst/" target="_blank" rel="noopener">938. 二叉搜索树的范围和</a></p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述">题目描述</h1>
<p>给定二叉搜索树的根结点 root，返回 L 和 R（含）之间的所有结点的值的和。</p>
<p>二叉搜索树保证具有唯一的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：root &#x3D; [10,5,15,3,7,null,18], L &#x3D; 7, R &#x3D; 15</span><br><span class="line">输出：32</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：root &#x3D; [10,5,15,3,7,13,18,1,null,6], L &#x3D; 6, R &#x3D; 10</span><br><span class="line">输出：23</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">树中的结点数量最多为 10000 个。</span><br><span class="line">最终的答案保证小于 2^31。</span><br></pre></td></tr></table></figure>
<h1 id="解题思路">解题思路</h1>
<h2 id="方法1低效">方法1（低效）</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeSumBST2</span><span class="params">(TreeNode root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root.val &lt;= R &amp;&amp; root.val &gt;= L)&#123;</span><br><span class="line">            sum += root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        sum += rangeSumBST(root.left, L, R);</span><br><span class="line">        sum += rangeSumBST(root.right, L, R);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该思路比较了二叉搜索树中的每一个节点，显然没有利用到二叉搜索树最重要的特性：左边的节点均比右边的要小（或者相反），代码改进如下。</p>
<h2 id="方法2">方法2</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeSumBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; L)&#123;</span><br><span class="line">            <span class="keyword">return</span> rangeSumBST(root.right, L, R);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; R)&#123;</span><br><span class="line">            <span class="keyword">return</span> rangeSumBST(root.left, L, R);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root.val + rangeSumBST(root.left, L, R) + rangeSumBST(root.right, L, R);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题记之《1313. 解压缩编码列表》</title>
    <url>/2020/03/09/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8B%E3%80%8A1313.%20%E8%A7%A3%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81%E5%88%97%E8%A1%A8%E3%80%8B/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode刷题记。</p>
<p><a href="https://leetcode-cn.com/problems/decompress-run-length-encoded-list" target="_blank" rel="noopener">1313. 解压缩编码列表</a></p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述">题目描述</h1>
<p>给你一个以行程长度编码压缩的整数列表 <code>nums</code> 。</p>
<p>考虑每对相邻的两个元素 <code>freq, val] = [nums[2*i], nums[2*i+1]] （其中 i &gt;= 0 ）</code>，每一对都表示解压后子列表中有 <code>freq</code> 个值为 <code>val</code> 的元素，你需要从左到右连接所有子列表以生成解压后的列表。</p>
<p>请你返回解压后的列表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入：nums &#x3D; [1,2,3,4]</span><br><span class="line">输出：[2,4,4,4]</span><br><span class="line">解释：第一对 [1,2] 代表着 2 的出现频次为 1，所以生成数组 [2]。</span><br><span class="line">第二对 [3,4] 代表着 4 的出现频次为 3，所以生成数组 [4,4,4]。</span><br><span class="line">最后将它们串联到一起 [2] + [4,4,4] &#x3D; [2,4,4,4]。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [1,1,2,3]</span><br><span class="line">输出：[1,3,3]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">2 &lt;&#x3D; nums.length &lt;&#x3D; 100</span><br><span class="line">nums.length % 2 &#x3D;&#x3D; 0</span><br><span class="line">1 &lt;&#x3D; nums[i] &lt;&#x3D; 100</span><br></pre></td></tr></table></figure>
<h1 id="解题思路">解题思路</h1>
<p>三个思路：</p>
<ol type="1">
<li>使用<code>ArrayList&lt;Integer&gt;</code>，然后再根据<code>ArrayList</code>创建<code>int[]</code>；</li>
<li>由于这道题的数据量不大，直接创建一个大数组<code>int[5000]</code>，然后用<code>Arrays.copyOfRange()</code>截取这个大数组;</li>
<li>先遍历一遍输入数组，确定结果数组长度，然后用<code>Arrays.fill()</code>填充这个结果数组。</li>
</ol>
<p>前两个算法都比较简单，这里只写第三个解法。</p>
<p>以下是Java版代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] decompressRLElist(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">            len += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] rst = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, idx = <span class="number">0</span>; i &lt; nums.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">            Arrays.fill(rst, idx, idx = idx + nums[i], nums[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是Python版代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decompressRLElist</span><span class="params">(nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    <span class="keyword">return</span> [nums[<span class="number">2</span> * i + <span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(int(len(nums) / <span class="number">2</span>)) <span class="keyword">for</span> j <span class="keyword">in</span> range(nums[<span class="number">2</span> * i])]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>Python</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题记之《1365. 有多少小于当前数字的数字》</title>
    <url>/2020/03/08/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8B%E3%80%8A1365.%20%E6%9C%89%E5%A4%9A%E5%B0%91%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E5%AD%97%E3%80%8B/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode刷题记。</p>
<p><a href="https://leetcode-cn.com/problems/how-many-numbers-are-smaller-than-the-current-number" target="_blank" rel="noopener">1365.有多少小于当前数字的数字</a></p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述">题目描述</h1>
<p>给你一个数组 <code>nums</code>，对于其中每个元素 <code>nums[i]</code>，请你统计数组中比它小的所有数字的数目。</p>
<p>换而言之，对于每个 <code>nums[i]</code> 你必须计算出有效的<code>j</code>的数量，其中<code>j</code>满足 <code>j != i 且 nums[j] &lt; nums[i]</code> 。</p>
<p>以数组形式返回答案。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums &#x3D; [8,1,2,2,3]</span><br><span class="line">输出：[4,0,1,1,3]</span><br><span class="line">解释： </span><br><span class="line">对于 nums[0]&#x3D;8 存在四个比它小的数字：（1，2，2 和 3）。 </span><br><span class="line">对于 nums[1]&#x3D;1 不存在比它小的数字。</span><br><span class="line">对于 nums[2]&#x3D;2 存在一个比它小的数字：（1）。 </span><br><span class="line">对于 nums[3]&#x3D;2 存在一个比它小的数字：（1）。 </span><br><span class="line">对于 nums[4]&#x3D;3 存在三个比它小的数字：（1，2 和 2）。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums &#x3D; [6,5,4,8]</span><br><span class="line">输出：[2,1,0,3]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums &#x3D; [7,7,7,7]</span><br><span class="line">输出：[0,0,0,0]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">2 &lt;&#x3D; nums.length &lt;&#x3D; 500</span><br><span class="line">0 &lt;&#x3D; nums[i] &lt;&#x3D; 100</span><br></pre></td></tr></table></figure>
<h1 id="解题思路">解题思路</h1>
<p>三个思路：</p>
<ol type="1">
<li>暴力破解（以及暴力破解的改进型，比较次数不变），循环两遍；</li>
<li>定义一排桶，只循环一遍;</li>
<li>排序</li>
</ol>
<h2 id="方法1暴力破解">方法1：暴力破解</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 暴力破解，循环两遍</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] smallerNumbersThanCurrent1(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> numsLength = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[numsLength];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsLength; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; numsLength; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    ++counts[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> counts;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 改进型的暴力破解，内层循环次数减少，但总的比较次数依然不变</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] smallerNumbersThanCurrent2(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> numsLength = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[numsLength];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsLength - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; numsLength; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    ++counts[i];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; nums[j]) &#123;</span><br><span class="line">                    ++counts[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> counts;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O\left(n^{2}\right), n=nums.length\)</span></p>
<p>空间复杂度：<span class="math inline">\(O(1)\)</span></p>
<h2 id="方法2桶排序">方法2：桶排序</h2>
<p>该方法是一个常用的方法，它根据<code>nums[i]</code>的取值范围定义一个空数组，然后求前缀和：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] smallerNumbersThanCurrent(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">101</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            ++buckets[num];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">101</span>; ++i) &#123;</span><br><span class="line">            buckets[i] += buckets[i - <span class="number">1</span>];	<span class="comment">// 求前缀和</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] rst = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != <span class="number">0</span>)</span><br><span class="line">                rst[i] = buckets[nums[i] - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是Python版的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smallerNumbersThanCurrent</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        buckets = [<span class="number">0</span>] * <span class="number">101</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            buckets[num] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">101</span>):</span><br><span class="line">            buckets[i] += buckets[i - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        rst = [<span class="number">0</span>] * len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i]:</span><br><span class="line">                rst[i] = buckets[nums[i] - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rst</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O(S+n),S=num[i]的值域,n=nums.length\)</span></p>
<p>空间复杂度：<span class="math inline">\(O(S)\)</span></p>
<h2 id="方法3排序">方法3：排序</h2>
<p>将数组整个排序后，在<code>nums[i]</code>前面的且不同于<code>nums[i]</code>的数字就是所有比<code>nums[i]</code>小的数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] smallerNumbersThanCurrent(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] sorted = Arrays.copyOf(nums, n);</span><br><span class="line">        Arrays.sort(sorted);</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer, Integer&gt; countMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        countMap.put(sorted[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, count = <span class="number">1</span>, pre = sorted[<span class="number">0</span>]; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sorted[i] != pre) &#123;</span><br><span class="line">                countMap.put(sorted[i], count);</span><br><span class="line">                pre = sorted[i];</span><br><span class="line">            &#125;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] rst = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            rst[i] = countMap.get(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是Python的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smallerNumbersThanCurrent</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        temp = sorted(nums)</span><br><span class="line"></span><br><span class="line">        count_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> temp[i] <span class="keyword">not</span> <span class="keyword">in</span> count_dict:</span><br><span class="line">                count_dict[temp[i]] = i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [count_dict[nums[i]] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</span><br></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O(n \log (n)),n=nums.length\)</span></p>
<p>空间复杂度：<span class="math inline">\(O(n)\)</span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路42-数据结构和算法</title>
    <url>/2018/06/28/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF42-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>《Python Cookbook》笔记。</p>
<p>本篇主要讨论Python中一些常用的数据结构和算法。</p>
<p>未完待续。</p>
</blockquote>
<a id="more"></a>
<h1 id="保留最后n个元素">1. 保留最后N个元素</h1>
<p><code>collections.deque</code>可以设置队列的长度，用于保存最后加入的N个元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q = deque(maxlen=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.extend([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q</span><br><span class="line">deque([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], maxlen=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q</span><br><span class="line">deque([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], maxlen=<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>有时我们希望在处理数据时(比如文本匹配)能记录最后访问到的几项数据，此时使用<code>collections.deque</code>就会非常方便。</p>
<h1 id="找到最大或最小的n个元素">2. 找到最大或最小的N个元素</h1>
<p>使用<code>heapq</code>模块中的<code>nlargest()</code>和<code>nsmallest()</code>函数可以轻松实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> heapq</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nums = [<span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">23</span>, <span class="number">7</span>, <span class="number">-4</span>, <span class="number">18</span>, <span class="number">23</span>, <span class="number">42</span>, <span class="number">37</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heapq.nlargest(<span class="number">3</span>, nums)</span><br><span class="line">[<span class="number">42</span>, <span class="number">37</span>, <span class="number">23</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heapq.nsmallest(<span class="number">3</span>, nums)</span><br><span class="line">[<span class="number">-4</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p>和<code>sorted()</code>函数一样，这两个函数也接收一个<code>key</code>参数，用于在排序时比较元素。</p>
<p>从这个模块名可以看出，这个模块中的函数必定和堆(Heap)有关，但<code>nlargest()</code>和<code>nsmallest()</code>在排序元素时并不一定建堆，它会根据实际情况选择排序方法：比如，要是N和集合本身大小差不多，它就会选择例如快排之类的排序方法，然后切片，而不是建堆。</p>
<p>这两个函数一般用于N比较小的情况：</p>
<ul>
<li>当N=1时，建议大家使用<code>max()</code>和<code>min()</code>函数；</li>
<li>当N接近集合大小时，建议大家直接使用<code>sorted()</code>函数，然后切片；</li>
<li>当N在上述两个情况之间时，则是用到<code>nlargest()</code>和<code>nsmallest()</code>的时候。</li>
</ul>
<p>还有一种情况，如果想依次获取集合中最小的元素，可以先建堆，再弹出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> heapq</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heap = [<span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">23</span>, <span class="number">7</span>, <span class="number">-4</span>, <span class="number">18</span>, <span class="number">23</span>, <span class="number">42</span>, <span class="number">37</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heapq.heapify(heap)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heap</span><br><span class="line">[<span class="number">-4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">23</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">18</span>, <span class="number">23</span>, <span class="number">42</span>, <span class="number">37</span>, <span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heapq.heappop(heap)</span><br><span class="line"><span class="number">-4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>heapq.heappop(heap)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>不过，在使用<code>heapq.heappop()</code>之前，请先建堆<code>heapq.heapify()</code>，否则得到的不一定是你想要的结果。</p>
<p><strong><code>heapq.heapify()</code>建立的是小顶堆，<code>heapq.heappop()</code>的时间复杂度是<code>O(logN)</code>级。</strong></p>
<h1 id="优先级队列">3. 优先级队列</h1>
<p>其实<code>queue.py</code>模块中自带了一个<code>PriorityQueue</code>类，它的内部实现其实也是使用的<code>collections.queue</code>和<code>heapq</code>。这里我们手动使用<code>heapq</code>模块来实现一个简单的优先级队列，用于展示其中的某些技巧。这个优先级队列每次<code>pop</code>操作时，都弹出优先级最高的那个元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._queue = []</span><br><span class="line">        self._index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, item, priority)</span>:</span></span><br><span class="line">        heapq.heappush(self._queue, (-priority, self._index, item))  <span class="comment"># 优先级是取负！</span></span><br><span class="line">        self._index += <span class="number">1</span>    <span class="comment"># 保证同优先级时按录入的顺序输出</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> heapq.heappop(self._queue)[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> my_prique <span class="keyword">import</span> PriorityQueue</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Item</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.name = name</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">"Item(&#123;!r&#125;)"</span>.format(self.name)</span><br><span class="line"><span class="meta">... </span>   </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q = PriorityQueue()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.push(Item(<span class="string">"foo"</span>), <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.push(Item(<span class="string">"bar"</span>), <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.push(Item(<span class="string">"grok"</span>), <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.pop()</span><br><span class="line">Item(<span class="string">'bar'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.pop()</span><br><span class="line">Item(<span class="string">'foo'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q.pop()</span><br><span class="line">Item(<span class="string">'grok'</span>)</span><br></pre></td></tr></table></figure>
<p>这里其实利用到了3个点：</p>
<ul>
<li>在比较元素顺序时，利用了元组比较的规则：两个元组进行比较时，先比较第一个元素，第一个元素相等再比较下一个元素，以此类推；</li>
<li>由于<code>heapq.heapify()</code>建立的是小顶堆，每次<code>pop</code>操作返回的都是最小值，而我们要求返回最大值，所以将优先级进行了取负，这是一个常用的技巧；</li>
<li>为了实现"同优先时级先录入的先输出"，这里维护了一个<code>self._index</code>计数器，用于指示录取的顺序。它相当于一个第二优先级。</li>
</ul>
<p><code>heapq.heappush()</code>的时间复杂度也是<code>O(logN)</code>级。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python进阶</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Python</tag>
        <tag>Python进阶</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路41-元类</title>
    <url>/2018/06/26/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF41-%E5%85%83%E7%B1%BB/</url>
    <content><![CDATA[<blockquote>
<p>《流畅的Python》笔记。</p>
<p>本篇主要讨论Python中的元类。Python中所有的类都直接或间接地是元类type的实例。阅读本篇时，请时刻注意你所阅读的内容指的是<strong>"实例"(或者说"对象")</strong>、<strong>"类"</strong>还是<strong>"元类"</strong>，否则很容易被绕晕。</p>
</blockquote>
<a id="more"></a>
<h1 id="前言">1. 前言</h1>
<p>Python中，几乎所有的东西都是对象。<strong>不光类的实例是对象，连类本身也是对象</strong>。</p>
<p>不像C++、Java等静态语言，在编译前就必须将类定义好，运行时不能再创建新类，Python则可以在运行时动态创建新类，且不通过关键字<code>class</code>。<strong>创建类的类叫做元类</strong>。<strong>元类</strong>也是类，它可以派生出<strong>新的元类</strong>，但<strong>所有元类</strong>最顶层的超类只有一个，就是我们经常用到的<code>type</code>。Python中所有的类都直接或间接地是<code>type</code>的<strong>实例</strong>。</p>
<p>在运行时能通过元类动态创建类是Python的魅力，但想要理解这个"魅力"确并不是那么容易。本篇内容主要有：元类的简单示例，类装饰器，元类的原理、定义及使用方式，最后使用元类来弥补<a href="http://www.vpointer.net/articles/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF40-%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6/" target="_blank" rel="noopener">上一篇</a>中描述符的不足。</p>
<p>本篇只能算是对元类的初步介绍，更深层次的内容还需进一步学习。</p>
<h1 id="初识元类">2. 初识元类</h1>
<p>通常，如果要创建对象，需要先在某个模块中用<code>class</code>关键字定义好类，再在业务代码中创建这个类的实例。与这种事先定义的方式相反，可以通过<code>type</code>在运行时创建类，以下是它的示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">"this is a string"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(a)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt;</span></span><br><span class="line">&gt;&gt;&gt; MyClass = type("MyClass", (object,), &#123;"x": 1, "x2": lambda self: self.x * 2&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mc = MyClass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mc.x</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mc.x2()</span><br><span class="line"><span class="number">2</span>                      <span class="comment"># 请留意下方这三个特殊属性</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mc.__class__       <span class="comment"># __class__的值是实例所属的类</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">MyClass</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">MyClass</span>.<span class="title">__bases__</span>  # <span class="title">__bases__</span>的值是类的所有直接超类</span></span><br><span class="line"><span class="class"><span class="params">(&lt;class <span class="string">'object'</span>&gt;,)</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">MyClass</span>.<span class="title">__mro__</span>    # <span class="title">__mro__</span>的值是类的所有超类</span></span><br><span class="line"><span class="class"><span class="params">(&lt;class <span class="string">'MyClass'</span>&gt;, &lt;class <span class="string">'object'</span>&gt;)</span> </span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">MyClass</span>.<span class="title">__class__</span>  # 这表明<span class="title">MyClass</span>这个类是<span class="title">type</span>的对象</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">type</span>'&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述<code>MyClass</code>的定义等同于如下定义：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">x2</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.x * <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><code>type</code>通常被当做函数使用，但它其实是一个类。当只传入一个实例时，它返回实例的类型；当传入3个参数时，它生成并返回一个类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">type(cls_name, bases, attr_dict)</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>cls_name</code>是要创建的类的名称的字符串；</li>
<li><code>bases</code>是一个元组，它存储即将创建的类的直接父类们，比如<code>MyClass</code>继承自<code>object</code>(如果只继承自<code>object</code>，可以将<code>bases</code>设置为空元组)；</li>
<li><code>attr_dict</code>是新类的属性字典。不光包括数据属性，还包括了方法(含特殊方法)。不过，如果是数据属性，这些数据属性将成为<strong>类属性</strong>，而<strong>不是</strong>实例属性。如果想创建实例属性，请在<code>attr_dict</code>中传入<code>__init__</code>的定义，或者传入<code>__dict__</code>。</li>
</ul>
<p>为了更详细的介绍<code>type</code>的用法，我们用它来构造一个类工厂函数。</p>
<h1 id="类工厂函数">3. 类工厂函数</h1>
<p>对于数据结构固定的数据，如果想将其包装成类对象，传统的做法是使用<code>class</code>定义每个类，比如为宠物应用定义各种动物类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, weight, owner)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.owner = owner</span><br></pre></td></tr></table></figure>
<p>不知道各位在敲这段代码时有没有抱怨：<code>name</code>，<code>weight</code>，<code>owner</code>敲了三遍！如果再多几种动物类，这种样板代码得写多少？当然，对于相关的类可以选择继承。但如果数据间不相关呢？难道定义每个类的时候都将这种样板代码敲一遍？这个时候就可以用<strong>类工厂函数</strong>来减少这种样板代码。下方代码展示了<code>type</code>更具体的用法，生成的类比较简单，适合用于处理格式固定的数据。这个工厂函数其实是在模仿<code>collections.namedtuple</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">record_factory</span><span class="params">(cls_name, field_name)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:   <span class="comment"># 假设传入的field_name是字符串，获取属性名</span></span><br><span class="line">        field_names = field_name.replace(<span class="string">","</span>, <span class="string">" "</span>).split()</span><br><span class="line">    <span class="keyword">except</span> AttributeError:</span><br><span class="line">        <span class="keyword">pass</span>  <span class="comment"># 如果不是字符串，则当做可迭代对象处理</span></span><br><span class="line">    field_names = tuple(field_names)   <span class="comment"># 将属性名存到元组中</span></span><br><span class="line">    <span class="comment"># __init__不作用于这个工厂函数！这是为要创建的类定义的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span>        </span><br><span class="line">        attrs = dict(zip(self.__slots__, args))</span><br><span class="line">        attrs.update(kwargs)</span><br><span class="line">        <span class="keyword">for</span> name, value <span class="keyword">in</span> attrs.items():</span><br><span class="line">            setattr(self, name, value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span>   <span class="comment"># 让即将创建的类可迭代</span></span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> self.__slots__:</span><br><span class="line">            <span class="keyword">yield</span> getattr(self, name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span>   <span class="comment"># 格式化输出</span></span><br><span class="line">        values = <span class="string">", "</span>.join(<span class="string">"&#123;&#125;=&#123;!r&#125;"</span>.format(*i) <span class="keyword">for</span> i <span class="keyword">in</span> zip(self.__slots__, self))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;&#125;(&#123;&#125;)"</span>.format(self.__class__.__name__, values)</span><br><span class="line">    <span class="comment"># 类将拥有的属性</span></span><br><span class="line">    cls_attrs = dict(__slots__=field_names, __init__=__init__,</span><br><span class="line">                     __iter__=__iter__, __repr__=__repr__)</span><br><span class="line">    <span class="keyword">return</span> type(cls_name, (), cls_attrs)   <span class="comment"># 继承自object</span></span><br></pre></td></tr></table></figure>
<p>下面是这个类工厂函数的用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Dog = record_factory(<span class="string">"Dog"</span>, <span class="string">"name weight owner"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dog = Dog(<span class="string">"test"</span>, <span class="number">5</span>, <span class="string">"Kevin"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dog</span><br><span class="line">Dog(name=<span class="string">'test'</span>, weight=<span class="number">5</span>, owner=<span class="string">'Kevin'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dog.weight = <span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dog</span><br><span class="line">Dog(name=<span class="string">'test'</span>, weight=<span class="number">6</span>, owner=<span class="string">'Kevin'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name, weight, owner = dog</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name, weight, owner</span><br><span class="line">(<span class="string">'test'</span>, <span class="number">6</span>, <span class="string">'Kevin'</span>)</span><br></pre></td></tr></table></figure>
<p>下面我们将进一步了解元类。</p>
<h1 id="元类">4. 元类</h1>
<p>面向对象的思想有两大关系：类的继承和类的实例化。在Python中，<code>type</code>和<code>object</code>就像两个紧密合作的管理员，<code>type</code>主管实例化，<code>object</code>主管继承。</p>
<p>我们都知道，Python中所有的类都是从<code>object</code>继承而来的。但如果你看过下方的代码后，不知道对这一点的理解会不会动摇：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>type.__bases__</span><br><span class="line">(&lt;class 'object'&gt;,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type.__class__</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">type</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">object</span>.<span class="title">__bases__</span></span></span><br><span class="line"><span class="class"><span class="params">()</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">object</span>.<span class="title">__class__</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">type</span>'&gt;</span></span><br></pre></td></tr></table></figure>
<p>这段代码翻译成中文就是：<code>object</code>是<code>type</code>的实例，<code>type</code>是<code>object</code>的子类，因此<code>type</code>也是<code>type</code>自身的实例。这里完美地扯出了一个"先有蛋还是先有鸡"的问题：既然<code>object</code>是<code>type</code>的实例，那就得先由<code>type</code>创建<code>object</code>；但<code>type</code>又是<code>object</code>的子类，也就是得先有<code>object</code>，再有<code>type</code>，所以到底是谁先有？</p>
<p>这个关系直到现在我也没搞清楚。如果是现实世界，可以说人类暂时还没搞清楚是先有鸡还是先有蛋，但Python这种编程语言可是人造的东西，况且底层还是C语言，所以我肯定不信什么"互为祖先，同时产生"这种说法，而且这在代码里不是死循环吗？查了很多资料，基本都是引用的这张图，其中虚线表示实例关系，实线表示继承关系：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1529920648/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF41-%E5%85%83%E7%B1%BB/type_object.jpg" /></p>
<p>但大家都回避了前面那个问题：<code>object</code>从<code>type</code>实例化而来，可<code>type</code>又从<code>object</code>派生而来，到底谁先存在？</p>
<p>只能去看源码。源码中<code>type</code>确实继承自<code>object</code>，但<code>object</code>的定义中并没有<code>metaclass</code>关键字出现(后面会讲到，如果以<code>class</code>的形式从元类实例化类，需要使用这个关键字)；并且，<code>object</code>中有这么一个定义：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__class__ = <span class="literal">None</span> <span class="comment"># (!) forward: type, real value is ''</span></span><br></pre></td></tr></table></figure>
<p>这就让疑惑更深了：<code>object</code>究竟是不是<code>type</code>的实例？<code>type</code>中有如下定义：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__bases__ = (</span><br><span class="line">    object,</span><br><span class="line">)</span><br><span class="line">__base__ = object</span><br><span class="line">__mro__ = (</span><br><span class="line">    <span class="literal">None</span>, <span class="comment"># (!) forward: type, real value is ''</span></span><br><span class="line">    object,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>更深层的源代码暂时还啃不动。官方<a href="https://docs.python.org/3/reference/datamodel.html#metaclasses" target="_blank" rel="noopener">说明文档</a>中说明了类的构建过程：所有的类，不管指没指明元类，都会经由<code>type()</code>，产生实际使用的类，这也验证了所有的类都是<code>type</code>的实例这一说法。</p>
<p>这两者的具体关系还有待继续研究。但我们毕竟不是语言专家，我们更看重的是元类怎么使用。对于这些概念，我们只需要知道：</p>
<ul>
<li>元类<code>type</code>可以创建类；</li>
<li>所有的类都直接或间接的是<code>type</code>的实例；</li>
<li><code>type</code>是自身的实例；</li>
<li><code>type</code>可以被继承，用于创建新的元类。</li>
</ul>
<h2 id="类装饰器">4.1 类装饰器</h2>
<p>在继续元类之前，我们先来解决<a href="http://www.vpointer.net/articles/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF40-%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6/" target="_blank" rel="noopener">上一篇</a>属性描述符没有解决的问题：储存属性需要手动指定，而自动生成的名称所表达的意思又不够明显：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Food.weight.storage_name</span><br><span class="line"><span class="string">'_Quantity#0'</span></span><br></pre></td></tr></table></figure>
<p>这是<a href="http://www.vpointer.net/articles/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF40-%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6/" target="_blank" rel="noopener">上一篇</a>文章中自动生成储存属性的名称时采用的策略，但我们更希望是下面这种形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Food.weight.storage_name</span><br><span class="line"><span class="string">'_Quantity#weight'</span></span><br></pre></td></tr></table></figure>
<p>上一篇中也说过，描述符类很难获取托管类的类属性名称的。使用类装饰器则能解决这个问题。类装饰器和函数装饰器非常相似，是参数为类对象的函数，返回原来的类或修改后的类。这里我们将它装饰到<code>Food</code>类上，而不是<code>Quantity</code>类上(<code>Food</code>和<code>Quantity</code>的具体定义请查看<a href="http://www.vpointer.net/articles/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF40-%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6/" target="_blank" rel="noopener">上一篇</a>文章。以下代码不能直接运行，请自行导入所需的类)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@entity</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Food</span>:</span>   <span class="comment"># 这个类比上一篇有所省略</span></span><br><span class="line">    weight = Quantity()   <span class="comment"># 并没有传入储存属性的名称</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, weight)</span>:</span></span><br><span class="line">        self.weight = weight</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">entity</span><span class="params">(cls)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> key, attr <span class="keyword">in</span> cls.__dict__.items():</span><br><span class="line">        <span class="keyword">if</span> isinstance(attr, Validated):      <span class="comment"># 如果这个属性是Validated类的实例</span></span><br><span class="line">            type_name = type(attr).__name__  <span class="comment"># 则修改它的storage_name属性的值</span></span><br><span class="line">            attr.storage_name = <span class="string">"_&#123;&#125;#&#123;&#125;"</span>.format(type_name, key)</span><br><span class="line">    <span class="keyword">return</span> cls</span><br></pre></td></tr></table></figure>
<p>其实实现的思路很简单：<code>Quantity</code>之所以无法获取<code>Food</code>类的属性名，是因为在<code>Food</code>中生成<code>Quantity</code>实例时，<code>Food</code>这个类都还没有创建完毕，自然只能手动传入。那等<code>Food</code>类创建完毕了再设置值不就行了？与函数装饰器类似，类装饰器会在<code>Food</code>生成后立即运行。</p>
<p>也可以用类装饰器来替换掉类中的某些方法。但<strong>类装饰器有一个重大缺点：只能对直接依附的类有效</strong>。这意味着，被装饰类的子类不一定继承装饰器所做的修改，具体情况视改动的方式而定。</p>
<blockquote>
<p>小插曲：我看到这个概念的时候，无法理解为什么这被称之为"缺点"：继承的时候子类重写了父类的同名方法，这不再正常不过吗？难道是不准让子类重写这个方法，要让这个方法在整个继承体系中都保持唯一？那不重写不就完了吗？如果整个项目就一个人做，当然能保证不重写这个方法。但往往软件开发是个团队项目，其他人并不一定清楚这个方法能不能被重写。</p>
</blockquote>
<p>要保持方法在整个继承体系中保持唯一，不被子类所覆盖，这就得祭出元类。</p>
<h2 id="使用元类">4.2 使用元类</h2>
<p>当使用到元类的时候，其实就是在定制化类及其子类的行为。下面我们使用元类替换掉前面的类装饰器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Validated和Quantity都在上一篇文章中，以下代码不能直接运行！</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EntityMeta</span><span class="params">(type)</span>:</span>  <span class="comment"># 在元类中，通常将self换成cls</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(cls, name, bases, attr_dict)</span>:</span>  <span class="comment"># 逻辑和类装饰器是一样的</span></span><br><span class="line">        super().__init__(name, bases, attr_dict)<span class="comment"># 这一步将name,bases,attr_dict绑定到了cls上</span></span><br><span class="line">        <span class="keyword">for</span> key, attr <span class="keyword">in</span> attr_dict.items():</span><br><span class="line">            <span class="keyword">if</span> isinstance(attr, Validated):</span><br><span class="line">                type_name = type(attr).__name__</span><br><span class="line">                attr.storage_name = <span class="string">"_&#123;&#125;#&#123;&#125;"</span>.format(type_name, key)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span><span class="params">(metaclass=EntityMeta)</span>:</span></span><br><span class="line">    <span class="string">"""带有验证字段的业务实体"""</span>   <span class="comment"># 什么都不用做，除非像添加新方法</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Food</span><span class="params">(Entity)</span>:</span>    <span class="comment"># 对这个类进行了简化</span></span><br><span class="line">    weight = Quantity()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, weight)</span>:</span></span><br><span class="line">        self.weight = weight</span><br></pre></td></tr></table></figure>
<p>请注意区分这些类的关系：</p>
<ul>
<li><code>EntityMeta</code>是元类<code>type</code>的子类，所以它也是个元类。</li>
<li><code>Entity</code>使用<code>class</code>关键字来定义新的类，而不是调用<code>type()</code>函数来创建新的类；在定义<code>Entity</code>时，使用了<code>metaclass</code>关键字，表明这是元类<code>EntityMeta</code>的实例，而不是<code>EntityMeta</code>的子类，即，这不是继承关系。同时，<code>Entity</code>也(间接)是<code>type</code>的实例。</li>
<li><code>Food</code>是<code>Entity</code>的子类，也是元类<code>EntityMeta</code>和<code>type</code>的实例。</li>
</ul>
<p>列出这些关系，是想提醒大家，如果要自行定义元类，请时刻注意，究竟谁是谁的子类，谁是谁的实例。下面来运行一下这段代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Food.weight.storage_name</span><br><span class="line"><span class="string">'_Quantity#weight'</span>   <span class="comment"># 行为符合预期</span></span><br></pre></td></tr></table></figure>
<p>这里又产生了3个问题。</p>
<p>第1个问题是：从<code>EntityMeta</code>的<code>__init__</code>中可以看到，参数<code>cls</code>存的是元类的实例的引用，即类<code>Entity</code>或者类<code>Food</code>的引用，但整个初始化过程中，根本就没有用到<code>cls</code>，可结果表明，这些修改确实作用到了<code>Food</code>上，那么这是怎么作用<code>Food</code>上的呢？</p>
<p><code>EntityMeta.__init__()</code>这个方法中的语句并不多，简答分析就能知道，问题出在<code>super().__init__()</code>，即<code>type.__init__()</code>上。但这个方法的具体实现我暂时也不知道，只能给出我的猜想：我们都知道，对于普通的类(例如<code>Food</code>)来说，它的对象(例如<code>f</code>)保存在内存中的某个位置<code>a</code>上，<code>Food</code>的<code>__init__</code>操作内存<code>a</code>上的数据；而开篇就提到，所有的类也都是对象，于是类比一下，元类(例如<code>EntityMeta</code>)的实例(例如<code>Food</code>)肯定也存储在内存的某个位置<code>b</code>，那么<code>type.__init__</code>肯定将传入的参数关联到了内存<code>b</code>(实例<code>Food</code>)上。所以，这些操作最后在<code>Food</code>上生效了。平时对类的使用，其实就是用内存<code>b</code>中的数据创建内存<code>a</code>中的数据。</p>
<p>元类之所以难理解，难就难在我们并不习惯于"<strong>根据类来创建类</strong>"这种思路，我们习惯的是"<strong>根据类来创建实例</strong>"。这里也再次申明，<strong>没有"根据类来创建类"这种说法，一切都是"根据类来创建实例"</strong>！当涉及到元类时，就<strong>把元类看做平常使用的类，把元类生成的类看做平常使用的实例</strong>(或者说对象)。如果能这样想，下面两个问题也就能很好回答：</p>
<ul>
<li>两个<code>__init__</code>谁先运行呢？</li>
<li>前面说到，在元类中定义的方法能影响到整个继承体系，即使子类重写这个方法也没有用，那这是怎么做到的呢？</li>
</ul>
<p>要彻底回答这两个问题，就要涉及到<strong>运行时</strong>与<strong>导入时</strong>的概念。</p>
<h1 id="运行时导入时">5. 运行时&amp;导入时</h1>
<p>为了正确地做元编程，必须知道Python解释器在什么时候运行各个代码块。Python程序员区分<strong>运行时</strong>与<strong>导入时</strong>这两个概念，但其实这两个术语并没有严格定义，而且两者有交集。</p>
<p>在导入时，解释器会编译源文件，解释器会从上到下一次性解析完整个<code>.py</code>模块，然后生成用于执行的字节码，并将其存到<code>.pyc</code>文件中(这类文件在本地的<code>__pycache__</code>文件夹中)。所以，虽然Python是解释型语言，边解释边运行，但解释的不是<code>.py</code>源文件，而是<code>.pyc</code>中的字节码数据。</p>
<p>导入时除了编译，还会做些其他的事情。由于Python中的语句几乎都是可执行的，稍不注意，某些本该在运行时才运行的语句会在导入时就运行，导致用户程序的状态被修改。这里指的就是<code>import</code>语句：</p>
<ul>
<li>在Java中，<code>import</code>只用作声明，运行的时候才真正执行<code>import</code>后面的包中的代码。</li>
<li>在Python中，<code>import</code>不仅仅是声明。模块首次被导入时，模块中所有的代码都会被运行并缓存，以后再导入相同的模块时直接使用缓存(只做名称绑定)；所导入的模块中如果还有<code>import</code>，那么这些模块只要没被导入过，也会被运行一遍。这表明，<strong>运行时</strong>与<strong>导入时</strong>产生了交集。</li>
</ul>
<p>之前我在网上搜索这个概念的时候，很多博主都说，导入时会运行模块中所有的代码。其实并不是这样的，Python解释器确实会将模块从头执行到尾，但是：</p>
<ul>
<li><strong>对于函数</strong>，解释器只执行完<code>def</code>关键字所在的行，它会编译函数的定义体，把函数对象绑定到对应的全局名称上，但显然函数定义体不会被执行。只有到运行时，解释器才通过全局名称找到函数定义体，再执行它。</li>
<li><strong>对于类</strong>，情况就不一样了。导入时，解释器会执行每个类的定义体，甚至会执行嵌套类的定义体。这么做的结果就是，定义了类的属性和方法(方法的定义体依然不会被执行)，并构建了类这个对象。</li>
</ul>
<p>绕了这么一大圈，终于和元类发生了关系！类这个对象在导入时就会被创建，所以，元类在导入时就会初始化它的实例：类。</p>
<p>为了更真切的体验这个过程，下面创建几个类，并观察解释器在导入时和运行时的行为。</p>
<p>下面的代码会用到类装饰器和元类，前面说到类装饰器在子类中不一定起作用，但元类一定起作用，请留意这两个的行为。</p>
<h2 id="一般情况">5.1 一般情况</h2>
<p>这里指没有元类的情况。首先创建两个模块，代码可能有点长，但都很简单。注意这两个模块的名称，首先是<code>evaltime.py</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># evaltime.py</span></span><br><span class="line"><span class="keyword">from</span> evalsupport <span class="keyword">import</span> deco_alpha</span><br><span class="line"></span><br><span class="line">print(<span class="string">'&lt;[1]&gt; evaltime module start'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassOne</span>:</span>   <span class="comment"># 它嵌套了一个类</span></span><br><span class="line">    print(<span class="string">'&lt;[2]&gt; ClassOne body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[3]&gt; ClassOne.__init__'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[4]&gt; ClassOne.__del__'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_x</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[5]&gt; ClassOne.method_x'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ClassTwo</span><span class="params">(object)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[6]&gt; ClassTwo body'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@deco_alpha</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassThree</span>:</span>  <span class="comment"># 它被类装饰器装饰</span></span><br><span class="line">    print(<span class="string">'&lt;[7]&gt; ClassThree body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_y</span><span class="params">(self)</span>:</span>  <span class="comment"># 注意才场景2中观察这个方法的行为</span></span><br><span class="line">        print(<span class="string">'&lt;[8]&gt; ClassThree.method_y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassFour</span><span class="params">(ClassThree)</span>:</span>   <span class="comment"># 这里有一个继承，ClassThree被类装饰器装饰过</span></span><br><span class="line">    print(<span class="string">'&lt;[9]&gt; ClassFour body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_y</span><span class="params">(self)</span>:</span>  <span class="comment"># 注意才场景2中观察这个方法的行为</span></span><br><span class="line">        print(<span class="string">'&lt;[10]&gt; ClassFour.method_y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'&lt;[11]&gt; ClassOne tests'</span>, <span class="number">30</span> * <span class="string">'.'</span>)</span><br><span class="line">    one = ClassOne()</span><br><span class="line">    one.method_x()</span><br><span class="line">    print(<span class="string">'&lt;[12]&gt; ClassThree tests'</span>, <span class="number">30</span> * <span class="string">'.'</span>)</span><br><span class="line">    three = ClassThree()</span><br><span class="line">    three.method_y()</span><br><span class="line">    print(<span class="string">'&lt;[13]&gt; ClassFour tests'</span>, <span class="number">30</span> * <span class="string">'.'</span>)</span><br><span class="line">    four = ClassFour()</span><br><span class="line">    four.method_y()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'&lt;[14]&gt; evaltime module end'</span>)</span><br></pre></td></tr></table></figure>
<p>接着是<code>evalsupport.py</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># evalsupport.py</span></span><br><span class="line">print(<span class="string">'&lt;[100]&gt; evalsupport module start'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco_alpha</span><span class="params">(cls)</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[200]&gt; deco_alpha'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner_1</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[300]&gt; deco_alpha:inner_1'</span>)</span><br><span class="line"></span><br><span class="line">    cls.method_y = inner_1</span><br><span class="line">    <span class="keyword">return</span> cls</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MetaAleph</span><span class="params">(type)</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[400]&gt; MetaAleph body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(cls, name, bases, dic)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[500]&gt; MetaAleph.__init__'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner_2</span><span class="params">(self)</span>:</span></span><br><span class="line">            print(<span class="string">'&lt;[600]&gt; MetaAleph.__init__:inner_2'</span>)</span><br><span class="line"></span><br><span class="line">        cls.method_z = inner_2    <span class="comment"># 实例中的这个属性如果有，则会被替换</span></span><br><span class="line">                                  <span class="comment"># 如果没有，则新建这个属性并赋值为内嵌函数inner_2的引用</span></span><br><span class="line">print(<span class="string">'&lt;[700]&gt; evalsupport module end'</span>)</span><br></pre></td></tr></table></figure>
<p>上面这两个模块的代码中有<code>&lt;[N]&gt;</code>标记，<code>N</code>表示数字。现在请大家模拟以下两种场景，记录标记出现的顺序，最后再和真实结果比较。</p>
<p><strong>场景1</strong>：在Python控制台中以交互的方式导入<code>evaltime.py</code>模块，即</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> evaltime.py</span><br></pre></td></tr></table></figure>
<p><strong>场景2</strong>：在命令行中运行<code>evaltime.py</code>模块，即</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python3 evaltime.py</span><br></pre></td></tr></table></figure>
<p>建议模拟完后再看下面的结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 场景1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> evaltime.py</span><br><span class="line">&lt;[<span class="number">100</span>]&gt; evalsupport module start    <span class="comment"># 运行evalsupport.py模块</span></span><br><span class="line">&lt;[<span class="number">400</span>]&gt; MetaAleph body              <span class="comment"># MetaAleph的定义体运行了</span></span><br><span class="line">&lt;[<span class="number">700</span>]&gt; evalsupport module end      <span class="comment"># 函数deco_alpha定义体在导入时并没有被执行！</span></span><br><span class="line">&lt;[<span class="number">1</span>]&gt; evaltime module start         <span class="comment"># 开始运行evaltime.py模块</span></span><br><span class="line">&lt;[<span class="number">2</span>]&gt; ClassOne body                 <span class="comment"># ClassOne的定义体被运行了，但其中的方法没有被运行</span></span><br><span class="line">&lt;[<span class="number">6</span>]&gt; ClassTwo body                 <span class="comment"># 嵌套的ClassTwo的定义体也被运行了</span></span><br><span class="line">&lt;[<span class="number">7</span>]&gt; ClassThree body               <span class="comment"># ClassThree的定义体被执行。</span></span><br><span class="line">&lt;[<span class="number">200</span>]&gt; deco_alpha    <span class="comment"># 跳到了类装饰器中，函数定义体在导入时被执行了！证明导入时创建了类对象</span></span><br><span class="line">&lt;[<span class="number">9</span>]&gt; ClassFour body                <span class="comment"># 类定义体被执行</span></span><br><span class="line">&lt;[<span class="number">14</span>]&gt; evaltime module end          <span class="comment"># 模块执行完毕</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 场景2</span></span><br><span class="line">$ python3 evaltime.py</span><br><span class="line">&lt;[<span class="number">100</span>]&gt; evalsupport module start</span><br><span class="line">&lt;[<span class="number">400</span>]&gt; MetaAleph body</span><br><span class="line">&lt;[<span class="number">700</span>]&gt; evalsupport module end</span><br><span class="line">&lt;[<span class="number">1</span>]&gt; evaltime module start</span><br><span class="line">&lt;[<span class="number">2</span>]&gt; ClassOne body</span><br><span class="line">&lt;[<span class="number">6</span>]&gt; ClassTwo body</span><br><span class="line">&lt;[<span class="number">7</span>]&gt; ClassThree body</span><br><span class="line">&lt;[<span class="number">200</span>]&gt; deco_alpha</span><br><span class="line">&lt;[<span class="number">9</span>]&gt; ClassFour body                <span class="comment"># 在此行之前，和导入时没有区别，毕竟要执行得先导入嘛</span></span><br><span class="line">&lt;[<span class="number">11</span>]&gt; ClassOne tests ..............................   <span class="comment"># 开始执行if中的内容了</span></span><br><span class="line">&lt;[<span class="number">3</span>]&gt; ClassOne.__init__             <span class="comment"># 初始化ClassOne</span></span><br><span class="line">&lt;[<span class="number">5</span>]&gt; ClassOne.method_x             <span class="comment"># 调用ClassOne的method_x方法</span></span><br><span class="line">&lt;[<span class="number">12</span>]&gt; ClassThree tests .............................. </span><br><span class="line">&lt;[<span class="number">300</span>]&gt; deco_alpha:inner_1          <span class="comment"># ClassThree的method_y被替换了</span></span><br><span class="line">&lt;[<span class="number">13</span>]&gt; ClassFour tests ..............................</span><br><span class="line">&lt;[<span class="number">10</span>]&gt; ClassFour.method_y           <span class="comment"># 类装饰器在子类上不起作用</span></span><br><span class="line">&lt;[<span class="number">14</span>]&gt; evaltime module end          <span class="comment"># 模块运行结束</span></span><br><span class="line">&lt;[<span class="number">4</span>]&gt; ClassOne.__del__              <span class="comment"># ClassOne在被销毁时调用__del__方法</span></span><br></pre></td></tr></table></figure>
<p>不知大家的模拟是否和结果一致？</p>
<p>场景2中的结果证明了，类装饰器在子类中不一定起作用。</p>
<p>两个场景中，类装饰器在导入时都运行了一次，这证明了类对象在导入时创建，而不是在运行时创建。</p>
<h2 id="加入元类">5.2 加入元类</h2>
<p>还剩下的两个问题将在这个例子中找到答案。不过，还得再创建一个模块<code>evaltime_meta.py</code>，并建议大家回顾一下<code>MetaAleph</code>的实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># evaltime_meta.py</span></span><br><span class="line"><span class="keyword">from</span> evalsupport <span class="keyword">import</span> deco_alpha, MetaAleph</span><br><span class="line"></span><br><span class="line">print(<span class="string">'&lt;[1]&gt; evaltime_meta module start'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@deco_alpha</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassThree</span><span class="params">()</span>:</span>  <span class="comment"># 被类装饰器装饰</span></span><br><span class="line">    print(<span class="string">'&lt;[2]&gt; ClassThree body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_y</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[3]&gt; ClassThree.method_y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassFour</span><span class="params">(ClassThree)</span>:</span></span><br><span class="line">    print(<span class="string">'&lt;[4]&gt; ClassFour body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_y</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[5]&gt; ClassFour.method_y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassFive</span><span class="params">(metaclass=MetaAleph)</span>:</span>   <span class="comment"># 它是元类MetaAleph的实例！</span></span><br><span class="line">    print(<span class="string">'&lt;[6]&gt; ClassFive body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[7]&gt; ClassFive.__init__'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_z</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[8]&gt; ClassFive.method_y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassSix</span><span class="params">(ClassFive)</span>:</span>   <span class="comment"># 它也是元类MetaAleph的实例！</span></span><br><span class="line">    print(<span class="string">'&lt;[9]&gt; ClassSix body'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method_z</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'&lt;[10]&gt; ClassSix.method_y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'&lt;[11]&gt; ClassThree tests'</span>, <span class="number">30</span> * <span class="string">'.'</span>)</span><br><span class="line">    three = ClassThree()</span><br><span class="line">    three.method_y()</span><br><span class="line">    print(<span class="string">'&lt;[12]&gt; ClassFour tests'</span>, <span class="number">30</span> * <span class="string">'.'</span>)</span><br><span class="line">    four = ClassFour()</span><br><span class="line">    four.method_y()</span><br><span class="line">    print(<span class="string">'&lt;[13]&gt; ClassFive tests'</span>, <span class="number">30</span> * <span class="string">'.'</span>)</span><br><span class="line">    five = ClassFive()</span><br><span class="line">    five.method_z()</span><br><span class="line">    print(<span class="string">'&lt;[14]&gt; ClassSix tests'</span>, <span class="number">30</span> * <span class="string">'.'</span>)</span><br><span class="line">    six = ClassSix()</span><br><span class="line">    six.method_z()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'&lt;[15]&gt; evaltime_meta module end'</span>)</span><br></pre></td></tr></table></figure>
<p>还是那两个场景：</p>
<p><strong>场景1</strong>：在Python控制台中导入<code>evaltime_meta.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> evaltime_meta.py</span><br></pre></td></tr></table></figure>
<p><strong>场景2</strong>：在命令行中运行<code>evaltime_meta.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python3 evaltime_meta.py</span><br></pre></td></tr></table></figure>
<p>以下是两个场景的结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 场景1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> evaltime_meta.py</span><br><span class="line">&lt;[<span class="number">100</span>]&gt; evalsupport module start</span><br><span class="line">&lt;[<span class="number">400</span>]&gt; MetaAleph body</span><br><span class="line">&lt;[<span class="number">700</span>]&gt; evalsupport module end</span><br><span class="line">&lt;[<span class="number">1</span>]&gt; evaltime_meta module start</span><br><span class="line">&lt;[<span class="number">2</span>]&gt; ClassThree body</span><br><span class="line">&lt;[<span class="number">200</span>]&gt; deco_alpha</span><br><span class="line">&lt;[<span class="number">4</span>]&gt; ClassFour body        <span class="comment"># 到这里为止，和上一个场景1的情况一样</span></span><br><span class="line">&lt;[<span class="number">6</span>]&gt; ClassFive body        <span class="comment"># 执行了ClassFive定义体</span></span><br><span class="line">&lt;[<span class="number">500</span>]&gt; MetaAleph.__init__  <span class="comment"># 元类中的初始化方法在导入时被执行了！也证明导入时创建了类对象</span></span><br><span class="line">&lt;[<span class="number">9</span>]&gt; ClassSix body</span><br><span class="line">&lt;[<span class="number">500</span>]&gt; MetaAleph.__init__  <span class="comment"># 再次触发元类中的初始化方法，</span></span><br><span class="line">&lt;[<span class="number">15</span>]&gt; evaltime_meta module end</span><br><span class="line"></span><br><span class="line"><span class="comment"># 场景2</span></span><br><span class="line">$ python3 evaltime_meta.py</span><br><span class="line">&lt;[<span class="number">100</span>]&gt; evalsupport module start</span><br><span class="line">&lt;[<span class="number">400</span>]&gt; MetaAleph body</span><br><span class="line">&lt;[<span class="number">700</span>]&gt; evalsupport module end</span><br><span class="line">&lt;[<span class="number">1</span>]&gt; evaltime_meta module start</span><br><span class="line">&lt;[<span class="number">2</span>]&gt; ClassThree body</span><br><span class="line">&lt;[<span class="number">200</span>]&gt; deco_alpha</span><br><span class="line">&lt;[<span class="number">4</span>]&gt; ClassFour body</span><br><span class="line">&lt;[<span class="number">6</span>]&gt; ClassFive body</span><br><span class="line">&lt;[<span class="number">500</span>]&gt; MetaAleph.__init__</span><br><span class="line">&lt;[<span class="number">9</span>]&gt; ClassSix body</span><br><span class="line">&lt;[<span class="number">500</span>]&gt; MetaAleph.__init__   <span class="comment"># 到此行位置，和场景1的情况一样</span></span><br><span class="line">&lt;[<span class="number">11</span>]&gt; ClassThree tests ..............................</span><br><span class="line">&lt;[<span class="number">300</span>]&gt; deco_alpha:inner_1   <span class="comment"># 方法被类装饰器替换</span></span><br><span class="line">&lt;[<span class="number">12</span>]&gt; ClassFour tests ..............................</span><br><span class="line">&lt;[<span class="number">5</span>]&gt; ClassFour.method_y     <span class="comment"># 类装饰器对子类不起作用</span></span><br><span class="line">&lt;[<span class="number">13</span>]&gt; ClassFive tests ..............................</span><br><span class="line">&lt;[<span class="number">7</span>]&gt; ClassFive.__init__     <span class="comment"># 初始化ClassFive的实例five</span></span><br><span class="line">&lt;[<span class="number">600</span>]&gt; MetaAleph.__init__:inner_2  <span class="comment"># 方法被替换</span></span><br><span class="line">&lt;[<span class="number">14</span>]&gt; ClassSix tests ..............................</span><br><span class="line">&lt;[<span class="number">7</span>]&gt; ClassFive.__init__     <span class="comment"># 初始化ClassFive的子类ClassSix的实例six</span></span><br><span class="line">&lt;[<span class="number">600</span>]&gt; MetaAleph.__init__:inner_2  <span class="comment"># 子类的方法也被替换了！</span></span><br><span class="line">&lt;[<span class="number">15</span>]&gt; evaltime_meta module end</span><br></pre></td></tr></table></figure>
<p>这组例子再一次证明了类对象在导入时创建！并且元类对它的类对象的初始化也在导入时进行。其实，导入时对于元类来说就是它的运行时。</p>
<p>现在来回答之前留下的两个问题：</p>
<ul>
<li>元类只要有实例，元类的<code>__init__</code>方法就一定先于实例的<code>__init__</code>方法先执行。比较这两者的<code>__init__</code>方法有些牵强，毕竟类对象(例如<code>ClassFive</code>)在运行时创建，因此元类的<code>__init__</code>方法必定在导入时执行；而类实例在运行时才创建，类对象的<code>__init__</code>方法也就只能在运行时才执行。其实就是一个显而易见的逻辑：<strong>什么时候创建"实例"，就什么时候执行"类"中的<code>__init__</code>方法咯</strong>。不过得清楚，这里的"实例"和"类"究竟指代的是谁。</li>
<li>上一条解释其实已经回答了"元类为什么能覆盖所有子类的方法"。<code>ClassFive</code>是元类<code>MetaAleph</code>的实例，而不是继承自<code>MetaAleph</code>；<code>ClassSix</code>虽继承自<code>ClassFive</code>，但又不是继承自<code>MetaAleph</code>，它仅仅只是<code>MetaAleph</code>的又一个实例而已。这里说的覆盖对元类而言根本就不是覆盖，元类仅仅只是在为它的实例的属性赋值而已：你(<code>ClassSix</code>)只是我(<code>MetaAleph</code>)的实例，你继承自我的另一个实例(<code>ClassFive</code>)，又不是继承自我，所以你跟我谈什么继承与覆盖？我只是在给你的属性赋值而已！</li>
</ul>
<p>本文对元类的介绍到此结束。这些内容仅仅只是元类的皮毛。其中有很多地方依然没有弄懂，继续努力吧！</p>
<h2 id="补充">5.3 补充</h2>
<p>其实如果想弥补本文中类装饰器的缺陷，可以不用定义元类，现在有更方便的方法：定义特殊方法<code>__init_subclass__</code>。它的作用和本文中的元类一样，但比创建元类简单直观得多。在创建子类时，子类都会被这个方法初始化。</p>
<h1 id="总结">6. 总结</h1>
<p>本文首先展示了元类的基本用法：直接用<code>type()</code>函数创建类，然后将元类用到了类工厂函数中。之后加入了一个小插曲，类装饰器；接着深入介绍了元类的概念性知识，并展示了如何使用<code>class</code>和<code>metaclass</code>关键字从元类创建类。最后，介绍了运行时与导入时的概念，并通过代码展示了这两者的区别，尤其展示了类的创建时间。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python进阶</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python进阶</tag>
        <tag>元编程</tag>
        <tag>元类</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路40-属性描述符</title>
    <url>/2018/06/24/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF40-%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6/</url>
    <content><![CDATA[<blockquote>
<p>《流畅的Python》笔记。</p>
<p>本篇主要讨论Python中的描述符，它是精通Python的关键。</p>
</blockquote>
<a id="more"></a>
<h1 id="前言">1. 前言</h1>
<p>描述符是对多个属性运用相同存取逻辑的一种方式。它是实现了特定协议的类，只要实现了<code>__get__</code>，<code>__set__</code>和<code>__delete__</code>三个方法中的任意一个，这个类就是描述符。</p>
<p>特性<code>property</code>类实现了完整的描述符协议，大多数描述符只实现了<code>__get__</code>和<code>__set__</code>方法，还有很多只实现了其中的一个。</p>
<p>描述符的用法很简单：<strong>创建一个实例，作为另一个类的类属性</strong>。</p>
<p>本篇的内容包括：将<a href="http://www.vpointer.net/articles/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF39-%E7%89%B9%E6%80%A7property/" target="_blank" rel="noopener">上一篇</a>中的特性工厂函数改为描述符类；重构并派生描述符子类；覆盖型描述符和非覆盖型描述符；非覆盖型描述符的典型代表：方法。</p>
<h1 id="描述符">2. 描述符</h1>
<p><a href="http://www.vpointer.net/articles/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF39-%E7%89%B9%E6%80%A7property/" target="_blank" rel="noopener">上一篇</a>中，我们用特性工厂函数<code>quantity()</code>实现了特性的抽象，并以此来验证属性。现在我们将<code>quantity()</code>函数改为<code>Quantity</code>描述符类。</p>
<h2 id="quantity">2.1 Quantity</h2>
<p><code>Quantity</code>类暂时只实现存值方法，取值方法暂时还用不到：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码2.1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quantity</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, storage_name)</span>:</span></span><br><span class="line">        self.storage_name = storage_name  <span class="comment"># 存储描述符对应的属性名？</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value &gt; <span class="number">0</span>:</span><br><span class="line">            instance.__dict__[self.storage_name] = value   <span class="comment"># 注意此处，用的是__dict__</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"value must be &gt; 0"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Food</span>:</span></span><br><span class="line">    weight = Quantity(<span class="string">"weight"</span>)  <span class="comment"># 类属性</span></span><br><span class="line">    price = Quantity(<span class="string">"price"</span>)    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, weight, price)</span>:</span></span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.price = price</span><br></pre></td></tr></table></figure>
<p>这段代码并不复杂，<code>weight</code>和<code>price</code>与上一篇一样，被设置成了类属性。但奇怪的是，<code>__set__</code>的参数列表是<code>(self, instance, value)</code>，即，传入了一个实例，而不是预想的<code>(self, value)</code>。并且这个方法中，直接操作实例的字典属性<code>instance.__dict__[self.storage_name]</code>来修改值，而不是操作描述符的字典属性<code>self.__dict__[self.storage_name]</code>。暂时不解释，先来看看<code>Food</code>的行为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码2.2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Food(<span class="number">100</span>,<span class="number">0</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">   -- snip --</span><br><span class="line">ValueError: value must be &gt; <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = Food(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.weight = <span class="number">-1</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">   -- snip --</span><br><span class="line">ValueError: value must be &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>当要创建一个<code>price</code>值为0的<code>Food</code>实例时，抛出了异常，行为符合要求。当要给属性<code>weight</code>设置负值时，行为也是正确的。<code>Food</code>类的行为符合要求。</p>
<h2 id="托管">2.2 托管</h2>
<p>继续研究描述符，突然蹦出来些奇怪的概念：</p>
<ul>
<li>描述符类，描述符实例：实现了描述符协议的类叫描述符类，它的实例就是描述符实例（废话，这并不奇怪）；</li>
<li>托管类，托管实例：把描述符实例声明为类属性的类，也就是上面的<code>Food</code>类；这种类的对象就称为托管实例，也就是上面的<code>f</code>(这也很好理解)；</li>
<li>储存属性：托管实例中存储自身托管属性的属性(这看的是天书？说的这么妖娆？)；</li>
<li>托管属性：托管类中有描述符实例处理的公开属性，值存储在储存属性中(已经懵逼了)。</li>
</ul>
<p>Wait a minute! 怎么就扯上“托管”了？我把什么托管给谁了？为了弄清描述符到底是干什么的，就得弄清这些概念。不过在这之前，先来看看之前我们用到的描述符<code>property</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码2.3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span>  <span class="comment"># 如果按下方注释中的写法，会无限递归，直到强制结束</span></span><br><span class="line"><span class="meta">... </span>    @property</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">(self)</span>:</span> <span class="keyword">return</span> self.__a           <span class="comment"># 并不是 return self.a</span></span><br><span class="line"><span class="meta">... </span>    @a.setter</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">(self, value)</span>:</span> self.__a = value   <span class="comment"># 也不是 self.a = value</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = Test()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vars(t)</span><br><span class="line">&#123;&#125;   <span class="comment"># 空的，并不是&#123;"a": None&#125;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.a = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vars(t)</span><br><span class="line">&#123;<span class="string">"_Test__a"</span>: <span class="number">1</span>&#125;    <span class="comment"># 也不是&#123;"a": 1&#125;</span></span><br></pre></td></tr></table></figure>
<p>当创建<code>Test</code>的实例<code>t</code>时，它的属性列表是空的，可以理解，毕竟没有给它定义实例属性，而<code>a</code>又是类属性，<code>vars</code>函数不会输出它。但当给<code>t.a</code>赋值后，属性列表多了一个属性，值也存到了这个属性中。换句话说，值并没有存到<code>t.a</code>中，而是存到了<code>t.__a</code>(或者说<code>t._Test__a</code>)中。再来看<code>Food</code>的实例<code>f</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码2.4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = Food(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vars(f)</span><br><span class="line">&#123;<span class="string">"weight"</span>: <span class="number">1</span>, <span class="string">"price"</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>
<p><code>f</code>居然有两个和类属性同名的实例属性(实例属性和描述符实例同名)！但在定义<code>Food</code>的时候，一个实例属性都没有定义，那这俩实例属性是从哪来的？不难发现：在<code>Quantity</code>的 <code>__set__</code>方法中，我们直接操作了实例的<code>__dict__</code>，<code>instance.__dict__[self.storage_name]</code>，在为<code>self.weight</code>和<code>self.price</code>赋值时，创建了这两个实例属性。</p>
<p>这和我最初的理解相差有点大呀：<strong>描述符不是用来管理属性的存取的吗？不保存这些值怎么管理呢？嗯？难道它是个中介？</strong></p>
<p>之所以有这个疑惑，其实是忽略了一个概念：<strong>描述符是类属性</strong>。一个类的实例有千千万万个，但类属性是唯一的，被所有实例所共有。要是把每个实例的数据都存到类属性中，这不叫“管理”，这叫“制造混乱”。</p>
<p>也就是说，描述符其实是个管理工具，它不是用来存储实例的数据属性的，而是代为管理实例的这些属性。这也解释了为什么有“托管”一说：<strong>所有</strong>托管实例将某些共同的属性委托给<strong>一个</strong>描述符实例管理。没使用描述符时，用户获取属性，比如<code>f.weight</code>，这相当于直接调用<code>f.__dict__["weight"]</code>，即用户直接操作了<code>__dict__</code>；使用了描述符后，对<code>__dict__</code>的操作由描述符接管：“你自己操作不安全，告诉我(描述符)你要做什么，我来给你操作”。从这个层面讲，描述符更应该被叫做“接管器”。</p>
<p>现在再回过头来看之前给出的那些奇怪概念：</p>
<ul>
<li><strong>描述符类</strong>，<strong>描述符实例</strong>：我们自定义的，实现了描述符接口的<code>Quantity</code>就是描述符类，<code>Food</code>中的<code>weight</code>和<code>price</code>类属性就是描述符实例；</li>
<li><strong>托管类</strong>，<strong>托管实例</strong>：<code>Food</code>类使用了描述符实例<code>weight</code>和<code>price</code>作为类属性，所以它是<strong>托管类</strong>；前面用到的<code>f</code>就是<strong>托管实例</strong>；</li>
<li><strong>托管属性</strong>：在使用<code>Food</code>或<code>Test</code>的实例时，如果不知道这两个类的定义，那么在调用<code>f.weight</code>或者<code>t.a</code>时，我们只能判断<code>f</code>有个名为<code>weight</code>的属性，<code>t</code>有个名为<code>a</code>的属性，但这两个属性是一般属性还是特性或者描述符，这就无法直观判断了，只知道这俩属性能公开访问(这类属性也叫<strong>公开属性</strong>)。如果某个公开属性是由描述符管理的，这个公开属性就是<strong>托管属性</strong>，否则就是一般的属性。但<strong>托管属性并不是指与之同名的用作类属性的描述符实例</strong>。</li>
<li><strong>储存属性</strong>：经上述分析可知，描述符不是用来存储托管实例的属性的，而是用来管理的，但这些值总得有个地方存呀。托管实例真正存这些值的属性就叫做<strong>储存属性</strong>(如果要说得再准确一点，就是前面给出的那个妖娆的定义)。托管属性<code>t.a</code>真正的值存在<code>t._Test__a</code>中，托管属性<code>f.weight</code>真正的值存在<code>f.__dict__["weight"]</code>中，这两个实例属性就叫做<strong>储存属性</strong>。或者说，与<code>self.storage_name</code>同名的属性就是储存属性。这里也体现了“描述符”为什么叫“描述符”：把一个属性“描述”成另一个属性。可以看出，<strong>储存属性和托管属性是可以同名的</strong>，或者说，<strong>储存属性和描述符实例是可以同名的</strong>！一旦同名，大家也应该明白会牵扯到什么问题：覆盖。</li>
</ul>
<p>上述这些概念也解释了之前的疑惑：</p>
<ul>
<li>描述符需要知道从托管实例的哪个属性获取值，或者存到哪个属性中，因此<code>Quantity</code>需要定义一个实例属性<code>storage_name</code>，它的值是<strong>储存属性</strong>的名称；</li>
<li>描述符其实是管理工具，它要操作实例，所以<code>Quantity</code>中<code>__set__</code>的参数列表是<code>(self, instance, value)</code>，而不是<code>(self, value)</code>；</li>
<li>描述符用作类属性，它不是用来存储托管实例的属性的，真正的值依然存储在托管实例中，所以是<code>instance.__dict__[self.storage_name]</code>，而不是<code>self.__dict__[self.storage_name]</code>。</li>
</ul>
<h2 id="重构quantity">2.3 重构Quantity</h2>
<p>使用上述<code>Quantity</code>，当在<code>Food</code>中定义描述符实例时，同一个单词重复输入了两次，这看着有点别扭，能不能只输入一次呢？比如像这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码2.5</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Food</span>:</span></span><br><span class="line">    weight = Quantity()</span><br></pre></td></tr></table></figure>
<p>实现这种功能最好的办法是使用类装饰器或元类，这将在下一篇文章中介绍。本篇介绍一个略显笨拙的方式：既然<code>Food</code>中不指定<strong>储存属性</strong>的名称，那就自动生成，为每个<code>Quantity</code>实例的<code>storage_name</code>创建一个唯一的字符串。</p>
<p>我们还要实现之前没有实现的<code>__get__</code>方法，而且还想在<code>Food</code>中添加一个<code>description</code>实例，用于描述<code>Food</code>实例。<code>description</code>不能为空，因此也需要使用描述符。由于验证逻辑和<code>weight</code>相似，从头再写一个描述符类并不值得，因此选择继承。</p>
<p>以下是重构后的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码2.6</span></span><br><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoStorage</span>:</span>   <span class="comment"># 这个描述符可以作用于一般的属性，并没有进行属性验证</span></span><br><span class="line">    __counter = <span class="number">0</span>    <span class="comment"># 描述符类内部维护一个计数器，用于创建属性</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>        <span class="comment"># 不再需要传入储存属性的名称，由描述符类自动生成</span></span><br><span class="line">        cls = self.__class__   <span class="comment"># 名称的格式为 下划线 + 类名 + #号 + 编号</span></span><br><span class="line">        prefix = cls.__name__  <span class="comment"># 类名作为前缀</span></span><br><span class="line">        index = cls.__counter  <span class="comment"># 获取编号</span></span><br><span class="line">        self.storage_name = <span class="string">"_&#123;&#125;#&#123;&#125;"</span>.format(prefix, index)   <span class="comment"># 生成类名</span></span><br><span class="line">        cls.__counter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span>  <span class="comment"># 这个方法有一个owner参数，它是托管类的引用</span></span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:    <span class="comment"># 如果实例为空，此时表示通过托管类而不是托管实例实例来访问属性</span></span><br><span class="line">            <span class="keyword">return</span> self         <span class="comment"># 返回描述类实例自身</span></span><br><span class="line">        <span class="keyword">else</span>:                   <span class="comment"># 否则返回托管实例相应的属性</span></span><br><span class="line">            <span class="keyword">return</span> getattr(instance, self.storage_name)   <span class="comment"># 并没有直接调用__dict__</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span>   <span class="comment"># 这里并没有验证，而是直接赋值</span></span><br><span class="line">        setattr(instance, self.storage_name, value)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Validated</span><span class="params">(abc.ABC, AutoStorage)</span>:</span>    <span class="comment"># 多重继承，重写了__set__方法，赋值之前进行验证</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span>   </span><br><span class="line">        value = self.validate(instance, value)   </span><br><span class="line">        super().__set__(instance, value)  <span class="comment"># 并没有直接调用__dict__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod                  # 将验证的过程单独放到一个函数中</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, instance, value)</span>:</span> <span class="comment"># 并由子类自行实现验证方法</span></span><br><span class="line">        <span class="string">"""return validated value or raise ValueError"""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quantity</span><span class="params">(Validated)</span>:</span>  <span class="comment"># 值必须大于0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, instance, value)</span>:</span>   <span class="comment"># 这个描述符类只需重写验证方法</span></span><br><span class="line">        <span class="keyword">if</span> value &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"value must be &gt; 0!"</span>)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonBlank</span><span class="params">(Validated)</span>:</span>  <span class="comment"># 值不能是空字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        value = value.strip()</span><br><span class="line">        <span class="keyword">if</span> len(value) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"value cannot be empty or blank"</span>)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Food</span>:</span></span><br><span class="line">    description = NonBlank()</span><br><span class="line">    weight = Quantity()</span><br><span class="line">    price = Quantity()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, description, weight, price)</span>:</span></span><br><span class="line">        self.description = description</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.price = price</span><br></pre></td></tr></table></figure>
<p>在<code>__get__</code>方法的参数列表中有一个<code>owner</code>参数，它存储的是托管类的引用。它之前还有一个<code>instance</code>参数，如果是通过<strong>托管实例</strong>访问属性，比如<code>f.weight</code>，<code>instance</code>的值则为<code>f</code>的引用；如果是通过<strong>托管类</strong>访问属性，比如<code>Food.weight</code>，<code>instance</code>的值则为<code>None</code>。</p>
<p>在<code>__get__</code>和<code>__set__</code>方法中，我们并没有直接操作<code>__dict__</code>，因为这里的<strong>储存属性</strong>和<strong>描述符实例</strong>不会重名，所以不会产生无限递归，可以使用内置的<code>getattr()</code>和<code>setattr()</code>函数。</p>
<p>为了自动生成<code>storage_name</code>，这里以<code>_Quantity#</code>或者<code>_NonBlank#</code>为前缀，然后在后面接个数字。然而，形如<code>f._Quantity#0</code>的直接访问在Python中是无效的，因为注释也用的是<code>#</code>号，然而内置的<code>getattr</code>和<code>setattr</code>函数可以使用这种“无效的”标识获取和设置属性，此外也可以直接处理实例属性<code>__dict__</code>，因为井号<code>#</code>被放到了字符串中。</p>
<h2 id="描述符-vs-特性工厂函数">2.4 描述符 vs 特性工厂函数</h2>
<p>将描述符的实现和前面的特性工厂函数对比，其实差别并不是想象中的那么大。这两者有以下几点差异：</p>
<ul>
<li>描述符类可以使用子类扩展；若想重用工厂函数中的代码，除了复制粘贴，很难有其他方法；</li>
<li>如果要像<code>代码2.6</code>中重构后的描述符那样自动创建<code>storage_name</code>，那么工厂函数需要用到函数属性和闭包，这让代码显得不够直观。</li>
</ul>
<h1 id="覆盖型与非覆盖型描述符">3. 覆盖型与非覆盖型描述符</h1>
<p>Python<strong>存取属性的方式</strong>并不是对等的：通过实例<strong>读取属性</strong>时，通常返回的是实例中定义的属性，如果没有这个属性，再到所属的类中去找；但为实例中的<strong>属性赋值</strong>时，通常会在实例中创建属性，根本不影响类。</p>
<p>这种不对等也影响到了描述符。根据是否定义<code>__set__</code>方法，描述符被分成了两大类：定义了<code>__set__</code>方法的描述符是覆盖型描述符，否则是费覆盖型描述符。可以分为以下三种情况(再次提醒，描述符是类属性)：</p>
<ul>
<li>如果描述符实现了<code>__get__</code>和<code>__set__</code>方法，描述符<strong>会</strong>覆盖同名实例属性，即属性的<strong>存取值</strong>过程<strong>都会</strong>被描述符接管。这说得通，毕竟两个方法都定义了；</li>
<li>如果描述符只实现了<code>__set__</code>方法，描述符“<strong>半覆盖</strong>”同名实例属性，即<strong>存值</strong>过程<strong>会</strong>被接管，而<strong>取值</strong>过程<strong>不会</strong>被接管。这也说得通，毕竟没有定义<code>__get__</code>方法；</li>
<li>如果描述符只实现了<code>__get__</code>方法，描述符<strong>不会</strong>覆盖同名实例属性，即<strong>存取值</strong>过程<strong>都不会</strong>被接管！这就蹊跷了，明明定义了<code>__get__</code>方法，但它不起作用。</li>
</ul>
<p>定义三个描述符和一个类用于演示上述情况：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码3.1 所有的__get__，__set__方法都只是输出操作，没有存取值的操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Overriding</span>:</span>        <span class="comment"># 两个方法都实现，覆盖型</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        print(instance, owner)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        print(instance, value)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OverridingNoGet</span>:</span>   <span class="comment"># 只实现__set__，覆盖型</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        print(instance, value)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonOverriding</span>:</span>     <span class="comment"># 只实现__get__，非覆盖型</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        print(instance, owner)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Managed</span>:</span></span><br><span class="line">    over = Overriding()</span><br><span class="line">    over_no_get = OverridingNoGet()</span><br><span class="line">    non_over = NonOverriding()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(self)</span>:</span>  <span class="comment"># 这个方法后面会用到</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>下面我们通过一些例子来展示覆盖的情况。</p>
<h2 id="覆盖型描述符">3.1 覆盖型描述符</h2>
<p>此处展示实现了<code>__get__</code>和<code>__set__</code>方法的描述符的覆盖情况：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码3.2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = Managed()  <span class="comment"># 此时没有实例属性</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.over      <span class="comment"># 取值过程被接管，注意输出，形参instance指向obj</span></span><br><span class="line">&lt;a.Managed object at <span class="number">0x000001A616C13EB8</span>&gt; &lt;<span class="class"><span class="keyword">class</span> '<span class="title">a</span>.<span class="title">Managed</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">Managed</span>.<span class="title">over</span>  # 通过托管类读值，依然被描述符接管，<span class="title">instance</span>为空</span></span><br><span class="line"><span class="class"><span class="title">None</span> &lt;<span class="title">class</span> '<span class="title">a</span>.<span class="title">Managed</span>'&gt;</span></span><br><span class="line">&gt;&gt;&gt; obj.over = 7  # 存值过程也被接管，值传给了__set__的形参value</span><br><span class="line">&lt;a.Managed object at <span class="number">0x000001A616C13EB8</span>&gt; <span class="number">7</span>   <span class="comment"># 注意这里的输出</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vars(obj)     <span class="comment"># 由于存值过程被接管，所以依然没有实例属性</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.__dict__[<span class="string">"over"</span>] = <span class="number">8</span>   <span class="comment"># 绕过描述符，直接存值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vars(obj)     <span class="comment"># 有了和描述符同名的实例属性</span></span><br><span class="line">&#123;<span class="string">'over'</span>: <span class="number">8</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.over      <span class="comment"># 描述符覆盖了实例属性(被接管)，读不到实例属性的值</span></span><br><span class="line">&lt;a.Managed object at <span class="number">0x000001A616C13EB8</span>&gt; &lt;<span class="class"><span class="keyword">class</span> '<span class="title">a</span>.<span class="title">Managed</span>'&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里不光验证了前面的说法，还发现，通过类访问描述符(<code>Managed.over</code>)，依然会调用<code>__get__</code>方法。而对于普通的类属性，(如果没有定义重写<code>__repr__</code>方法)则会直接返回类属性在内存中的信息，比如<code>&lt;a.OtherClass object at 0x...&gt;</code>。也就是说，通过托管类访问描述符依然会被接管。</p>
<h2 id="无-__get__-方法描述符">3.2 无 __get__ 方法描述符</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码3.3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = Managed()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.over_no_get</span><br><span class="line">&lt;a.OverridingNoGet object at <span class="number">0x0000019FF17C7E48</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Managed.over_no_get</span><br><span class="line">&lt;a.OverridingNoGet object at <span class="number">0x0000019FF17C7E48</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.over_no_get = <span class="number">7</span></span><br><span class="line">&lt;a.Managed object at <span class="number">0x0000019FF1F88748</span>&gt; <span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vars(obj)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.__dict__[<span class="string">"over_no_get"</span>] = <span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vars(obj)</span><br><span class="line">&#123;<span class="string">"over_no_get"</span>: <span class="number">8</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.over_no_get</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>可以看到，读值过程没有被接管。在没有实例属性<code>over_no_get</code>之前，<code>obj.over_no_get</code>和<code>Managed.over_no_get</code>都返回的是描述符实例<code>over_no_get</code>在内存中的信息。</p>
<h2 id="非覆盖型描述符">3.3 非覆盖型描述符</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码3.4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = Managed()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.non_over</span><br><span class="line">&lt;a.Managed object at <span class="number">0x0000019FF1F88710</span>&gt; &lt;<span class="class"><span class="keyword">class</span> '<span class="title">a</span>.<span class="title">Managed</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">Managed</span>.<span class="title">non_over</span></span></span><br><span class="line"><span class="class"><span class="title">None</span> &lt;<span class="title">class</span> '<span class="title">a</span>.<span class="title">Managed</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">vars</span><span class="params">(obj)</span></span></span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.non_over = <span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.non_over</span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vars(obj)</span><br><span class="line">&#123;<span class="string">"non_over"</span>: <span class="number">7</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Managed.non_over</span><br><span class="line"><span class="literal">None</span> &lt;<span class="class"><span class="keyword">class</span> '<span class="title">a</span>.<span class="title">Managed</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">del</span> <span class="title">obj</span>.<span class="title">non_over</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">obj</span>.<span class="title">non_over</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">a</span>.<span class="title">Managed</span> <span class="title">object</span> <span class="title">at</span> 0<span class="title">x0000019FF1F88710</span>&gt; &lt;<span class="title">class</span> '<span class="title">a</span>.<span class="title">Managed</span>'&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到，未赋值前，<code>obj.non_over</code>和<code>Managed.non_over</code>都被描述符接管，此时<code>obj</code>中也没有实例属性。在赋值过后，<code>obj</code>中有了实例属性<code>non_over</code>，并且它覆盖了描述符，读值过程没有被接管。删除了实例属性后，描述符不再被覆盖。非覆盖型描述符可以实现缓存。</p>
<h1 id="方法是描述符">4. 方法是描述符</h1>
<p>在类中定义的函数属于绑定方法(bound method)，简称方法，而用户定义的函数都有<code>__get__</code>方法，所以方法其实是非覆盖型描述符。这也是非覆盖型描述符的一个具体类型，同时，这也说明了，Python语言的底层就用到了描述符类。下面是之前定义的<code>spam</code>方法的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码4.1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = Managed()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.spam</span><br><span class="line">&lt;bound method Managed.spam of &lt;a.Managed object at <span class="number">0x0000019FF17E1E80</span>&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Managed.spam</span><br><span class="line">&lt;function Managed.spam at <span class="number">0x0000019FF1F7D7B8</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.spam = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.spam</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vars(obj)</span><br><span class="line">&#123;<span class="string">"spam"</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> obj.spam</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.spam</span><br><span class="line">&lt;bound method Managed.spam of &lt;a.Managed object at <span class="number">0x0000019FF17E1E80</span>&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.spam.__self__</span><br><span class="line">&lt;a.Managed object at <span class="number">0x0000019FF17E1E80</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.spam.__func__ <span class="keyword">is</span> Managed.spam</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.spam.__get__</span><br><span class="line">&lt;method-wrapper <span class="string">'__get__'</span> of method object at <span class="number">0x00000261B11B3908</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Managed.spam((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">(<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>从上面的例子可以看到一个重要的信息：<code>obj.spam</code>和<code>Managed.spam</code>获取的是不同的对象，这和前面三种情况的描述符很不一样。<code>Managed.spam</code>得到的是<code>function</code>对象，而<code>obj.spam</code>得到的是<code>bound method</code>对象：</p>
<ul>
<li>绑定方法对象是一种可调用的对象，里面包装着函数，并把托管实例绑定给函数的第一个参数;</li>
<li>绑定方法对象有一个<code>__self__</code>属性，其值是调用这个方法的实例的引用，比如<code>obj.spam.__self__</code>就是<code>obj</code>自身；</li>
<li>绑定方法对象还有个<code>__func__</code>属性，它的值是依附在<strong>托管类</strong>上的那个原始函数的引用；通过<strong>托管类</strong>访问方法也访问的是那个原始函数(<code>Managed.spam</code>)，换句话说，如果通过托管类访问方法，这个方法就只是一个普通函数，此时传入的第一个参数会赋值给形参<code>self</code>，<code>self</code>不再自动指向任何类的实例。比如上述的<code>Managed.spam((1, 2, 3))</code>，<code>self</code>参数存的是元组<code>(1, 2, 3)</code>的引用。</li>
<li>绑定方法对象还有个<code>__call__</code>方法，用于处理真正的调用过程：它会调用<code>__func__</code>引用的原始函数，并把<code>__self__</code>的引用传给函数的第一个参数，也就是<code>self</code>。这也正是<code>self</code>的隐式绑定过程。</li>
</ul>
<p>也就是说，<code>function</code>对象只要一个，但<code>bound method</code>对象会随实例的不同而不同；与描述符接管属性的存取过程类似，实例调用方法时也会被接管，由<code>bound method</code>去调用真正的<code>function</code>。</p>
<h1 id="总结">5. 总结</h1>
<p>本篇首先将讲特性工厂函数换成了描述符类，介绍了描述符的基本用法；然后介绍了众多与描述符相关的概念(“托管”)；随后我们将<code>Quantity</code>重构，实现了描述符的派生，以及去掉了之前声明<code>Quantity</code>描述符所需的<code>storage_name</code>参数；接着介绍了覆盖型与非覆盖型描述符；最后介绍了非覆盖型描述符的一个典型类型：方法。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python进阶</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python进阶</tag>
        <tag>描述符</tag>
        <tag>属性</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路39-特性property</title>
    <url>/2018/06/23/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF39-%E7%89%B9%E6%80%A7property/</url>
    <content><![CDATA[<blockquote>
<p>《流畅的Python》笔记。</p>
<p>本篇主要讨论Python中的特性property。</p>
</blockquote>
<a id="more"></a>
<h1 id="前言">1. 前言</h1>
<p><a href="http://www.vpointer.net/articles/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF38-%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E5%B1%9E%E6%80%A7/" target="_blank" rel="noopener">上一篇</a>介绍了如何动态创建属性(Attribute)，在最后一个例子中我们使用了<code>@property</code>装饰器实现了只读特性。本篇将介绍如何使用特性(Property)来验证属性。我会通过一个<code>Food</code>类来演示<code>property</code>的用法和行为。</p>
<h1 id="property基本用法">2. property基本用法</h1>
<p><code>Food</code>是个食品类，论公斤卖，以下是它的定义和用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码2.1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Food</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, weight, price)</span>:</span></span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtotal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.weight * self.price</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>food = Food(<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>food.subtotal()</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>food.weight = <span class="number">-20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>food.subtotal()</span><br><span class="line"><span class="number">-200</span></span><br></pre></td></tr></table></figure>
<p>这个类很简单，但有一个问题：可以将<code>self.weight</code>和<code>self.price</code>的值设为负数。解决这个问题很好办，为每个属性设置<code>get/set</code>方法，在设置值之前对传入的值进行验证，Java就是这么做的。但比起直接访问和设置属性来说，通过<code>get/set</code>方法操作属性并不自然。并且，如果这个代码已经上线运行，存取值就是直接操作属性，现在要把它改成用<code>get/set</code>方法操作属性，那要改的地方就太多了。此时，符合Python风格的做法是：将属性替换成特性。</p>
<p>现在我们使用<code>@property</code>装饰器来修改上述代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码2.2 subtotal()不变</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Food</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, weight, price)</span>:</span></span><br><span class="line">        self.weight = weight  <span class="comment"># 这里已经在使用特性了，而不是创建一个名为weight的属性</span></span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property  # get方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">weight</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__weight</span><br><span class="line"></span><br><span class="line"><span class="meta">    @weight.setter  # set方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">weight</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value &gt; <span class="number">0</span>:</span><br><span class="line">            self.__weight = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"Value must be &gt; 0"</span>)</span><br></pre></td></tr></table></figure>
<p>我们将真正的值存储在<code>self.__weight</code>属性中，并且在设置<code>weight</code>的值之前进行了验证，使其必须为正数。</p>
<p>这里留了一个坑：<code>price</code>依然可以设置为负数。之所以没有改<code>price</code>，因为如果要改，也就只是把上面<code>get/set</code>方法再抄一遍：把<code>self.__weight</code>换为<code>self.__price</code>，再把方法名给换了。这不就重复造轮子了吗？要是<code>get/set</code>方法的代码量比较大，那整个文件一大半内容都被存取值方法给占了。如果这个类再多一些属性，这些属性的要求都一样，这得写多少个<code>@property</code>？</p>
<p>避免这种情况的方法大家都知道：抽象。对特性进行抽象有两种方式：使用特性工厂函数，或者使用描述符类。后者更灵活，下一篇再介绍。本篇介绍特性工厂函数，不过在此之前，先深入了解一下特性。</p>
<h1 id="property解析">3. property解析</h1>
<p>虽然内置的<code>property</code>经常被用作装饰器，但它其实是一个类(在Python中，类和函数经常互换，不用纠结)。它的构造方法的完整签名如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码3.1</span></span><br><span class="line">property(fget=<span class="literal">None</span>, fset=<span class="literal">None</span>, fdel=<span class="literal">None</span>, doc=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>所有参数都是可选的，比如<code>Food</code>中，特性<code>weight</code>设置了前两个参数，后两个没有设置。</p>
<h2 id="用法">3.1 用法</h2>
<p><code>property</code>有两种用法，将其用作装饰器是现在主流的用法，但它还有一个“经典”的用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码3.2 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_a</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__a</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_a</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.__a = value</span><br><span class="line">    </span><br><span class="line">    a = property(get_a, set_a)</span><br></pre></td></tr></table></figure>
<p>某些情况下，这种写法比装饰器写法要好，比如后面用到的特性工厂函数，但装饰器更加明显且常用。</p>
<h2 id="特性覆盖实例属性">3.2 特性覆盖实例属性</h2>
<p><strong>类属性会被实例属性覆盖，特性也是类属性，但特性管理的是实例属性的存取，它不会被实例属性覆盖。</strong>下面来看一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码3.3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span>  <span class="comment"># 定义一个测试类</span></span><br><span class="line"><span class="meta">... </span>    data = <span class="string">"the class data attr"</span>   <span class="comment"># 这是个类属性</span></span><br><span class="line"><span class="meta">... </span>    @property</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">prop</span><span class="params">(self)</span>:</span>   <span class="comment"># prop是特性，特性也是类属性！</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">"the prop value"</span></span><br><span class="line"><span class="meta">... </span>   </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = Test()      <span class="comment"># 新建一个Test实例</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vars(obj)         <span class="comment"># 查看实例属性，没有任何实例属性</span></span><br><span class="line">&#123;&#125;                    <span class="comment"># 特性prop和类属性data都不在其中</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.data          <span class="comment"># 访问的是类属性</span></span><br><span class="line"><span class="string">'the class data attr'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.data = <span class="string">"bar"</span>  <span class="comment"># 添加实例属性，与类属性同名</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.data          <span class="comment"># 覆盖了类属性</span></span><br><span class="line"><span class="string">'bar'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vars(obj)         <span class="comment"># 现在有一个实例属性</span></span><br><span class="line">&#123;<span class="string">'data'</span>: <span class="string">'bar'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Test.data         <span class="comment"># 类属性的值并没有被改变</span></span><br><span class="line"><span class="string">'the class data attr'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Test.prop         <span class="comment"># 通过类访问特性prop，特性是类属性</span></span><br><span class="line">&lt;property object at <span class="number">0x000002BBD1963C78</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.prop          <span class="comment"># 通过实例访问特性prop</span></span><br><span class="line"><span class="string">'the prop value'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.prop = <span class="string">"foo"</span>  <span class="comment"># 没有定义set方法，所以不能对特性设置值，也不能像上面那样创建同名实例属性</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;input&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: can<span class="string">'t set attribute</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; obj.__dict__["prop"] = "foo"   # 创建也特性同名的普通实例属性，上一篇文章中用到了此法</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; vars(obj)         # 现在有两个实例属性</span></span><br><span class="line"><span class="string">&#123;'</span>data<span class="string">': '</span>ba<span class="string">r', '</span>prop<span class="string">': '</span>foo<span class="string">'&#125;</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; obj.prop          # 依然显示的是特性prop的值，而不是刚才设置的值</span></span><br><span class="line"><span class="string">'</span>the prop value<span class="string">'</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; Test.prop = "baz" # 这里不是调用特性的set方法，而是把特性给删除了，prop变为了str类型的类属性</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; obj.prop          # 访问普通实例属性prop，它不再被覆盖</span></span><br><span class="line"><span class="string">'</span>foo<span class="string">'</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; Test.data = property(lambda self: "the '</span>data<span class="string">' prop value")  # 将之前的类属性data变为特性</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; obj.data        # 之前这个属性覆盖了类属性，现在类属性变为了特性，于是这个实例属性被特性覆盖</span></span><br><span class="line"><span class="string">"the '</span>data<span class="string">' prop value"</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; del Test.data     # 删除这个特性</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; obj.data          # 实例属性不再被覆盖</span></span><br><span class="line"><span class="string">'</span>ba<span class="string">r'</span></span><br></pre></td></tr></table></figure>
<p>上述代码也展示了一个技巧：如果想添加与特性同名的实例属性，可以直接操作<code>__dict__</code>。</p>
<h2 id="特性删除操作">3.3 特性删除操作</h2>
<p>从<code>property</code>的签名可以看出，它的第三个参数是<code>fdel</code>，当删除特性时，就会调用它。虽然使用Python编程时不常删除属性，但Python为我们提供了删除方法<code>del</code>。以下是删除特性的一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码3.4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line"><span class="meta">... </span>    @property</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">"This is a"</span>)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">"a"</span>    </span><br><span class="line"><span class="meta">... </span>    @a.deleter</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">"Delete a"</span>)</span><br><span class="line"><span class="meta">... </span>       </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = Test()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t.a</span><br><span class="line">This <span class="keyword">is</span> a</span><br><span class="line"><span class="string">'a'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> t.a</span><br><span class="line">Delete a</span><br></pre></td></tr></table></figure>
<h2 id="特性的文档">3.4 特性的文档</h2>
<p><code>__doc__</code>属相相当于类或方法的使用说明，当用户需要了解某个类或方法时，Python会从这个属性获取值，并返回给用户。</p>
<p>从<code>property</code>的签名可以看出，它有一个参数<code>doc</code>，用于设置特性的<code>__doc__</code>属性。如果使用“经典”方法创建特性，我们可以手动传入这个参数。但如果使用的是装饰器方式，则<strong>读值方法</strong>的文档字符串将作为特性的文档。</p>
<h1 id="特性工厂函数">4. 特性工厂函数</h1>
<p>现在来定义一个特性工厂函数，实现特性的抽象。延续前面<code>Food</code>类的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quantity</span><span class="params">(name)</span>:</span>  <span class="comment"># 工厂函数，这个单词表示正数量。这个函数使用到了闭包</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">qty_getter</span><span class="params">(instance)</span>:</span>  <span class="comment"># 统一的get方法</span></span><br><span class="line">        <span class="keyword">return</span> instance.__dict__[name]  <span class="comment"># name是自由变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">qty_setter</span><span class="params">(instance, value)</span>:</span>  <span class="comment"># 统一的set方法</span></span><br><span class="line">        <span class="keyword">if</span> value &gt; <span class="number">0</span>:</span><br><span class="line">            instance.__dict__[name] = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"value must be &gt; 0"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> property(qty_getter, qty_setter)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Food</span>:</span></span><br><span class="line">    weight = quantity(<span class="string">"weight"</span>)  <span class="comment"># 同一单词重复输入了两次，这是特性工厂方式的一个不足，很难避免</span></span><br><span class="line">    price = quantity(<span class="string">"price"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, weight, price)</span>:</span></span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtotal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.weight * self.price</span><br></pre></td></tr></table></figure>
<p>当一个类中有多个属性采用相同的验证方法时(比如100个属性有50个都要求为正数)，使用此法可以节省大量代码。</p>
<h1 id="总结">5. 总结</h1>
<p>本篇内容并不多。首先我们介绍了特性<code>property</code>的常用方式，并引出了特性工厂的概念，但并没有马上展开这个概念，转而介绍特性本身的相关内容。最后，使用特性工厂函数改写了之前的<code>Food</code>类的代码。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python进阶</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python进阶</tag>
        <tag>特性</tag>
        <tag>property</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路38-动态创建属性</title>
    <url>/2018/06/23/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF38-%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<blockquote>
<p>《流畅的Python》笔记。</p>
<p>本篇主要讨论元编程中的动态创建属性。</p>
</blockquote>
<a id="more"></a>
<h1 id="前言">1. 前言</h1>
<p>平时我们一般把类中存储数据的变量称为属性，把类中的函数称为方法。但这两个概念其实是统一的，它们都称为属性(Attrubute)，方法只是可调用的属性，并且属性还是可以动态创建的。如果我们事先不知道数据的结构，或者在运行时需要再添加一些属性，此时就需要动态创建属性。</p>
<p>本文将讲述如果通过动态创建属性来读取JSON中的数据。第一个例子我们将实现一个<code>FrozenJSON</code>类，使用<code>__getattr__</code>方法，根据JSON文件中的数据项动态创建<code>FrozenJSON</code>实例的属性。第二个例子，更进一步，实现数据的关联查找，其中，会用到实例的<code>__dict__</code>属性来动态创建属性。</p>
<p>不过在这两部分内容之前，先来看一个简单粗暴地使用JSON数据的例子。</p>
<h1 id="json数据">2. JSON数据</h1>
<p>首先是一个现实世界中的JSON数据：OSCON大会的JSON数据。为了节省篇幅，只保留了它的数据格式中的一部分，数据内容也有所改变，原始数据会在用到的时候下载：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">"Schedule"</span>: &#123;</span><br><span class="line">    <span class="attr">"conferences"</span>: [&#123;<span class="attr">"serial"</span>: <span class="number">115</span>&#125;],</span><br><span class="line">    <span class="attr">"events"</span>: [&#123;</span><br><span class="line">        <span class="attr">"serial"</span>: <span class="number">33451</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"This is a test"</span>,</span><br><span class="line">        <span class="attr">"venue_serial"</span>: <span class="number">1449</span>,</span><br><span class="line">        <span class="attr">"speakers"</span>: [<span class="number">149868</span>]</span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="attr">"speakers"</span>: [&#123;</span><br><span class="line">        <span class="attr">"serial"</span>: <span class="number">149868</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Speaker1"</span>,</span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="attr">"venues"</span>: [&#123;</span><br><span class="line">        <span class="attr">"serial"</span>: <span class="number">1448</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"F151"</span>,</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>整个数据集是一个JSON对象，也是一个映射(map)，(最外层)只有一个键<code>"Schedule"</code>，它表示整个大会；<code>"Schedule"</code>的值也是一个map，这个map有4个键，分别是：</p>
<ul>
<li><code>"conferences"</code>，它只记录这场大会的编号；</li>
<li><code>"events"</code>，它表示大会中的每场演讲；</li>
<li><code>"speakers"</code>，它记录每个演讲者；</li>
<li><code>"venues"</code>，它表示演讲的地点，比如哪个会议室，哪个场所等。</li>
</ul>
<p>这4个键的值都是列表，而列表的元素又都是map，其中某些键的值又是列表。是不是很绕 :) ？</p>
<p>还需要注意一点：每条数据都有一个<code>"serial"</code>，相当于一个标识，后面会用到</p>
<h2 id="读取json数据">2.1 读取JSON数据</h2>
<p>读取JSON文件很简单，用Python自带的<code>json</code>模块就可以读取。以下是用于读取<code>json</code>的<code>load()</code>函数，如果数据不存在，它会自动从远端下载数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码2.1 osconfeed.py 注意这个模块名，后面还会用到</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"></span><br><span class="line">URL = <span class="string">"http://www.oreilly.com/pub/sc/osconfeed"</span></span><br><span class="line">JSON = <span class="string">"data/osconfeed.json"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(JSON):  <span class="comment"># 如果本地没有数据，则从远端下载</span></span><br><span class="line">        <span class="keyword">with</span> urlopen(URL) <span class="keyword">as</span> remote, open(JSON, <span class="string">"wb"</span>) <span class="keyword">as</span> local: <span class="comment"># 这里打开了两个上下文管理器</span></span><br><span class="line">            local.write(remote.read())</span><br><span class="line">    <span class="keyword">with</span> open(JSON) <span class="keyword">as</span> fp:</span><br><span class="line">        <span class="keyword">return</span> json.load(fp)</span><br></pre></td></tr></table></figure>
<h2 id="使用json数据">2.2 使用JSON数据</h2>
<p>现在我们来读取并使用上述JSON数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码2.2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> osconfeed <span class="keyword">import</span> load</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>feed = load()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>feed[<span class="string">'Schedule'</span>][<span class="string">'events'</span>][<span class="number">40</span>][<span class="string">'speakers'</span>]</span><br><span class="line">[<span class="number">3471</span>, <span class="number">5199</span>]</span><br></pre></td></tr></table></figure>
<p>从这个例子可以看出，要访问一个数据，得输入多少中括号和引号，为了跳出这些中括号和引号，又得浪费多少操作？如果再嵌套几个map......</p>
<p>在JavaScript中，可以通过<code>feed.Schedule.events[40].speakers</code>来访问数据，Python中也可以很容易实现这样的访问。这种方式，<code>"Schedule"</code>，<code>"events"</code>和<code>"speakers"</code>等数据项则表现的并不像map的键，而更像类的属性，因此，这种访问方式也叫做<strong>属性表示法</strong>。这在Java中有点像链式调用，但链式调用调用的是函数，而这里是数据属性。但为了方面，后面都同一叫做<strong>链式访问</strong>。</p>
<p>下面正式进入本篇的第一个主题：动态创建属性以读取JSON数据。</p>
<h1 id="frozenjson">3. FrozenJSON</h1>
<p>我们通过创建一个<code>FrozenJSON</code>类来实现动态创建属性，其中创建属性的工作交给了<code>__getattr__</code>特殊方法。这个类可以实现链式访问。</p>
<h2 id="初版frozenjson类">3.1 初版FrozenJSON类</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码3.1 explore0.py</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrozenJSON</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, mapping)</span>:</span></span><br><span class="line">        self.__data = &#123;&#125;  <span class="comment"># 为了安全，创建副本</span></span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> mapping.items(): <span class="comment"># 确保传入的数据能转换成字典；</span></span><br><span class="line">            <span class="keyword">if</span> keyword.iskeyword(key): <span class="comment"># 如果某些属性是Python的关键字，不适合做属性，</span></span><br><span class="line">                key += <span class="string">"_"</span>             <span class="comment"># 则在前面加一个下划线</span></span><br><span class="line">            self.__data[key] = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span> <span class="comment"># 当没有指定名称的属性时，才调用此法；name是str类型</span></span><br><span class="line">        <span class="keyword">if</span> hasattr(self.__data, name): <span class="comment"># 如果self.__data有这个属性，则返回这个属性</span></span><br><span class="line">            <span class="keyword">return</span> getattr(self.__data, name)</span><br><span class="line">        <span class="keyword">else</span>:   <span class="comment"># 如果self.__data没有指定的属性，创建FronzenJSON对象</span></span><br><span class="line">            <span class="keyword">return</span> FrozenJSON.build(self.__data[name]) <span class="comment"># 递归转换嵌套的映射和列表</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(cls, obj)</span>:</span>  </span><br><span class="line">        <span class="comment"># 必须要定义这个方法，因为JSON数据中有列表！如果数据中只有映射，或者在__init__中进行了</span></span><br><span class="line">        <span class="comment"># 类型判断，则可以不定义这个方法。</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(obj, abc.Mapping): <span class="comment"># 如果obj是映射，则直接构造</span></span><br><span class="line">            <span class="keyword">return</span> cls(obj)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(obj, abc.MutableSequence):</span><br><span class="line">            <span class="comment"># 如果obj是MutableSequence，则在本例中，obj则必定是列表，而列表的元素又必定是映射</span></span><br><span class="line">            <span class="keyword">return</span> [cls.build(item) <span class="keyword">for</span> item <span class="keyword">in</span> obj]</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 如果两者都不是，则原样返回</span></span><br><span class="line">            <span class="keyword">return</span> obj</span><br></pre></td></tr></table></figure>
<p>这个类非常的简单。由于没有定义任何数据属性，所以，在访问数据时，每次都会调用<code>__getattr__</code>特殊方法，并在这个方法中递归创建新实例，即，<strong>通过<code>__getattr__</code>特殊方法实现动态创建属性，通过递归构造新实例实现链式访问</strong>。</p>
<h2 id="使用frozenjson">3.2 使用FrozenJSON</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码3.2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> osconfeed <span class="keyword">import</span> load</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> explore0 <span class="keyword">import</span> FrozenJSON</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>raw_feed = load()  <span class="comment"># 读取原始JSON数据</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>feed = FrozenJSON(raw_feed)   <span class="comment"># 使用原始数据生成FrozenJSON实例</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(feed.Schedule.speakers)   <span class="comment"># 对应于FronzenJSON.__getattr__中if为False的情况</span></span><br><span class="line"><span class="number">357</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(feed.Schedule.keys())  <span class="comment"># 对应于FrozenJSON.__getattr__中if为True的情况</span></span><br><span class="line">[<span class="string">'conferences'</span>, <span class="string">'events'</span>, <span class="string">'speakers'</span>, <span class="string">'venues'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>feed.Schedule.speakers[<span class="number">-1</span>].name</span><br><span class="line"><span class="string">'Carina C. Zona'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>talk = feed.Schedule.events[<span class="number">40</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(talk)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">explore0</span>.<span class="title">FrozenJSON</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">talk</span>.<span class="title">name</span></span></span><br><span class="line"><span class="class">'<span class="title">There</span> *<span class="title">Will</span>* <span class="title">Be</span> <span class="title">Bugs</span>'</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">talk</span>.<span class="title">speakers</span></span></span><br><span class="line">[3471, 5199]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>talk.flavor   <span class="comment"># !!!</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">KeyError: <span class="string">'flavor'</span></span><br></pre></td></tr></table></figure>
<p>上述代码中，通过不断从<code>FrozenJSON</code>对象中创建<code>FrozenJSON</code>对象，实现了属性表示法。为了更好的理解上述代码，我们需要分析其中实例的创建过程：</p>
<p><code>feed</code>是一个<code>FrozenJSON</code>实例，当访问<code>Schedule</code>属性时，由于<code>feed</code>没有这个属性，于是调用<code>__getattr__</code>方法。由于<code>Schedule</code>也不是<code>feed.__data</code>的属性，所以需要再创建一个<code>FrozenJSON</code>对象。<code>Schedule</code>在JSON数据中是最外层映射的键，它的值<code>feed.__data["Schedule"]</code>又是一个映射，所以在<code>build</code>方法中，继续将<code>feed.__data["Schedule"]</code>包装成一个<code>FrozenJSON</code>对象。如果继续链接下去，还会创建<code>FrozenJSON</code>对象。这里之所以指出这一点，是想提醒大家<strong>注意每个<code>FrozenJSON</code>实例中的<code>__data</code>具体指的是JSON数据中的哪一部分数据</strong>(我在模拟这个递归过程的时候，多次都把<code>__data</code>搞混)。</p>
<p>上述代码中还有一处调用：<code>feed.Schedule.keys()</code>。<code>feed.Schedule</code>是一个<code>FrozenJSON</code>对象，它并没有<code>keys</code>方法，于是调用<code>__getattr__</code>，但由于<code>feed.Schedule.__data</code>是个<code>dict</code>，它有<code>keys</code>方法，所以这里并没有继续创建新的<code>FrozenJSON</code>对象。</p>
<p>注意最后一处调用：<code>talk.flavor</code>。JSON中<code>events</code>里并没有<code>flavor</code>数据项，因此这里抛出了异常。但这个异常是<code>KeyError</code>，而更合理的做法应该是：只要没有这个属性，都应该抛出<code>AttributeError</code>。如果要抛出<code>AttributeError</code>，<code>__getattr__</code>的代码长度将增加一倍，但这并不是本文的重点，所以没有处理。</p>
<h2 id="特殊方法__new__">3.3 特殊方法__new__</h2>
<p>在初版<code>FrozenJSON</code>中，我们定义了一个类方法<code>build</code>来创建新实例，但更方便也更符合Python风格的做法是定义<code>__new__</code>方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码3.3 frozenjson.py  新增__new__，去掉build，修改__getattr__</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrozenJSON</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        -- snip --</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 直接创建FrozenJSON对象</span></span><br><span class="line">            <span class="keyword">return</span> FrozenJSON(self.__data[name])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, arg)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(arg, abc.Mapping):</span><br><span class="line">            <span class="keyword">return</span> super().__new__(cls)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(arg, abc.MutableSequence):</span><br><span class="line">            <span class="keyword">return</span> [cls(item) <span class="keyword">for</span> item <span class="keyword">in</span> arg]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> arg</span><br></pre></td></tr></table></figure>
<p>不知道大家第一次看到“构造方法<code>__init__</code>”这个说法时有没有疑惑：这明明是初始化Initialize这个单词的缩写，将其称为“构造(create, build)”似乎不太准确呀？其实这个称呼是从其他语言借鉴过来的，它更应该叫做“初始化方法”，因为它确实执行的是初始化的工作，真正执行“构造”的是<code>__new__</code>方法。</p>
<p>一般情况下，当创建类的实例时，首先调用的是<code>__new__</code>方法，它必须创建并返回一个实例，然后将这个实例作为第一个参数(即<code>self</code>)传入<code>__init__</code>方法，再由<code>__init__</code>执行初始化操作。但也有不常见的情况：<code>__new__</code>也可以返回其他类的实例，此时，解释器不会继续调用<code>__init__</code>方法。</p>
<p><strong><code>__new__</code>方法是一个类方法</strong>，由于使用了特殊方法方式处理，所以它不用加<code>@classmethod</code>装饰器。</p>
<p>我们几乎不需要自行编写<code>__new__</code>方法，因为从<code>object</code>类继承的这个方法已经足够了。</p>
<p>使用<code>FrozenJSON</code>读取JSON数据的例子到此结束。</p>
<h1 id="record">4. Record</h1>
<p>上述<code>FrozenJSON</code>有个明显的缺点：查找有关联的数据很麻烦，必须从头遍历<code>Schedule</code>的相关数据项。比如<code>feed.Schedule.events[40].speakers</code>是一个含有两个元素的列表，它是这场演讲的演讲者们的编号。如果想访问演讲者的具体信息，比如姓名，我们不能直接调用<code>feed.Schedule.events[40].speakers[0].name</code>，这样会报<code>AttributeError</code>，只能根据<code>feed.Schedule.events[40].serial</code>在<code>feed.Schedule.speakers</code>中挨个查找。</p>
<p>为了实现这种关联访问，需要在读取数据时调整数据的结构：不再像之前<code>FrozenJSON</code>中那样，将整个JSON原始数据存到内部的<code>__data</code>中，而是<strong>将每条数据单独存到一个<code>Record</code>对象中</strong>(这里的“每条数据”指每个<code>event</code>，每个<code>speaker</code>，每个<code>venue</code>以及<code>conferences</code>中的唯一一条数据)。并且，还需要在每条数据的<code>serial</code>字段的值前面加上数据类型，比如某个<code>event</code>的<code>serial</code>为<code>123</code>，则将其变为<code>event.123</code>。</p>
<h2 id="要实现的功能">4.1 要实现的功能</h2>
<p>不过在给出实现方法之前，先来看看它应该具有的功能：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码4.1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> schedule <span class="keyword">import</span> Record, Event, load_db</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>db = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>load_db(db)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Record.set_db(db)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>event = Record.fetch(<span class="string">"event.33950"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>event</span><br><span class="line">&lt;schedule.Event object at <span class="number">0x000001DBC71E9CF8</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>event.venue</span><br><span class="line">&lt;schedule.Record object at <span class="number">0x000001DBC7714198</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>event.venue.name</span><br><span class="line"><span class="string">'Portland 251'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> spkr <span class="keyword">in</span> event.speakers:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"&#123;0.serial&#125;: &#123;0.name&#125;"</span>.format(spkr))</span><br><span class="line"><span class="meta">... </span>   </span><br><span class="line">speaker<span class="number">.3471</span>: Anna Martelli Ravenscroft</span><br><span class="line">speaker<span class="number">.5199</span>: Alex Martelli</span><br></pre></td></tr></table></figure>
<p>这其中包含了两个类，<code>Record</code>和继承自<code>Record</code>的<code>Event</code>，并将这些数据放到名为<code>db</code>的映射中。<code>Event</code>专门用于存JSON数据中<code>events</code>里的数据，其余数据全部存为<code>Record</code>对象。之所以这么安排，是因为原始数据中，<code>event</code>包含了<code>speaker</code>和<code>venue</code>的<code>serial</code>(相当于外键约束)。现在，我们可以通过<code>event</code>查找到与之关联的<code>speaker</code>和<code>venue</code>，而并不仅仅只是查找到这两个的<code>serial</code>。如果想根据<code>speaker</code>或<code>venue</code>查找<code>event</code>，大家可以根据后面的方法自行实现(但这么做得遍历整个<code>db</code>)。</p>
<h2 id="record-event">4.2 Record &amp; Event</h2>
<p>下面是这两个类以及调整数据结构的<code>load_db</code>函数的实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码4.2 schedule.py</span></span><br><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"><span class="keyword">import</span> osconfeed</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Record</span>:</span></span><br><span class="line">    __db = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        self.__dict__.update(**kwargs)  <span class="comment"># 在这里动态创建属性！</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_db</span><span class="params">(db)</span>:</span></span><br><span class="line">        Record.__db = db</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_db</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Record.__db</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fetch</span><span class="params">(cls, ident)</span>:</span>  <span class="comment"># 获取数据</span></span><br><span class="line">        db = cls.get_db()</span><br><span class="line">        <span class="keyword">return</span> db[ident]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Event</span><span class="params">(Record)</span>:</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">venue</span><span class="params">(self)</span>:</span></span><br><span class="line">        key = <span class="string">"venue.&#123;&#125;"</span>.format(self.venue_serial)</span><br><span class="line">        <span class="keyword">return</span> self.__class__.fetch(key)  <span class="comment"># 并不是self.fetch(key)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speakers</span><span class="params">(self)</span>:</span>  <span class="comment"># event对应的speaker的数据项保存在_speaker_objs属性中</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, <span class="string">"_speaker_objs"</span>): <span class="comment"># 如果没有speakers数据，则从数据集中获取</span></span><br><span class="line">            spkr_serials = self.__dict__[<span class="string">"speakers"</span>]  <span class="comment"># 首先获取speaker的serial</span></span><br><span class="line">            fetch = self.__class__.fetch</span><br><span class="line">            self._speaker_objs = [fetch(<span class="string">"speaker.&#123;&#125;"</span>.format(key)) <span class="keyword">for</span> key <span class="keyword">in</span> spkr_serials]</span><br><span class="line">        <span class="keyword">return</span> self._speaker_objs</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>Record</code>类中一个数据属性都没有，真正实现动态创建属性的是<code>__init__</code>方法中的<code>self.__dict__.update(**kwargs)</code>，其中<code>kwargs</code>是一个映射，在本例中，它就是每一个条JSON数据。</p>
<p>如果类中没有声明<code>__slots__</code>，实例的属性都会存到实例的<code>__dict__</code>中，<code>Record.__init__</code>方法展示的是一个流行的Python技巧，这种方法能快速地为实例添加大量属性。</p>
<p>在<code>Record</code>中还有一个类属性<code>__db</code>，它是数据集的引用，并不是数据集的副本。本例中，我们将数据放到了一个<code>dict</code>中，<code>__db</code>指向这个<code>dict</code>。其实也可以放到数据库中，然后<code>__db</code>存放数据库的引用。静态方法<code>get_db</code>和<code>set_db</code>则是设置和获取<code>__db</code>的方法。<code>fetch</code>方法是一个类方法，它用于从<code>__db</code>中获取数据。</p>
<p><code>Event</code>继承自<code>Record</code>，并添加了两个特性<code>venue</code>和<code>speakers</code>，也正是这两个特性实现了关联查找以及属性表示法。<code>venue</code>的实现很简单，因为一个<code>event</code>只对于一个<code>venue</code>，给<code>event</code>中的<code>venue_serial</code>添加一个前缀，然后查找数据集即可。</p>
<p><code>Event.speakers</code>的实现则稍微有点复杂：首先得清楚，这里查找的不是<code>speaker</code>的标识<code>serial</code>，而是查找<code>speaker</code>的具体数据项。查找到的数据项保存在<code>Event</code>实例的<code>_speaker_objs</code>中。一般在第一访问<code>event.speakers</code>时会进入到<code>if</code>中。还有情况就是<code>event._speakers_objs</code>被删除了。</p>
<p><code>Event</code>中还有一个值得注意的地方：调用<code>fetch</code>方法时，并不是直接<code>self.fetch</code>，而是<code>self.__class__.fetch</code>。这样做是为了避免一些很隐秘的错误：如果数据中有名为<code>fetch</code>的字段，这就会和<code>fetch</code>方法冲突，此时获取的就不是<code>fetch</code>方法，而是一个数据项。这种错误不易发觉，尤其是在动态创建属性的时候，如果数据不完全规则，几百几千条数据中突然有一条数据的某个属性名和实例的方法重名了，这个时候调试起来简直是噩梦。所以，除非能确保数据中一定不会有重名字段，否则建议按照本例中的写法。</p>
<h2 id="load_db">4.3 load_db()</h2>
<p>下面是加载和调整数据的<code>load_db()</code>函数的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码4.3，依然在schedule.py文件中</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_db</span><span class="params">(db)</span>:</span></span><br><span class="line">    raw_data = a.load()  <span class="comment"># 首先加载原始JSON数据</span></span><br><span class="line">    <span class="keyword">for</span> collection, rec_list <span class="keyword">in</span> raw_data[<span class="string">"Schedule"</span>].items(): <span class="comment"># 遍历Schedule中的数据</span></span><br><span class="line">        record_type = collection[:<span class="number">-1</span>]  <span class="comment"># 将Schedule中4个键名作为类型标识，去掉键名后面的's'</span></span><br><span class="line">        cls_name = record_type.capitalize()  <span class="comment"># 将类型名首字母大写作为可能的类名</span></span><br><span class="line">        <span class="comment"># 从全局作用域中获取对象；如果找不到所要的对象，则用Record代替</span></span><br><span class="line">        cls = globals().get(cls_name, Record) </span><br><span class="line">        <span class="comment"># 如果获取的对象是个类，且是Record的子类，则稍后用其创建实例；否则用Record创建实例</span></span><br><span class="line">        <span class="keyword">if</span> inspect.isclass(cls) <span class="keyword">and</span> issubclass(cls, Record):  </span><br><span class="line">            factory = cls</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            factory = Record</span><br><span class="line">        <span class="keyword">for</span> record <span class="keyword">in</span> rec_list:  <span class="comment"># 遍历Schedule中每个键对应的数据列表</span></span><br><span class="line">            key = <span class="string">"&#123;&#125;.&#123;&#125;"</span>.format(record_type, record[<span class="string">"serial"</span>])  <span class="comment"># 生成新的serial</span></span><br><span class="line">            record[<span class="string">"serial"</span>] = key  <span class="comment"># 这里是替换原有数据，而不是添加新数据！</span></span><br><span class="line">            db[key] = factory(**record)  <span class="comment"># 生成实例，并存入数据集中</span></span><br></pre></td></tr></table></figure>
<p>该函数是一个嵌套循环，最外层循环只迭代4次。每条数据都被包装为一个<code>Record</code>，且<code>serial</code>字段的值中添加了数据类型，这个新的<code>serial</code>也作为键和<code>Record</code>实例组成键值对存入<code>db</code>中。</p>
<h2 id="shelve">4.4 shelve</h2>
<p>前面说过，<code>db</code>可以从<code>dict</code>换成数据库的引用。Python标准库中则提供了一个现成的数据库类型<code>shelve.Shelf</code>。它是一个简单的键值对数据库，背后由<code>dbm</code>模块支持，具有如下特点：</p>
<ul>
<li><code>shelve.Shelf</code>是<code>abc.MutableMapping</code>的子类，提供了处理映射类型的重要方法；</li>
<li>他还提供了几个管理I/O的方法，比如<code>sync</code>和<code>close</code>；它也是一个上下文管理器；</li>
<li>键必须是字符串，值必须是<code>pickle</code>模块能处理的对象。</li>
</ul>
<p>本例中，它的用法和<code>dict</code>没有太大区别，以下是它的用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码4.4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> shelve</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>db = shelve.open(<span class="string">"data/schedule_db"</span>)  <span class="comment"># shelve.open方法返回一个shelve.Shelf对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> <span class="string">"conference.115"</span> <span class="keyword">not</span> <span class="keyword">in</span> db:  <span class="comment"># 这是一个简单的检测数据库是否加载的技巧，仅限本例</span></span><br><span class="line"><span class="meta">... </span>    load_db(db)  <span class="comment"># 如果是个空数据库，则向数据库中填充数据</span></span><br><span class="line"><span class="meta">... </span><span class="comment"># 中间的用法就和之前的dict没有区别了，不过最后需要记住调用close()关闭数据库连接</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>db.close() <span class="comment"># 建议在with块中访问db</span></span><br></pre></td></tr></table></figure>
<h1 id="record-vs-frozenjson">5. Record vs FrozenJSON</h1>
<p>如果不需要关联查询，那么<code>Record</code>只需要一个<code>__init__</code>方法，而且也不用定义<code>Event</code>类。这样的话，<code>Record</code>的代码将比<code>FrozenJSON</code>简单很多，那为什么之前<code>FrozenJSON</code>不这么定义呢？原因有两点:</p>
<ul>
<li><code>FrozenJSON</code>要递归转换嵌套的映射和列表，而<code>Record</code>类不需要这么做，因为所有的映射都被转换成了对应的<code>Record</code>，转换好的数据集中没有嵌套的映射和列表。</li>
<li>在<code>FrozenJSON</code>中，没有改动JSON数据的数据结构，因此，为了实现链式访问，需要将整个JSON数据存到内嵌的<code>__data</code>属性中。而在<code>Record</code>中，每条数据都被包装成了单个的<code>Record</code>，且对数据结构进行了重构。</li>
</ul>
<p>还有一点，本例中，使用映射来实现<code>Record</code>类或许更符合Python风格，但这样就无法展示动态属性编程的技巧和陷阱。</p>
<h1 id="总结">6. 总结</h1>
<p>我们通过两个例子说明了如何动态创建属性：第一个例子是在<code>FrozenJSON</code>中通过实现<code>__getattr__</code>方法动态创建属性，这个类还可以实现链式访问；第二个例子是通过创建<code>Record</code>和它的子类<code>Event</code>来实现关联查找，其中我们在<code>__init__</code>方法中通过<code>self.__dict__.update(**kw)</code>这个技巧实现批量动态创建属性。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python进阶</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python进阶</tag>
        <tag>元编程</tag>
        <tag>动态属性</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路37-使用asyncio包处理并发</title>
    <url>/2018/06/18/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF37-%E4%BD%BF%E7%94%A8asyncio%E5%8C%85%E5%A4%84%E7%90%86%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<blockquote>
<p>《流畅的Python》笔记。</p>
<p>本篇主要讨论asyncio包，这个包使用事件循环驱动的协程实现并发。</p>
</blockquote>
<a id="more"></a>
<h1 id="前言">1. 前言</h1>
<p>本篇主要介绍如果使用<code>asyncio</code>包将上一篇中线程版的“国旗下载”程序改为协程版本，通过异步非阻塞来实现并发。</p>
<p>说实话，我在读这部分内容的时候是懵逼的，书中阻塞非阻塞、同步异步的概念和我之前的理解有很大差异。之前一直以为同步就意味着阻塞，异步就意味着非阻塞。但其实，阻塞非阻塞与同步异步并没有本质的联系。</p>
<p><strong>同步(Synchronizing)异步(Asynchronizing)是对指令而言的</strong>，也就是程序(理解成“函数”会更好一些)。以含有I/O操作的函数为例(被调用方)，如果这个函数要等到I/O操作结束，获取了数据，才返回到调用方，这就叫同步(绝大部分函数都同步)；反之，不等I/O执行完毕就返回到调用方，获取的数据以其他方式转给调用方，这就叫异步。</p>
<p><strong>阻塞(Blocking)非阻塞(Non-Blocking)是对进程线程而言</strong>(为了简洁，只以“线程”为例)。因为某些原因(比如I/O)，线程被挂起(被移出CPU)，这就叫阻塞；反之，即使因为这些原因，线程依然不被挂起(不被移出CPU)，这就叫非阻塞。</p>
<p>可见，这两组概念一共可以组成四种不同情况：<strong>同步阻塞</strong>(常见)，<strong>同步非阻塞</strong>(不常见)，<strong>异步阻塞</strong>(不常见)，<strong>异步非阻塞</strong>(常见)。</p>
<p>仍以上述I/O函数为例：</p>
<ul>
<li>如果这个函数的I/O请求已发出，只是单纯地在等服务器发回数据，线程也只是单纯地在等这个函数返回结果，CPU将会把这个线程挂起，这就叫做<strong>同步阻塞</strong>；</li>
<li>如果这个函数中调用的是一个执行复杂计算的子函数，此时，函数依然在等结果没有返回，但线程并不是没有运行，不会被CPU挂起，这就叫做<strong>同步非阻塞</strong>(“CPU以轮询的方式查看I/O是否结束”更能说明这种情况，但这已是很古老的方式了)；</li>
<li>如果这个函数在I/O请求没得到结果之前就返回了，但线程依然在等这个结果(在函数体之外等待使用这个数据)，这就叫<strong>异步阻塞</strong>；</li>
<li>如果这个函数在没得到结果之前返回了，线程继续执行其他函数，这就叫做<strong>异步非阻塞</strong>。更具体一点，这种情况对应的是<strong>使用回调实现异步非阻塞</strong>的情况；而Python中还有一种情况，也是本篇要讲的，就是<strong>使用协程实现异步非阻塞</strong>：协程在得到结果前依然不返回，但线程并没有等待，而是去执行其他协程。协程看起来就像同步一样。</li>
</ul>
<p>由于之前并没有遇到代码世界中的<strong>同步非阻塞</strong>和<strong>异步阻塞</strong>这两种情况，所以我也不确定上述这两种情况的例子是否准确，欢迎大佬留言指导。但这四种情况在现实生活中就很常见了，下面举个在<a href="https://www.zhihu.com/question/19732473/answer/23434554" target="_blank" rel="noopener">某处</a>看到的例子：</p>
<ul>
<li>老张把一普通水壶接上水放火上，眼睛直勾勾盯着等水开，不干其他事，这叫<strong>同步阻塞</strong>；</li>
<li>老张依然用一普通水壶烧水，但把水壶放火上后去客厅看电视，时不时回来看水烧好了没有，这叫<strong>同步非阻塞</strong>；</li>
<li>老张用一能响的水壶烧水，没盯着看，但也没干其他事，只是在那儿发愣。水烧好后，壶可劲儿的响，老张一惊，取走水壶，这叫<strong>异步阻塞</strong>；</li>
<li>老张用一能响的水壶烧水，把壶放火上后去客厅看电视，等壶响了再去拿壶，这叫<strong>异步非阻塞</strong>；</li>
</ul>
<p>从这四个例子可以看出，阻不阻塞是对老张而言的，在计算机中对应的就是进程线程；同步异步是对水壶而言的，在计算机中对应的就是函数。</p>
<p>有了上述概念后，我们接下来将使用<code>asyncio</code>包，将之前下载国旗的程序改为协程版本。</p>
<h1 id="异步">2. 异步</h1>
<p><a href="http://www.vpointer.net/articles/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF36-%E4%BD%BF%E7%94%A8future%E5%A4%84%E7%90%86%E5%B9%B6%E5%8F%91/" target="_blank" rel="noopener">之前</a>我们使用线程实现了并发下载数据，它是同步阻塞的，因为一到I/O操作，线程就被阻塞，然后调入新的线程。现在，我们将实现一个异步非阻塞版本。但从上述介绍知道，<strong>异步有两种方式：回调和协程</strong>。本文并不会实现回调版本的“下载国旗”，提出回调只是为了和协程进行比较。</p>
<h2 id="回调">2.1 回调</h2>
<p>举个例子说明<strong>回调</strong>。在调用函数A时除了传入必要的参数外，还传入一个参数：函数B。A中有一些费时的操作，比如I/O，A在没得到结果之前就返回，而<strong>将等待结果以及进行后续处理的事情交给函数B</strong>。这个过程就是<strong>回调</strong>，函数B就称为<strong>回调函数</strong>。</p>
<p>这种编程方式不太符合人的思维习惯，代码也不易于理解，情况一复杂，就很可能遇到<strong>“回调地狱”</strong>：多层嵌套回调。下面是一个JavaScript中使用回调的例子，它嵌套了3层：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码2.1</span></span><br><span class="line">api_call1(request1, <span class="function"><span class="keyword">function</span> (<span class="params">response1</span>)</span>&#123;  <span class="comment">// 多么痛的领悟</span></span><br><span class="line">    <span class="keyword">var</span> request2 = step1(response1);  <span class="comment">// 第一步</span></span><br><span class="line">    api_call2(request2, <span class="function"><span class="keyword">function</span> (<span class="params">response2</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> request3 = step2(response2);  <span class="comment">// 第二步</span></span><br><span class="line">        api_call3(request3, <span class="function"><span class="keyword">function</span> (<span class="params">response3</span>)</span>&#123;</span><br><span class="line">            step(response3);  <span class="comment">// 第三步</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>api_call1</code>、<code>api_call2</code>和<code>api_call3</code>都是库函数，用于异步获取结果。JavaScript中常用匿名函数作为回调函数。下面我们使用Python来实现上述代码，上述三个匿名函数分别命名为<code>stage1</code>，<code>stage2</code>和<code>stage3</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码2.2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stage1</span><span class="params">(response1)</span>:</span></span><br><span class="line">    request2 = step1(response1)</span><br><span class="line">    api_call2(request2, stage2)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stage2</span><span class="params">(response2)</span>:</span></span><br><span class="line">    request3 = step2(response2)</span><br><span class="line">    api_call3(request3, stage3)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stage3</span><span class="params">(response3)</span>:</span></span><br><span class="line">    step3(response3)</span><br><span class="line"></span><br><span class="line">api_call1(request1, stage1)  <span class="comment"># 代码从这里开始执行</span></span><br></pre></td></tr></table></figure>
<p>可见，即使用Python写，也不容易理解，这要是再多嵌套几层，不逼疯已经不错了。而且，如果要在<code>stage2</code>中使用<code>request2</code>，还得使用闭包，这就又变成了嵌套定义函数的情况。并且上述代码还没有考虑抛出异常的情况：在基于回调的API中，这个问题的解决办法是为每个异步调用注册两个回调，一个用于处理操作成功时返回的结果，一个用于处理错误。可以看出，一旦涉及错误处理，回调将更可怕。</p>
<h2 id="协程">2.2 协程</h2>
<p>现在我们用协程来改写上述代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码2.3</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">three_stages</span><span class="params">(request1)</span>:</span></span><br><span class="line">    response1 = <span class="keyword">yield</span> <span class="keyword">from</span> api_call1(request1)</span><br><span class="line">    request2 = step1(response1)</span><br><span class="line">    response2 = <span class="keyword">yield</span> <span class="keyword">from</span> api_call2(request2)</span><br><span class="line">    request3 = step2(response2)</span><br><span class="line">    response3 = <span class="keyword">yield</span> <span class="keyword">from</span> api_call3(request3)</span><br><span class="line">    step3(response3)</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.create_task(three_stages(request1))</span><br></pre></td></tr></table></figure>
<p>与前面两个版本的回调相比，这个版本的代码将3个步骤依次写在同一函数中，易于理解，这样看起来是不是也更像同步函数？如果要处理异常，只需要相应的<code>yield from</code>语句处添加<code>try/except</code>即可。</p>
<p>但也别急着把这称为“协程天堂”，因为：</p>
<ul>
<li>不能使用常规函数，必须使用协程，而且要习惯<code>yield from</code>语句；</li>
<li>不能直接调用协程。即，不能像直接调用<code>api_call1(request1)</code>那样直接调用<code>three_stages(request1)</code>，必须使用事件循环(上面的<code>loop</code>)来驱动协程。</li>
</ul>
<p>但不管怎样，代码读起来和写起来比回调简单多了，尤其是嵌套回调。</p>
<p><strong><em>小技巧</em></strong>：读协程的代码时，为了便于理解代码的意思，可以直接将<code>yield from</code>关键字忽略掉。</p>
<h2 id="下载国旗批量版">2.3 下载国旗批量版</h2>
<p>下面我们开始实现协程版本的“下载国旗”。</p>
<p>为了将其改为协程版本，我们不能使用之前的<code>requests</code>包，因为它会阻塞线程，改为使用<code>aiohttp</code>包。为了尽量保持代码的简洁，这里不处理异常。下方是完整的代码，代码中我们使用了新语法。以下代码的基本思路是：<strong>在一个单线程程序中使用主循环一次激活队列中的协程，各个协程向前执行几步，然后把控制权让给主循环，主循环再激活队列中的下一个协程</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码2.4</span></span><br><span class="line"><span class="keyword">import</span> aiohttp, os, sys, time, asyncio   <span class="comment"># 代码中请勿这么写，这里只是为了减少行数</span></span><br><span class="line"></span><br><span class="line">POP20_CC = (<span class="string">"CN IN US ID BR PK NG BD RU JP MX PH VN ET EG DE IR TR CD FR"</span>).split()</span><br><span class="line">BASE_URL = <span class="string">"http://flupy.org/data/flags"</span></span><br><span class="line">DEST_DIR = <span class="string">"downloads/"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_flag</span><span class="params">(img, filename)</span>:</span></span><br><span class="line">    path = os.path.join(DEST_DIR, filename)</span><br><span class="line">    <span class="keyword">with</span> open(path, <span class="string">"wb"</span>) <span class="keyword">as</span> fp: </span><br><span class="line">        fp.write(img)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(text)</span>:</span></span><br><span class="line">    print(text, end=<span class="string">" "</span>)</span><br><span class="line">    sys.stdout.flush()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_flag</span><span class="params">(cc)</span>:</span>   <span class="comment"># aiohttp只支持TCP和UDP请求</span></span><br><span class="line">    url = <span class="string">"&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif"</span>.format(BASE_URL, cc=cc.lower())</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session: <span class="comment"># &lt;1&gt; 开启一个会话</span></span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> resp:   <span class="comment"># 发送请求</span></span><br><span class="line">            image = <span class="keyword">await</span> resp.read()   <span class="comment"># 读取请求</span></span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">download_one</span><span class="params">(cc)</span>:</span></span><br><span class="line">    image = <span class="keyword">await</span> get_flag(cc)</span><br><span class="line">    show(cc)</span><br><span class="line">    save_flag(image, cc.lower() + <span class="string">".gif"</span>)</span><br><span class="line">    <span class="keyword">return</span> cc</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list)</span>:</span></span><br><span class="line">    loop = asyncio.get_event_loop()   <span class="comment"># 获取事件循环</span></span><br><span class="line">    to_do = [download_one(cc) <span class="keyword">for</span> cc <span class="keyword">in</span> sorted(cc_list)]  <span class="comment"># 生成协程列表</span></span><br><span class="line">    wait_coro = asyncio.wait(to_do)   <span class="comment"># 将协程包装成Task类，wait_coro并不是运行结果！而是协程！</span></span><br><span class="line">    res, _ = loop.run_until_complete(wait_coro) <span class="comment"># 驱动每个协程运行</span></span><br><span class="line">    loop.close()   <span class="comment"># 循环结束</span></span><br><span class="line">    <span class="keyword">return</span> len(res)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(download_many)</span>:</span></span><br><span class="line">    t0 = time.time()</span><br><span class="line">    count = download_many(POP20_CC)</span><br><span class="line">    elapsed = time.time() - t0</span><br><span class="line">    msg = <span class="string">"\n&#123;&#125; flags downloaded in &#123;:.2f&#125;s"</span></span><br><span class="line">    print(msg.format(count, elapsed))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main(download_many)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">VN TR FR DE IN ID RU NG CN EG BR MX PH CD IR PK ET JP BD US </span><br><span class="line"><span class="number">20</span> flags downloaded <span class="keyword">in</span> <span class="number">1.27</span>s</span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong></p>
<p>①这里使用了新的语法<code>async/await</code>。再Python3.5之前，如果想定义一个协程只能延用函数的定义方式<code>def</code>，然后在定义体里面使用<code>yield</code>或<code>yield from</code>。如果想把一个函数更明确地声明为协程(或者说异步函数)，还可以使用<code>asyncio</code>中的<code>coroutine</code>装饰器，但这么做是不是挺麻烦的？从Python3.5起，可以明确<strong>使用<code>async</code>来定义协程(异步函数)</strong>和异步生成器。使用<code>async</code>则可以省略掉<code>@asyncio.coroutine</code>装饰器；在用<code>async</code>修饰的协程的定义体中可以使用<code>yield</code>关键字，但不能使用<code>yield from</code>，它必须被替换为<code>await</code>，即使<code>yield from</code>后面只是一个普通的生成器；从由<code>async修饰</code>的协程或生成器中获取数据时，必须使用<code>await</code>。</p>
<p>②如果要使用<code>@asyncio.coroutine</code>装饰器明确声明协程，那么在协程定义体内部只能使用<code>yield from</code>，不能使用<code>yield</code>，因为使用到<code>yield</code>的地方已经在<code>asyncio</code>中全部封装成了函数或者方法。最新版的<code>@asyncio.coroutine</code>也可以装饰<code>async</code>修饰的协程，这种情况下<code>coroutine</code>不做任何事，只是原封不动的返回被装饰的协程。</p>
<p>③ &lt;1&gt;处的代码之所以改用<code>async with</code>(异步上下文管理器)，是因为新版<code>asyncio</code>并不支持书中的旧语法<code>yield from aiohttp.request("GET", url)</code>。关于<code>async/await</code>，<code>async with/async for</code>的相关内容将在后续文章中介绍，这里只需要知道<code>async</code>对应于<code>@asyncio.coroutine</code>，<code>await</code>对应于<code>yield from</code>即可。</p>
<p>④我们将<code>get_flag</code>改成了协程版本，并使用<code>aiohttp</code>来实现异步请求；<code>download_one</code>函数也随之变成了协程版本。</p>
<p>⑤<code>download_many</code>只是一个普通函数，它要驱动协程运行。在这个函数中，我们通过<code>asyncio.get_event_loop()</code>创建事件循环(实质就是一个线程)来驱动协程的运行。接着生成含20个<code>download_one</code>协程的协程列表<code>to_do</code>，随后再调用<code>asyncio.wait(to_do)</code>将这个协程列表包装成<strong>一个</strong><code>wait</code>协程，取名为<code>wait_coro</code>。<code>wait</code>协程会将<code>to_do</code>中所有的协程包装成<code>Task</code>对象(<code>Future</code>的子类)，再形成列表。最后，我们通过<code>loop.run_until_complete(wait_coro)</code>驱动协程<code>wait_coro</code>运行。<strong>整个的驱动链是这样的：<code>loop.run_until_complete</code>驱动协程<code>wait_coro</code>，<code>wait_coro</code>再在内部驱动20个协程。</strong></p>
<p>⑥<code>wait</code>协程最后会返回一个元组，第一个元素是<strong>完成的协程数</strong>，第二个是<strong>未完成的协程数</strong>，<code>loop.run_until_complete</code>返回<strong>传入的协程的返回值</strong>(实际代码是Future.result())。有点绕，其实就是<code>wait_coro</code>最后返回一个元组给<code>run_until_complete</code>，<code>run_until_complete</code>再把这个值返回给调用方。</p>
<p>⑦在<a href="http://www.vpointer.net/articles/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF36-%E4%BD%BF%E7%94%A8future%E5%A4%84%E7%90%86%E5%B9%B6%E5%8F%91/" target="_blank" rel="noopener">上一篇</a>中，我们知道<code>concurrent.futures</code>中有一个<code>Future</code>，且通过它的<code>result</code>方法获取最后运行的结果；在<code>asyncio</code>包中，不光有<code>Future</code>，还有它的子类<code>Task</code>，但获取结果通常并不是调用<code>result</code>方法，而是通过<code>yield from</code>或<code>await</code>，即<code>yield from future</code>获取结果。<code>asyncio.Future</code>类的<code>result</code>方法没有参数，不能设置超时时间；如果调用<code>result</code>时<code>future</code>还未运行完毕，它并不会阻塞去等待结果，而是抛出<code>asyncio.InvalidStateError</code>异常。</p>
<h2 id="下载国旗改进版">2.4 下载国旗改进版</h2>
<p><a href="http://www.vpointer.net/articles/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF36-%E4%BD%BF%E7%94%A8future%E5%A4%84%E7%90%86%E5%B9%B6%E5%8F%91/" target="_blank" rel="noopener">上一篇</a>中，我们除了使用<code>Executor.map()</code>批量处理线程之外，我们还使用了<code>concurrent.futures.as_completed()</code>挨个迭代运行完的线程返回的结果。<code>asyncio</code>也实现了这个方法，我们将使用这个函数改写上方的代码。</p>
<p>还有一个问题：我们往往只关注了网络I/O请求，常常忽略本地的I/O操作。线程版本中的<code>save_flag</code>函数也是会阻塞线程的，因为它操作了磁盘。但由于图片太小，速度太快，我们感觉并不明显，如果换成更高像素的图片，这种速度差异就会很明显。我们将会以某种方式使其避免阻塞线程。下面是改写的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码2.5</span></span><br><span class="line"><span class="keyword">import</span> asyncio, os, sys, time, aiohttp</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">download_one</span><span class="params">(cc, semaphore)</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> semaphore:</span><br><span class="line">        image = <span class="keyword">await</span> get_flag(cc)</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_in_executor(<span class="literal">None</span>, save_flag, image, cc + <span class="string">".gif"</span>)</span><br><span class="line">    <span class="keyword">return</span> cc</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">download_coro</span><span class="params">(cc_list, concur_req)</span>:</span></span><br><span class="line">    semaphore = asyncio.Semaphore(concur_req)  <span class="comment"># 它是一个信号量，用于控制并发量</span></span><br><span class="line">    to_do = [download_one(cc, semaphore) <span class="keyword">for</span> cc <span class="keyword">in</span> sorted(cc_list)]</span><br><span class="line">    to_do_iter = asyncio.as_completed(to_do)</span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> to_do_iter:</span><br><span class="line">        res = <span class="keyword">await</span> future</span><br><span class="line">        print(<span class="string">"Downloaded"</span>, res)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list, concur_req)</span>:</span>  <span class="comment"># 变化不大</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    coro = download_coro(cc_list, concur_req)</span><br><span class="line">    loop.run_until_complete(coro)</span><br><span class="line">    loop.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    t0 = time.time()</span><br><span class="line">    download_many(POP20_CC, <span class="number">1000</span>)  <span class="comment"># 第二个参数表示最大并发数</span></span><br><span class="line">    print(<span class="string">"\nDone! Time elapsed &#123;:.2f&#125;s."</span>.format(time.time() - t0))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">Downloaded BD</span><br><span class="line">Downloaded CN</span><br><span class="line">-- snip --</span><br><span class="line">Downloaded US</span><br><span class="line"></span><br><span class="line">Done! Time elapsed <span class="number">1.21</span>s.</span><br></pre></td></tr></table></figure>
<p>上述代码有3个地方值得关注：</p>
<ul>
<li><code>asyncio.as_completed()</code>以<strong>元素为协程的可迭代对象</strong>为参数，但自身并不是协程，只是一个<strong>生成器</strong>。它在内部将传入的协程包装成<code>Task</code>，然后返回一个生成器，产出协程的返回值。这个生成器按协程<strong>完成的顺序</strong>生成值(先完成先产出)，而<strong>不是</strong>按协程在迭代器中的顺序生成值。</li>
<li><code>asyncio.Semaphore</code>是个信号量类，内部维护这一个计数器，调用它的<code>acquire</code>方法(这个方法是个协程)，计数器减一；对其调用<code>release</code>方法(这个方法不是协程)，计数器加一；当计数器为0时，会阻塞调用这个方法的协程。</li>
<li>我们将<code>save_flag</code>函数放到了其他线程中，<code>loop.run_in_executor()</code>的第一个参数是<code>Executor</code>实例，如果为<code>None</code>，则使用事件循环的默认<code>ThreadPoolExecutor</code>实例。余下的参数是可调用对象，以及可调用对象的位置参数。</li>
</ul>
<h1 id="总结">3. 总结</h1>
<p>本章开篇介绍了阻塞非阻塞、同步异步的概念，然后介绍了异步的两种实现方式：回调和协程。并通过代码比较了回调和协程的实现方式。然后我们使用<code>asyncio</code>和<code>aiohttp</code>两个库，将之前线程版本的下载国旗程序改为了协程版本。可惜我也是刚接触协程不久，写的内容不一定准确，尤其是关于<code>asyncio</code>的内容，这个库之前是一点都没接触过。后面我会专门研究Python中的协程，以及<code>asyncio</code>的实现，争取把这部分内容彻底搞懂。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python进阶</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python进阶</tag>
        <tag>并发</tag>
        <tag>asyncio</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路36-使用future处理并发</title>
    <url>/2018/06/16/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF36-%E4%BD%BF%E7%94%A8future%E5%A4%84%E7%90%86%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<blockquote>
<p>《流畅的Python》笔记。</p>
<p>本篇主要讨论concurrent.futures模块，并用它实现一个简单的并发操作。</p>
</blockquote>
<a id="more"></a>
<h1 id="前言">1. 前言</h1>
<p>我们都知道，如果有大量数据要处理，或者要处理大量链接，异步操作会比顺序操作快很多。Python中，<code>concurrent</code>和<code>asyncio</code>则是标准库中进行了高度封装的两个异步操作包。它们在底层使用了Python提供的更基础的两个模块，分别是<code>multiprocessing</code>和<code>threading</code>。</p>
<p><code>future</code>(全小写)并不具体指某个类的实例，而且笔者查了老多资料也没看到哪个类叫做<code>future</code>，它泛指用于异步操作的对象。<code>concurrent.futures</code>和<code>asyncio</code>这两个模块中有两个名为<code>Future</code>的类：<code>concurrent.futures.Future</code>和<code>asyncio.Future</code>。这两个类的作用相同，都表示<strong>可能已经完成或尚未完成的延迟计算</strong>。这两个<code>Future</code>的实例并不应该由我们手动创建，而应交由并发框架(也就是前面那两个模块)来实例化。</p>
<p>本篇主要介绍<code>concurrent.futures</code>模块的简单使用，并会将其和顺序计算进行对比，其中还会涉及GIL和阻塞型I/O的概念。<code>asyncio</code>将在下一篇进行介绍。</p>
<h1 id="顺序执行">2. 顺序执行</h1>
<p>首先实现一个下载各国国旗的程序，随后再将它与并发版本进行对比。以下是顺序执行的版本，它下载人口前20的国家的国旗，并保存到本地：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码2.1，flags.py</span></span><br><span class="line"><span class="keyword">import</span> os, time, sys  <span class="comment"># 这么引用只是为了节省篇幅，并不提倡</span></span><br><span class="line"><span class="keyword">import</span> requests  <span class="comment"># 第三方库</span></span><br><span class="line"></span><br><span class="line">POP20_CC = (<span class="string">"CN IN US ID BR PK NG BD RU JP MX PH VN ET EG DE IR TR CD FR"</span>).split()</span><br><span class="line"><span class="comment"># 如果想测试自己的并发程序，为了避免被误认为是DOS攻击，请自建http服务</span></span><br><span class="line">BASE_URL = <span class="string">"http://flupy.org/data/flags"</span>  </span><br><span class="line">DEST_DIR = <span class="string">"downloads/"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_flag</span><span class="params">(img, filename)</span>:</span>  <span class="comment"># 保存图片到本地</span></span><br><span class="line">    path = os.path.join(DEST_DIR, filename)</span><br><span class="line">    <span class="keyword">with</span> open(path, <span class="string">"wb"</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        fp.write(img)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_flag</span><span class="params">(cc)</span>:</span>   <span class="comment"># 请求图片</span></span><br><span class="line">    url = <span class="string">"&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif"</span>.format(BASE_URL, cc=cc.lower())</span><br><span class="line">    resp = requests.get(url)</span><br><span class="line">    <span class="keyword">return</span> resp.content</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(text)</span>:</span>  <span class="comment"># 每获取一张图片就给出一个提示</span></span><br><span class="line">    print(text, end=<span class="string">" "</span>)</span><br><span class="line">    sys.stdout.flush()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_one</span><span class="params">(cc)</span>:</span>   <span class="comment"># 下载一张图片</span></span><br><span class="line">    image = get_flag(cc)</span><br><span class="line">    show(cc)</span><br><span class="line">    save_flag(image, cc.lower() + <span class="string">".gif"</span>)</span><br><span class="line">    <span class="keyword">return</span> cc   <span class="comment"># 这个return主要是给后面的并发程序用的，此处不要这行代码也可以</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list)</span>:</span>   <span class="comment"># 下载多张图片</span></span><br><span class="line">    <span class="keyword">for</span> cc <span class="keyword">in</span> sorted(cc_list):</span><br><span class="line">        download_one(cc)</span><br><span class="line">    <span class="keyword">return</span> len(cc_list)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(download_many)</span>:</span>   <span class="comment"># 主程序，接收一个函数为参数</span></span><br><span class="line">    t0 = time.time()   <span class="comment"># 开始时间</span></span><br><span class="line">    count = download_many(POP20_CC)</span><br><span class="line">    elapsed = time.time() - t0   <span class="comment"># 结束时间</span></span><br><span class="line">    msg = <span class="string">"\n&#123;&#125; flags downloaded in &#123;:.2f&#125;s"</span></span><br><span class="line">    print(msg.format(count, elapsed))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main(download_many)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">BD BR CD CN DE EG ET FR ID IN IR JP MX NG PH PK RU TR US VN </span><br><span class="line"><span class="number">20</span> flags downloaded <span class="keyword">in</span> <span class="number">14.83</span>s   <span class="comment"># 耗时，只做了一次</span></span><br></pre></td></tr></table></figure>
<h1 id="concurrent.futures">3. concurrent.futures</h1>
<p>现在我们用<code>concurrent.futures</code>模块将上述代码改写为线程版本，使其异步执行，其中有大部分函数延用上述代码。</p>
<h2 id="futures.as_completed">3.1 futures.as_completed</h2>
<p>首先实现一个更具有细节的版本，我们手动提交线程，然后再运行。这个版本只是为了讲述细节，所以并没有全部下载，最大线程数也没有设置得很高：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码3.1，flags_threadpool.py</span></span><br><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line"><span class="keyword">from</span> flags <span class="keyword">import</span> save_flag, get_flag, download_one, show, main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many_ac</span><span class="params">(cc_list)</span>:</span></span><br><span class="line">    cc_list = cc_list[:<span class="number">5</span>] <span class="comment"># 只下载前五个用于测试</span></span><br><span class="line">    <span class="keyword">with</span> futures.ThreadPoolExecutor(len(cc_list) / <span class="number">2</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        to_do = &#123;&#125;   <span class="comment"># 有意写出字典，其实也可以是列表或集合，但这是个惯用方法</span></span><br><span class="line">        <span class="keyword">for</span> cc <span class="keyword">in</span> sorted(cc_list):</span><br><span class="line">            future = executor.submit(download_one, cc)</span><br><span class="line">            to_do[future] = cc</span><br><span class="line">            msg = <span class="string">"Scheduled for &#123;&#125;: &#123;&#125;"</span></span><br><span class="line">            print(msg.format(cc, future))</span><br><span class="line">        results = []</span><br><span class="line">        <span class="keyword">for</span> future <span class="keyword">in</span> futures.as_completed(to_do):</span><br><span class="line">            res = future.result()</span><br><span class="line">            msg = <span class="string">"&#123;&#125; result: &#123;!r&#125;"</span></span><br><span class="line">            print(msg.format(future, res))</span><br><span class="line">            results.append(res)</span><br><span class="line">        <span class="keyword">return</span> len(results)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main(download_many_ac)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">Scheduled <span class="keyword">for</span> BR: &lt;Future at <span class="number">0x1cbca5ab0f0</span> state=running&gt;</span><br><span class="line">Scheduled <span class="keyword">for</span> CN: &lt;Future at <span class="number">0x1cbcb339b00</span> state=running&gt;</span><br><span class="line">Scheduled <span class="keyword">for</span> ID: &lt;Future at <span class="number">0x1cbcb3490f0</span> state=running&gt;</span><br><span class="line">Scheduled <span class="keyword">for</span> IN: &lt;Future at <span class="number">0x1cbcb349748</span> state=pending&gt;</span><br><span class="line">Scheduled <span class="keyword">for</span> US: &lt;Future at <span class="number">0x1cbcb3497f0</span> state=pending&gt;</span><br><span class="line">CN &lt;Future at <span class="number">0x1cbcb339b00</span> state=finished returned str&gt; result: <span class="string">'CN'</span></span><br><span class="line">BR &lt;Future at <span class="number">0x1cbca5ab0f0</span> state=finished returned str&gt; result: <span class="string">'BR'</span></span><br><span class="line">IN &lt;Future at <span class="number">0x1cbcb349748</span> state=finished returned str&gt; result: <span class="string">'IN'</span></span><br><span class="line">US &lt;Future at <span class="number">0x1cbcb3497f0</span> state=finished returned str&gt; result: <span class="string">'US'</span></span><br><span class="line">ID &lt;Future at <span class="number">0x1cbcb3490f0</span> state=finished returned str&gt; result: <span class="string">'ID'</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span> flags downloaded <span class="keyword">in</span> <span class="number">2.39</span>s  <span class="comment"># 20个一起下载只需要1.6s左右</span></span><br></pre></td></tr></table></figure>
<p><strong>解释</strong>：</p>
<ul>
<li>在<code>concurrent.futures</code>中有一个名为<code>Executor</code>的抽象基类，由它定义执行异步操作的接口。在这个模块中有它的两个具体类：的<code>ThreadPoolExecutor</code>和<code>ProcessPoolExecutor</code>，前者是线程，后者是进程。<code>Executor</code>的第一个参数指定最大运行线程数。</li>
<li><code>Executor.submit(func, *args, **kwargs)</code>方法会在线程中执行<code>func(*args, **kwargs)</code>，它将这个方法<strong>封装成<code>Future</code>对象并返回</strong>(假设这个实例叫做<code>future</code>)。<code>submit</code>方法会对<code>future</code>进行排期，如果运行的线程数没达到最大线程数，则<code>future</code>会被<strong>立即运行</strong>，并将其状态置为<code>running</code>；否则就<strong>等待</strong>，并将其状态置为<code>pending</code>。<strong>这同时也表明，线程在<code>submit</code>方法中启动</strong>。</li>
<li><code>futures.as_completed</code>函数的第一个参数是一个<code>future</code>序列，在内部会被转换成<code>set</code>。它返回一个迭代器，在<code>future</code>运行结束后产出<code>future</code>。在使用这个函数时还有一个惯用方法：将<code>future</code>放到一个字典中。因为<code>as_completed</code>返回的<code>future</code>的顺序不一定是传入时的顺序，使用字典可以很轻松的做一些后续处理。</li>
<li>上述代码中，从第31-35行的最开始两个字母是由<code>show</code>函数输出的。光看上述结果，会让人觉得线程是在<code>as_completed</code>中启动的，而之所以结果输出得这么整齐，是因为<code>for</code>循环里只是“提交”，实际运行是在线程中。如果在每次循环最后都执行<code>sleep(2)</code>，你将会看到这样的结果： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码3.2</span></span><br><span class="line">Scheduled <span class="keyword">for</span> BR: &lt;Future at <span class="number">0x13e6b30b2b0</span> state=running&gt;</span><br><span class="line">BR Scheduled <span class="keyword">for</span> CN: &lt;Future at <span class="number">0x13e6b5820b8</span> state=running&gt;</span><br><span class="line">CN Scheduled <span class="keyword">for</span> ID: &lt;Future at <span class="number">0x13e6c099278</span> state=running&gt;</span><br><span class="line">-- snip --</span><br></pre></td></tr></table></figure></li>
<li><code>concurrent.futures.Future</code>有一个<strong><code>result</code>方法，它返回<code>future</code>中可调用对象运行完成后的结果，或者重新抛出可调用对象运行时的异常</strong>。如果<code>future</code>还未运行完成，调用<code>future.result()</code>将<strong>阻塞调用方所在的线程</strong>，直到有结果可返回；它还可以接受一个<code>timeout</code>参数用于指定运行时间，如果在<code>timeout</code>时间内<code>future</code>没有运行完毕，将抛出<code>TimeoutError</code>异常。</li>
</ul>
<h2 id="executor.map">3.2 Executor.map</h2>
<p>在<code>代码3.1</code>中，我们自行提交线程，其实，上述可改为更简洁的版本：使用<code>Executor.map</code>批量提交，只需要新建一个<code>download_many</code>函数，其余不变：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码3.3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> futures.ThreadPoolExecutor(len(cc_list)) <span class="keyword">as</span> executor:</span><br><span class="line">        res = executor.map(download_one, sorted(cc_list))</span><br><span class="line">    <span class="keyword">return</span> len(list(res))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">JP RUBR  EG CN VN BD TR FR ID NG DE IN PK ET PH IR US CD MX </span><br><span class="line"><span class="number">20</span> flags downloaded <span class="keyword">in</span> <span class="number">1.69</span>s</span><br></pre></td></tr></table></figure>
<p><code>Executor.map()</code>方法和内置的<code>map</code>函数类似，它将第一个参数(可调用对象)映射到第二个参数(可迭代对象)的每一个元素上以创建<code>Future</code>列表。<code>Executor.map()</code>方法内部也是通过调用<code>Future.submit</code>来创建<code>Future</code>对象。</p>
<h2 id="比较">3.3 比较</h2>
<p>从上面代码可以看出，虽然使用<code>Executor.map()</code>的代码量比较少，但<code>Executor.submit()</code>和<code>futures.as_completed()</code>的组合更灵活。</p>
<p><code>Executor.map()</code>更适合于需要批量处理的情况，比如同一函数(或者可调用对象)不同参数。而<code>Executor.submit()</code>则更适合于零散的情况，比如不同函数同一参数，不同函数不同参数，甚至两个线程毫无关联。</p>
<h1 id="补充">4. 补充</h1>
<p>本文主体部分已经结束，下面是一些补充。</p>
<h2 id="io密集型和gil">4.1 I/O密集型和GIL</h2>
<p>CPython本身并不是线程安全的，因此有全局解释器锁(Global Interpreter Lock, GIL)，一次只允许使用一个线程执行Python字节码。</p>
<p>以这个为基础，按理说上述所有代码将都不能并行下载，因为一次只能运行一个线程，并且线程版本的运行时间应该比顺序版本的还要多才对(线程切换耗时)。但结果也表明，两个线程版本的耗时都大大降低了。</p>
<p>这是因为，Python标准库中所有执行阻塞型I/O操作的函数，在等待操作系统返回结果时都会释放GIL。这就意味着，GIL几乎对I/O密集型处理并没有什么影响，依然可以使用多线程。</p>
<h2 id="cpu密集型">4.2 CPU密集型</h2>
<p><code>concurrent.futures</code>中还有一个<code>ProcessPoolExecutor</code>类，它实现的是真正的<strong>并行计算</strong>。它和<code>ThreadPoolExecutro</code>一样，继承自<code>Executor</code>，两者实现了共同的接口，因此使用<code>concurrent.futures</code>编写的代码可以轻松地在线程版本与进程版本之间转换，比如要讲上述代码改为进程版本，只需更改<code>download_many()</code>中的一行代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码3.4</span></span><br><span class="line"><span class="keyword">with</span> futures.ThreadPoolExecutor(len(cc_list)) <span class="keyword">as</span> executor:</span><br><span class="line"><span class="comment"># 改为：</span></span><br><span class="line"><span class="keyword">with</span> futures.ProcessPoolExecutor() <span class="keyword">as</span> executor:</span><br></pre></td></tr></table></figure>
<p>也可以指定进程数，但默认是<code>os.cpu_count()</code>的返回值，即电脑的CPU核心数。</p>
<p>这个类非常适合于CPU密集型作业上。使用这个类实现的上述代码虽然比线程版本慢一些，但依然比顺序版本快很多。</p>
<h2 id="进度条">4.3 进度条</h2>
<p>如果你用最新版<code>pip</code>下载过第三方库，你会发现在下载时会有一个文字进度条。在Python中想要实现这种效果可以使用第三方库<code>tqdm</code>，以下是它的一个简单用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码3.5</span></span><br><span class="line"><span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tqdm.tqdm(range(<span class="number">1000</span>)):</span><br><span class="line">    sleep(<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line"> <span class="number">40</span>%|████      |  <span class="number">400</span>/<span class="number">1000</span> [<span class="number">00</span>:<span class="number">10</span>&lt;<span class="number">00</span>:<span class="number">00</span>, <span class="number">98.11</span>it/s]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python进阶</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python进阶</tag>
        <tag>future</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路35-协程</title>
    <url>/2018/06/12/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF35-%E5%8D%8F%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>《流畅的Python》笔记。</p>
<p>本篇主要讨论一个与生成器看似无关，但实际非常相关的概念：协程。</p>
</blockquote>
<a id="more"></a>
<h1 id="前言">1. 前言</h1>
<p>说到协程(Coroutine)，如果是刚接触Python不久的新手，估计第一个反应是：懵逼，这是个什么玩意儿？有一点基础的小伙伴可能会想到进程和线程。</p>
<p>其实，<strong>和子程序（或者说函数）一样，协程也是一种程序组件</strong>。Donald Knuth曾经说过，<strong>子程序是协程的特例</strong>。我们都知道，一个子程序就是一次函数调用，它只有一个入口和一个出口：调用者调用子程序，子程序运行完毕，将结果返回给调用者。而<strong>协程则是多入口和多出口的子程序</strong>：调用者可以不止一个，执行过程中<strong>可以暂停</strong>，输出结果也可以不止一个。</p>
<p>协程和进程、线程也是有关系的：为了实现并发，高效利用系统资源，于是有了<strong>进程</strong>；为了实现更高的并发，以及减小进程切换时的上下文开销，于是有了<strong>线程</strong>；但即便线程切换时的开销小了，如果线程数量一多(比如10K个)，这时的上下文切换也不可小觑，于是在线程中加入了协程(这里之所以是“加入”，是因为协程的概念出现得比线程要早)。协程运行在一个线程当中，不会发生线程的切换，并且，它的启停可以由用户自行控制。由于协程在一个线程中运行，所以在共享资源时不需要加锁。</p>
<p><strong><em>补充</em></strong>：以后有机会单独出一篇详细介绍进程、线程和协程的文章。</p>
<h1 id="迭代器生成器和协程">2. 迭代器、生成器和协程</h1>
<p>这三者本不应该放在一起，之所以放在一起，是因为生成器将迭代器和协程联系了起来，或者说<code>yield</code>关键字将这三者联系了起来：生成器可以作为迭代器，生成器又是协程比不可少的组成部分。<strong>但千万不要把迭代器用作协程，也别把协程用作迭代器！这两者并不应该存在关系。</strong></p>
<p><code>yield</code>关键字背后的机制很强大，它不仅能向用户提供数据，还能从用户那里获取数据。而<strong>迭代器、生成器和协程这三个概念其实是对<code>yield</code>关键字用法的取舍</strong>：</p>
<ul>
<li><strong>凡是含有关键字<code>yield</code>或者<code>yield from</code>的函数都是生成器</strong>，不管你是用来干啥；</li>
<li>如果<strong>只是用<code>yield</code>来生成数据</strong>，或者说向用户提供数据，那么这个生成器可以看做<strong>迭代器</strong>(<strong>用作迭代器的生成器</strong>)；</li>
<li>如果还想<strong>用<code>yield</code>来获取外部的数据</strong>，实现双向数据交换，那么这个生成器可看做<strong>协程</strong>(<strong>用作协程的生成器</strong>)。</li>
</ul>
<p>这里先列举出迭代器和协程在代码上最直观的区别：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码2.1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_iter</span><span class="params">()</span>:</span> <span class="comment"># 用作迭代器的生成器</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;  <span class="comment"># 作为迭代器，yield关键字后面会跟一个数据</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;  <span class="comment"># 且不关心yield的返回值，没有赋值语句</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_co</span><span class="params">()</span>:</span> <span class="comment"># 用作协程的生成器</span></span><br><span class="line">    x = <span class="keyword">yield</span>    <span class="comment"># 这种写法表示希望从用户处获取数据，而不向用户提供数据(其实提供的是None)</span></span><br><span class="line">    y = <span class="keyword">yield</span> <span class="number">1</span>  <span class="comment"># 这种写法表示既向用户提供数据，也希望得到用户的反馈</span></span><br></pre></td></tr></table></figure>
<h1 id="协程">3. 协程</h1>
<p>本节主要包括协程的运行过程，协程的4个状态，协程的预激，协程的终止和异常处理，协程的返回值。</p>
<h2 id="协程的运行">3.1 协程的运行</h2>
<p>协程本身有4个状态(其实就是生成器的4个状态)，可以使用<code>inspect.getgeneratorstate()</code>函数来确定：</p>
<ul>
<li><code>GEN_CREATED</code>：等待开始执行；</li>
<li><code>GEN_RUNNING</code>：解释器正在执行，多线程时能看到这个状态；</li>
<li><code>GEN_SUSPENDED</code>：在<code>yield</code>表达式处暂停时的状态；</li>
<li><code>GEN_CLOSED</code>：执行结束。</li>
</ul>
<p>下面通过一个简单的例子来说明这四个状态以及协程的运行过程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码3.1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">simple_coro</span><span class="params">(a)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"Started a ="</span>, a)</span><br><span class="line"><span class="meta">... </span>    b = <span class="keyword">yield</span> a</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"Received b ="</span>, b)</span><br><span class="line"><span class="meta">... </span>    c = <span class="keyword">yield</span> a + b</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"End with c="</span>, c)</span><br><span class="line"><span class="meta">... </span>   </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> inspect <span class="keyword">import</span> getgeneratorstate</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro = simple_coro(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getgeneratorstate(my_coro)</span><br><span class="line"><span class="string">'GEN_CREATED'</span>       <span class="comment"># 刚创建的协程所处的状态，这时协程还没有被激活</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(my_coro)   <span class="comment">### 第一次调用next()叫做预激，这一步非常重要！ ###</span></span><br><span class="line">Started a = <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&gt;&gt;&gt; getgeneratorstate(my_coro)</span><br><span class="line"><span class="string">'GEN_SUSPENDED'</span>     <span class="comment"># 在yield表达式处暂停时的状态</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro.send(<span class="number">2</span>) <span class="comment"># 通过.send()方法将用户的数据传给协程</span></span><br><span class="line">Received b = <span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro.send(<span class="number">3</span>)</span><br><span class="line">End <span class="keyword">with</span> c= <span class="number">3</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;input&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration       <span class="comment"># 协程(生成器)结束，抛出StopIteration</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getgeneratorstate(my_coro)</span><br><span class="line"><span class="string">'GEN_CLOSED'</span>        <span class="comment"># 协程结束后的状态</span></span><br></pre></td></tr></table></figure>
<p><strong><em>解释</em></strong>：</p>
<ul>
<li>刚创建的协程并没有激活，对协程的第一次<code>next()</code>调用就是<strong>预激</strong>，这一步<strong>非常重要</strong>，它将运行到第一<code>yield</code>表达式处并暂停。对于没有预激的协程，在调用<code>.send(value)</code>时，如果<code>value</code>不是<code>None</code>，解释器将抛出异常。<strong>对于预激，既可以调用<code>next()</code>函数，也可以<code>.send(None)</code></strong>(此时会被特殊处理)。但对于<code>yield from</code>来说则不用预激，它会自动预激。</li>
<li><code>.send()</code>方法实现了用户和协程的交互。<code>yield</code>是一个表达式(上述代码中等号的右边)，它的默认返回值是<code>None</code>，如果用户通过<code>.send(value)</code>传入了参数<code>value</code>，那么这个值将作为协程<strong>暂停处</strong>的<code>yield</code>表达式的返回值。</li>
<li><strong>协程的运行过程</strong>：也可以叫做生成器的运行过程。从上一篇中我们知道，调用<code>next()</code>函数或<code>.send()</code>方法时，协程会运行到下一个<code>yield</code>表达式处并暂停。具体来说，比如上述代码中的<code>b = yield a</code>，代码其实是停在等号的右边，<code>yield a</code>这个表达式还没有返回，只是把<code>a</code>传给了用户，但还没有计算出<code>yield a</code>表达式的返回值，<code>b</code>因此也没有被赋值。当代码再次运行时，等号右边的<code>yield a</code>表达式才返回值，并将这个值赋给<code>b</code>。如果通过<code>next()</code>函数让协程继续运行，则上一个暂停处的<strong><code>yield</code>表达式</strong>将返回<strong>默认值</strong><code>None</code>(<code>b = None</code>)；如果通过<code>.send(value)</code>让协程继续运行，则上一个<code>yield</code>表达式将返回<code>value</code>(<code>b = value</code>)。这也解释了<strong>为什么要预激协程</strong>：如果没有预激，也就没有<code>yield</code>表达式与传入的<code>value</code>相对应，自然也就抛出异常。</li>
</ul>
<h2 id="终止协程和异常处理">3.2 终止协程和异常处理</h2>
<p>协程中没处理的异常会向上冒泡，传给<code>next()</code>函数或<code>.send()</code>方法的调用方。不过，我们也可以通过<code>.throw()</code>方法手动抛出异常，还可以通过<code>.close()</code>方法手动结束协程：</p>
<ul>
<li><code>generator.throw(exc_type[, exc_value[, traceback]])</code>：让生成器在暂停的<code>yield</code>表达式处抛出指定的异常。如果生成器处理了这个异常，代码会向前执行到下一个<code>yield</code>表达式<code>yield a</code>，并将生成的<code>a</code>作为<code>generator.throw()</code>的返回值。如果生成器没有处理抛出的异常，则会向上冒泡，并且生成器会终止，状态转换成<code>GEN_CLOSED</code>。</li>
<li><code>generator.close()</code>：使生成器在暂停处的<code>yield</code>表达式处抛出<code>GeneratorExit</code>异常。如果生成器没有处理这个异常，或者处理时抛出了<code>StopIteration</code>异常，<code>.close()</code>方法直接返回，且不报错；如果处理<code>GeneratorExit</code>时抛出了非<code>StopIteration</code>异常，则向上冒泡。</li>
</ul>
<h2 id="返回值">3.3 返回值</h2>
<p>从上一篇和本篇的代码中，不知道大家发现了一个现象没有：所有的生成器最后都没有写<code>return</code>语句。这其实是有原因的，因为在Python3.3之前，如果生成器返回值，解释器会报语法错误。现在则不会报错了，但返回的值并不是像普通函数那样可以直接接收：Python解释器会把这个返回值绑定到生成器最后抛出的<code>StopIteration</code>异常对象的<code>value</code>属性中。示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码3.2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="string">"This is a test"</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = test()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(t)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(t)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;input&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration: This <span class="keyword">is</span> a test   <span class="comment"># StopIteration有了附加信息</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = test()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(t)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>   next(t)</span><br><span class="line"><span class="meta">... </span><span class="keyword">except</span> StopIteration <span class="keyword">as</span> si:</span><br><span class="line"><span class="meta">... </span>    print(si.value)  <span class="comment"># 获取返回的值</span></span><br><span class="line">...</span><br><span class="line">This <span class="keyword">is</span> a test</span><br></pre></td></tr></table></figure>
<h2 id="预激协程的装饰器">3.4 预激协程的装饰器</h2>
<p>从前文我们知道，如果要使用协程，必须要预激。可以手动通过调用<code>next()</code>函数或者<code>.send(None)</code>方法。但有时我们会忘记手动预激，此时，我们可以使用装饰器来自动预激协程，这个装饰器如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码3.3</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coroutine</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">primer</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        gen = func(*args, **kwargs)</span><br><span class="line">        next(gen)</span><br><span class="line">        <span class="keyword">return</span> gen</span><br><span class="line">    <span class="keyword">return</span> primer</span><br></pre></td></tr></table></figure>
<p>提前预激的生成器只能和<code>yield</code>兼容，不能和<code>yield from</code>兼容，因为<code>yield from</code>会自动预激。所以请确定你的生成器要不要被放在<code>yield from</code>之后。</p>
<h1 id="yield-from">4. yield from</h1>
<p>上一篇文章说到，对于嵌套生成器，使用<code>yield from</code>能减少很多代码，比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码4.1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">y2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">y1</span><span class="params">()</span>:</span>  <span class="comment"># y1只要是个可迭代对象就行</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="comment"># 第一种写法</span></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> y1():</span><br><span class="line">        <span class="keyword">yield</span> y</span><br><span class="line">    <span class="comment"># 第二种写法</span></span><br><span class="line">    <span class="comment"># yield from y1()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> y2():</span><br><span class="line">        print(y)</span><br></pre></td></tr></table></figure>
<p>第二种写法明显比第一种简洁。这是<code>yield from</code>的一个作用：简化嵌套循环。<strong><code>yield from</code>后面还可以跟任意可迭代对象，并不是只能跟生成器</strong>。</p>
<p><code>yield from</code>最重要的作用是起到了<strong>类似通道的作用</strong>：<strong>它能让客户端代码和子生成器之间进行数据交换</strong>。</p>
<p>这里有几个术语需要先解释一下：</p>
<ul>
<li><p><strong>委派生成器</strong>：包含<code>yield from &lt;iterable&gt;</code>表达式的生成器函数。</p></li>
<li><p><strong>子生成器</strong>：上述的<code>&lt;iterable&gt;</code>部分就是子生成器。<code>&lt;iterable&gt;</code>也可以是委派生成器，以此类推下去，形成一个链条，但这个链条最终以一个只使用<code>yield</code>表达式的简单生成器结束。</p></li>
<li><p><strong>调用方</strong>：调用委派生成器的代码或对象叫做调用方。为了避免歧异，我们把最外层的代码，也就是调用第一层委派生成器的代码叫做<strong>客户端代码</strong>。</p></li>
</ul>
<p>比如上述代码，按照没有<code>yield from</code>语句的写法，如果客户端代码想通过<code>y2.send(value)</code>向<code>y1</code>传值，<code>value</code>只能传到<code>y2</code>这一层，如果想再传入<code>y1</code>，将要写大量复杂的代码。下面是<code>yield from</code>的说明图：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1528873772/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF35-%E5%8D%8F%E7%A8%8B/yield_from.jpg" /></p>
<p>结合上图，可做如下总结：</p>
<ul>
<li><code>yield from</code>和<code>yield</code>在使用上并无太大区别；</li>
<li>委派生成器也是生成器。当第一次对委派生成器调用<code>next()</code>或<code>.send(None)</code>时，委派生成器会执行到第一个<code>yield from</code>表达式并暂停。当客户端继续调用委派生成器的<code>.send()</code>，<code>.throw()</code>和<code>.close()</code>等方法时，会“直接”作用到最内层的子生成器上，而不是让委派生成器的代码继续向前执行。只有当子生成器抛出<code>StopIteration</code>异常后，委派生成器中的代码才继续执行，并将<code>StopIteration.value</code>的值作为<code>yield from</code>表达式的返回值。</li>
</ul>
<h2 id="补充可跳过">补充(可跳过)</h2>
<p>这一小节是<code>yield from</code>的逻辑伪代码实现，代码较为复杂，看不懂也没什么关系，可以跳过，也可直接看最后的总结，并不影响<code>yield from</code>的使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码4.2 ### "RESULT = yield from EXPR"语句的等效代码 ###</span></span><br><span class="line">_i = iter(EXPR)  <span class="comment"># 得到EXPR的迭代器</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    _y = next(_i)  <span class="comment"># 预激！还没有向客户端生成值</span></span><br><span class="line"><span class="keyword">except</span> StopIteration <span class="keyword">as</span> _e:  <span class="comment"># 如果_i抛出了StopIteration异常</span></span><br><span class="line">    _r = _e.value  <span class="comment"># _i的最后的返回值。这不是最后的生成值！</span></span><br><span class="line"><span class="keyword">else</span>:  <span class="comment"># 如果调用next(_i)一切正常</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:   <span class="comment"># 这是一个无限循环</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            _s = <span class="keyword">yield</span> _y  <span class="comment"># 向客户端发送子生成器生成的值，然后暂停</span></span><br><span class="line">        <span class="keyword">except</span> GeneratorExit <span class="keyword">as</span> _e:  <span class="comment"># 如果客户端调用.throw(GeneratorExit)，或者调用close方法</span></span><br><span class="line">            <span class="keyword">try</span>:  <span class="comment"># 首先尝试获取_i的close方法，因为_i不一定是生成器，普通迭代器不会实现close方法</span></span><br><span class="line">                _m = _i.close   </span><br><span class="line">            <span class="keyword">except</span> AttributeError:</span><br><span class="line">                <span class="keyword">pass</span>  <span class="comment"># 没有获取到close方法，什么也不做</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                _m()  <span class="comment"># 如果获取到了close方法，则调用子生成器的close方法</span></span><br><span class="line">            <span class="keyword">raise</span> _e  <span class="comment"># 最后不管怎样，都向上抛出GeneratorExit异常</span></span><br><span class="line">        <span class="keyword">except</span> BaseException <span class="keyword">as</span> _e:  <span class="comment"># 如果客户端通过throw()传入其它异常</span></span><br><span class="line">            _x = sys.exc_info()  <span class="comment"># 获取错误信息</span></span><br><span class="line">            <span class="keyword">try</span>: <span class="comment"># 尝试获取_i的throw方法，理由和上面的情况一样</span></span><br><span class="line">                _m = _i.throw  </span><br><span class="line">            <span class="keyword">except</span> AttributeError:  <span class="comment"># 如果没有这个方法</span></span><br><span class="line">                <span class="keyword">raise</span> _e            <span class="comment"># 则向上抛出用户传入的异常</span></span><br><span class="line">            <span class="keyword">else</span>:                   <span class="comment"># 如果_i有throw方法，即它是一个子生成器</span></span><br><span class="line">                <span class="keyword">try</span>:                </span><br><span class="line">                    _y = _m(*_x)    <span class="comment"># 尝试调用子生成器的throw方法</span></span><br><span class="line">                <span class="keyword">except</span> StopIteration <span class="keyword">as</span> _e:</span><br><span class="line">                    _r = _e.value   <span class="comment"># 如果子生成器抛出StopIteration，获取返回的值</span></span><br><span class="line">                <span class="keyword">break</span>               <span class="comment"># 并且跳出循环</span></span><br><span class="line">        <span class="keyword">else</span>:    <span class="comment"># 如果在生成器生成值时没有异常发生</span></span><br><span class="line">            <span class="keyword">try</span>: <span class="comment"># 试验证用户通过.send()方法传入的值</span></span><br><span class="line">                <span class="keyword">if</span> _s <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 如果传入的是None</span></span><br><span class="line">                    _y = next(_i)  <span class="comment"># 则尝试调用next()，向前继续执行</span></span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># 如果传入的不是None，则尝试调用子生成器的send方法</span></span><br><span class="line">                    _y = _i.send(_s)</span><br><span class="line">                    <span class="comment"># 如果子生成器没有send方法，则向上报AttributeError</span></span><br><span class="line">            <span class="keyword">except</span> StopIteration <span class="keyword">as</span> _e: <span class="comment"># 如果子生成器抛出了StopIteration</span></span><br><span class="line">                _r = _e.value           <span class="comment"># 获取子生成器返回的值</span></span><br><span class="line">                <span class="keyword">break</span>                   <span class="comment"># 并跳出循环，回复委派生成器的运行</span></span><br><span class="line">RESULT = _r <span class="comment"># _r就是yield from EXPR最终的返回值，将其赋予RESULT</span></span><br></pre></td></tr></table></figure>
<p>从上面这么长一串代码可以看出，如果没有<code>yield from</code>，而我们又想向最内层的子生成器传值，这得多麻烦。下面总结出几点<code>yield from</code>的特性：</p>
<ul>
<li><p>所有的“直接”其实都是间接的，都是一层一层传下去，或者一层一层传上来的，只是我们感觉是直接的而已；</p></li>
<li><p>调用<code>.send(value)</code>将值传给委派生成器时，如果<code>value</code>是<code>None</code>，则调用子生成器的<code>__next__</code>方法；否则，调用子生成器的<code>.send(value)</code>；</p></li>
<li><p>当对委派生成器调用<code>.throw()</code>，委派生成器会先确定子生成器有没有<code>.throw()</code>方法，如果有，则调用，如果没有，则向上抛出<code>AttributeError</code>异常；</p></li>
<li><p>当客户端调用委派生成器的<code>.throw(GeneratorExit)</code>或者<code>.close()</code>方法时，委派生成器也会先确定子生成器有没有<code>.close()</code>方法，如果有，则调用子生成器的<code>.close()</code>方法，由<strong>子生成器</strong>来抛出<code>GeneratorExit</code>异常，委派生成器将这个异常向上<strong>传递</strong>；如果子类没有<code>.close()</code>方法，则<strong>委派生成器</strong>直接抛出<code>GeneratorExit</code>异常。Python解释器会捕获这个异常，但不会显示异常信息。</p></li>
<li><p>只要子生成器抛出<code>StopIteration</code>异常，不管是用户通过<code>.throw</code>方法传递的，还是子生成器运行结束时抛出的，都会导致委派生成器继续向前执行。</p></li>
</ul>
<h1 id="协程计算均值">5. 协程计算均值</h1>
<p>在《Python学习之路26》中，我们分别用类和闭包来实现了平均值的计算，现在，作为本章最后一个例子，我们使用协程来实现平均值的计算，其中还会用到<code>yield from</code>和生成器的返回值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码5.1</span></span><br><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">()</span>:</span></span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    average = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        term = <span class="keyword">yield</span></span><br><span class="line">        <span class="keyword">if</span> term <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        total += term</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        average = total / count</span><br><span class="line">    <span class="keyword">return</span> average</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grouper</span><span class="params">(results, key)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  <span class="comment"># 每个循环都会新建averager</span></span><br><span class="line">        results[key] = <span class="keyword">yield</span> <span class="keyword">from</span> averager()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(data)</span>:</span></span><br><span class="line">    results = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> key, values <span class="keyword">in</span> data.items():</span><br><span class="line">        group = grouper(results, key)  <span class="comment"># 每个循环都会新建grouper</span></span><br><span class="line">        next(group)  <span class="comment"># 激活</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> values:</span><br><span class="line">            group.send(value)</span><br><span class="line">        <span class="comment"># 此句非常重要，否则不会执行到averager()中的return语句，也就得不到最终的返回值</span></span><br><span class="line">        group.send(<span class="literal">None</span>)  </span><br><span class="line"></span><br><span class="line">    print(results)</span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">"list1"</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="string">"list2"</span>: [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">&#123;<span class="string">'list1'</span>: <span class="number">3.0</span>, <span class="string">'list2'</span>: <span class="number">8.0</span>&#125;</span><br></pre></td></tr></table></figure>
<p>不知道大家看到这段代码的时候有没有什么疑问。当笔者看到<code>grouper()</code>委派生成器里的<code>While True:</code>时，非常疑惑：为啥要加个<code>While</code>循环呢？如果按这个版本，我们在<code>main</code>中的<code>for</code>循环后检测<code>group</code>的状态，会发现它是<code>GEN_SUSPENDED</code>，这笔者的强迫症就犯了，怎么能不是<code>GEN_CLOSED</code>呢？！而且这个版本每当执行完<code>group.send(None)</code>后，在<code>grouper()</code>中又会创建新的<code>averager</code>，然后当<code>main</code>中<code>group</code>更新后，上一个<code>grouper</code>(也就是刚新建了<code>averager</code>的<code>grouper</code>)由于引用数为0，又被回收了。刚新建一个<code>averager</code>就被回收，这不多此一举吗？于是笔者将代码改成了如下形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码5.2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grouper</span><span class="params">(results, key)</span>:</span> <span class="comment"># 去掉了循环</span></span><br><span class="line">    results[key] = <span class="keyword">yield</span> <span class="keyword">from</span> averager()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(data)</span>:</span></span><br><span class="line">    results = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> key, values <span class="keyword">in</span> data.items():</span><br><span class="line">        -- snip --</span><br><span class="line">        <span class="keyword">try</span>: <span class="comment"># 手动捕获异常</span></span><br><span class="line">            group.send(<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>
<p>写出来后发现代码并没有之前的简洁，但至少<code>group</code>最后变成了<code>GEN_CLOSED</code>状态。至于最后怎么取舍就看各位了。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python进阶</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python进阶</tag>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路34-迭代器和生成器</title>
    <url>/2018/06/08/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF34-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<blockquote>
<p>《流畅的Python》笔记。</p>
<p>本章将说明Python中迭代器和生成器的运行原理。</p>
</blockquote>
<a id="more"></a>
<h1 id="前言">1. 前言</h1>
<p>如果做严格区分，迭代器(iterator)和生成器(generator)是两个概念。迭代器是用于从集合中挨个获取元素，要求数据已存在；而生成器则是“凭空”生成元素，最典型的就是斐波那契数列。但是在Python中，大多数时候迭代器和生成器被视作同一概念。从Python2.2开始，可以使用<code>yield</code>关键字构建生成器，其作用和迭代器一样。在Python3中，生成器有了更广泛的用途，比如<code>range()</code>函数返回的就是一个类似生成器的对象，而在以前，它返回的是完整的列表。</p>
<p>本篇将有如下内容：</p>
<ul>
<li><code>iter()</code>内置函数处理可迭代对象的方式</li>
<li>如何使用Python实现经典的迭代器模式</li>
<li>详细说明生成器函数的工作原理</li>
<li>如何使用生成器函数或生成器表达式代替经典的迭代器</li>
<li>如何使用<code>yield from</code>语句合成生成器</li>
</ul>
<h1 id="可迭代对象与迭代器">2. 可迭代对象与迭代器</h1>
<h2 id="iter函数">2.1 iter()函数</h2>
<p>当Python解释器需要迭代对象<code>x</code>时，会自动调用<code>iter(x)</code>。内置的<code>iter()</code>函数的运行过程如下：</p>
<ul>
<li>检查对象是否实现了<code>__iter__</code>方法，如果实现了就调用它来获取一个迭代器；</li>
<li>如果没有实现<code>__iter__</code>方法，但实现了<code>__getitem__</code>方法，Python会创建一个迭代器，尝试从索引0开始获取元素；</li>
<li>如果上述操作都失败了，Python抛出<code>TypeError</code>异常，通常会提示<code>“T object is not iterable”</code>，其中<code>T</code>是目标对象所属的类。</li>
</ul>
<p>而从上述解释可以看出，任何Python序列都可迭代的原因是，它们都实现了<code>__getitem__</code>方法。但<code>iter()</code>函数之所以要检查<code>__getitem__</code>方法，除了能让更多对象可迭代之外，其实还为了向下兼容。至于<code>iter()</code>以后还检不检查<code>__getitem__</code>方法就很难说了（不过目测未来很长一段时间内应该不会改变这种策略），而标准的序列类型都实现了<code>__iter__</code>方法，所以，如果自定义类要实现可迭代，请实现<code>__iter__</code>方法。</p>
<p>由此，我们还可得出<strong>可迭代的对象</strong>的定义：</p>
<p><strong>实现了<code>__iter__</code>方法，能获取迭代器；或者实现了<code>__getitem__</code>方法，能从零开始索引的对象都是可迭代的对象。</strong></p>
<p><strong><em>补充</em></strong>：</p>
<ul>
<li><p>从Python3.4开始，检查对象<code>x</code><strong>能否迭代</strong>，最准确的方法是：调用<code>iter(x)</code>，如果不可迭代，再处理<code>TypeError</code>异常。这比使用<code>isinstance(x, abc.Iterable)</code>更准确，因为<code>abc.Iterable</code>不会考虑<code>__getitem__</code>方法。</p></li>
<li><p><code>iter()</code>函数还有一个鲜为人知的用法，即：传入两个参数，使用常规的函数或任何可调用对象创建迭代器。此时，第一个参数必须是可调用对象，第二个参数是“哨兵”。当可调用对象返回的值与“哨兵”相等时，抛弃该值，结束迭代并抛出<code>StopIteration</code>异常。这种用法的一个实际情况就是读取文件，当读取到空行或文件末尾时，停止读取：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码2.1</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"test.txt"</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> iter(fp.readline, <span class="string">"\n"</span>):</span><br><span class="line">        process_line(line)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="迭代器">2.2 迭代器</h2>
<p>首先需要明确可迭代对象和迭代器之间的关系：<strong>Python从可迭代对象中获取迭代器</strong>。当对象实现了<code>__iter__</code>方法时，Python从它获取迭代器；当对象只实现了<code>__getitem__</code>方法时，Python为这个对象创建迭代器。所以，<strong>Python在迭代时始终用的是迭代器！</strong></p>
<p>标准迭代器的UML继承关系图如下：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1528360661/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF33-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/Iterable_Iterator.png" /></p>
<p>从上图以及之前的描述，我们可以总结出以下几点：</p>
<ul>
<li><strong>具体的可迭代对象</strong>的<code>__iter__</code>方法应该返回一个<strong>具体的迭代器</strong>；</li>
<li><strong>具体的迭代器</strong>必须实现<code>__next__</code>和<code>__iter__</code>方法。<code>__iter__</code>方法返回迭代器本身(<code>return self</code>)；真正的迭代操作由<code>__next__</code>完成，当没有可迭代元素时，它还要抛出<code>StopIteration</code>异常；</li>
<li>由于迭代器也是从<code>Iterable</code>派生出来的，所以，<strong>迭代器是可迭代对象！</strong></li>
</ul>
<p>从上述内容可以猜出，应该有一个<code>next()</code>函数与<code>iter()</code>函数配对。没错，对可迭代对象的具体迭代操作就是由<code>next()</code>函数完成。以下是两个迭代过程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码2.2</span></span><br><span class="line">s = <span class="string">"ABC"</span></span><br><span class="line"><span class="comment"># 方法1，Python会隐式创建迭代器，并捕获StopIteration异常</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">    print(char)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2，显式创建迭代器并显式迭代，此时需要手动捕获StopIteration异常</span></span><br><span class="line">it = iter(s)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(next(it))</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">del</span> it</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>如果我们要实现<strong>具体的迭代器</strong>，并不一定需要从<code>collections.abc.Iterator</code>继承，只需要实现<code>__next__</code>和<code>__iter__</code>方法即可。在Python的<code>Lib/types.py</code>源文件有如下注释：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Iterators in Python aren't a matter of type but of protocol.  A large</span></span><br><span class="line"><span class="comment"># and changing number of builtin types implement *some* flavor of</span></span><br><span class="line"><span class="comment"># iterator.  Don't check the type!  Use hasattr to check for both</span></span><br><span class="line"><span class="comment"># "__iter__" and "__next__" attributes instead.</span></span><br></pre></td></tr></table></figure>
<p>所以，这里可以给迭代器下个定义：<strong>实现了<code>__next__</code>和<code>__iter__</code>方法的对象就是迭代器</strong>。如果再去查看<code>abc.Iterator</code>的源码，可以发现如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码2.3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iterator</span><span class="params">(Iterable)</span>:</span></span><br><span class="line">    -- snip --</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__subclasshook__</span><span class="params">(cls, C)</span>:</span></span><br><span class="line">        <span class="comment"># 做了更改，实际是调用 _check_methods(C, '__iter__', '__next__')</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">is</span> Iterator:  </span><br><span class="line">            <span class="keyword">if</span> (any(<span class="string">"__next__"</span> <span class="keyword">in</span> B.__dict__ <span class="keyword">for</span> B <span class="keyword">in</span> C.__mro__) <span class="keyword">and</span></span><br><span class="line">                any(<span class="string">"__iter__"</span> <span class="keyword">in</span> B.__dict__ <span class="keyword">for</span> B <span class="keyword">in</span> C.__mro__)):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="comment"># 希望大家看到NotImplemented能想到Python解释器后面会有什么操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NotImplemented</span>  <span class="comment"># 如果猜不到，可以查看《Python学习之路32》</span></span><br></pre></td></tr></table></figure>
<p>综上，<code>Iterator</code>采用的是白鹅类型技术：它实现了<code>__subclasshook__</code>方法，通过判断对象<code>x</code>是否实现了<code>__next__</code>和<code>__iter__</code>来判断<code>x</code>是否是迭代器。所以，<strong>判断对象<code>x</code>是否为迭代器的最好方法是调用<code>isinstance(x, abc.Iterator)</code></strong>。</p>
<p><strong><em>友情提示：</em></strong>通过迭代器不能判断是否还有剩余的元素，迭代器也不能重置。当然，你可以为迭代器添加其他方法来实现这两种功能，但并不推荐这种做法，除非这代码只有你自己欣赏。如果想要重新迭代，请再次调用<code>iter()</code>函数，并传入之前的可迭代对象，传入迭代器是没有用。</p>
<h2 id="典型的迭代器">2.3 典型的迭代器</h2>
<p>下面通过实现一个<code>Sentence</code>类和与之配对的<code>SentenceIterator</code>来演示传统迭代器的实现过程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码2.4</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.compile(<span class="string">"\w+"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line">        self.words = RE_WORD.findall(text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> SentenceIterator(self.words)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SentenceIterator</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, words)</span>:</span></span><br><span class="line">        self.words = words</span><br><span class="line">        self.index = <span class="number">0</span>  <span class="comment"># 保存索引</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            word = self.words[self.index]</span><br><span class="line">        <span class="keyword">except</span> IndexError:   <span class="comment"># 超出索引范围时抛出异常</span></span><br><span class="line">            <span class="keyword">raise</span> StopIteration()</span><br><span class="line">        self.index += <span class="number">1</span>  <span class="comment"># 递增索引</span></span><br><span class="line">        <span class="keyword">return</span> word</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self   <span class="comment"># 返回迭代器本身</span></span><br></pre></td></tr></table></figure>
<p>这里需要指出一个典型的<strong>错误</strong>思想：把<code>Sentence</code>变为迭代器。迭代器是可迭代对象，但可迭代对象<strong>不能</strong>是迭代器！请<strong>不要</strong>在可迭代对象的<code>__iter__</code>中返回可迭代对象自身，也<strong>不要</strong>为可迭代对象添加<code>__next__</code>方法！这是一种常见的反模式行为。</p>
<p>从设计模式来讲，我们对可迭代对象并不只有逐个迭代这种方式，有可能跳跃式迭代，也有可能反向迭代。如果把一个对象设计成既是可迭代对象也是迭代器，那这个对象内部将会有成吨的<code>if-else</code>语句，这非常不利于维护和扩展。</p>
<h1 id="生成器">3. 生成器</h1>
<p>上述版本中的<code>Sentence</code>需要配备一个迭代器。而更符合Python风格的方式是用生成器函数代替<code>SentenceIterator</code>。</p>
<h2 id="生成器函数">3.1 生成器函数</h2>
<p>使用生成器函数改写传统的迭代器（实际上不再定义迭代器）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码3.1 Sentence中其余代码不变，且不用再定义SentenceIterator</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line">    -- snip -- </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> self.words:</span><br><span class="line">            <span class="keyword">yield</span> word</span><br></pre></td></tr></table></figure>
<p><strong><em>解释：</em></strong>这里的<code>__iter__</code>是<strong>生成器函数</strong>，调用它时会创建<strong>生成器对象</strong>，然后用这个生成器对象充当迭代器。</p>
<h2 id="生成器函数工作原理">3.2 生成器函数工作原理</h2>
<p><strong>只要Python函数的定义体中有<code>yield</code>关键字，该函数就是生成器函数</strong>（这也是和普通函数的唯一区别）。“生成器”一词指代生成器函数，以及生成器函数构建的生成器对象，比较笼统，所以请具体语境具体分析。</p>
<p>生成器函数是一个生成器工厂，调用生成器函数时创建一个生成器对象，<strong>包装生成器函数的定义体</strong>。</p>
<p><strong>生成器对象实现了迭代器接口</strong>，通常Python会自动创建这个对象。当对生成器对象调用<code>next()</code>函数时，<strong>生成器函数</strong>会<strong>执行到</strong>定义体中的下一个<code>yield</code>语句的末尾，<strong>生成</strong><code>yield</code>关键字后面的表达式的值，然后停止在此处，等待下一次调用。当定义体中<strong>所有语句</strong>都执行完后，生成器函数返回，外层的生成器对象抛出<code>StopIteration</code>异常。</p>
<p><strong><em>友情提醒</em></strong>：生成器函数并不是<strong>只执行</strong>其中的<code>yield</code>语句；也不是<strong>只执行到</strong>最后一个<code>yield</code>语句，如果最后一个<code>yield</code>语句后面还有代码，依然会执行。</p>
<p>下面是关于生成器的一个简单例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码3.2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gen_AB</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"Start"</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="string">"A"</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"Continue"</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="string">"B"</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"End."</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen_AB</span><br><span class="line">&lt;function gen_AB at <span class="number">0</span>x...&gt;   <span class="comment"># 返回值和普通函数没区别</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen_AB()</span><br><span class="line">&lt;generator object gen_AB at <span class="number">0</span>x...&gt;   <span class="comment"># 返回了一个生成器对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = gen_AB()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</span><br><span class="line">Start      <span class="comment"># print("Start")</span></span><br><span class="line"><span class="string">'A'</span>  <span class="comment"># 这个是生成的值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp = next(g)  <span class="comment"># 获取生成器生成的第二个值</span></span><br><span class="line">Continue   <span class="comment"># print("Continue")</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp   <span class="comment"># 输出生成器生成的第二个值</span></span><br><span class="line"><span class="string">'B'</span>  <span class="comment"># 此时还并没有抛出异常，因为生成器函数还没执行完</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</span><br><span class="line">End.  <span class="comment"># 生成器函数执行完毕，生成器抛出异常。</span></span><br><span class="line">Traceback (most recent call last):    <span class="comment"># 显式调用next()需要自行捕获异常</span></span><br><span class="line">  File <span class="string">"&lt;input&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>
<h2 id="惰性实现与生成器表达式">3.3 惰性实现与生成器表达式</h2>
<p>上述的两个版本中，我们都用了<code>self.words</code>属性来保存文本中的单词，即在创建<code>Sentence</code>对象时就获得了所有的单词。这种方式叫做<strong>及早求值</strong>(Eager Evaluation)。而与之相反的则是<strong>惰性求值</strong>(Lazy Evaluation)，通俗讲就是“等用到的时候再来求值”。及早求值可能会消耗大量内存，而惰性求值则是为了减少内存的使用。</p>
<p><strong>生成器表达式</strong>以前提到过，它是用<strong>圆括号</strong>括起来的推导式(并不是生成元组)。<strong>生成器表达式</strong>可以理解为<strong>列表推导</strong>的<strong>惰性</strong>版本：不会一次性构造整个列表，而是返回一个生成器，按需惰性生成元素。以下是它的一个简单示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码3.3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">gen_AB</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"Start"</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="string">"A"</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"Continue"</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="string">"B"</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"End."</span>)</span><br><span class="line"><span class="meta">... </span>   </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res1 = [x * <span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> gen_AB()]  <span class="comment"># 这里有一个生成器，但被列表推导式全部迭代完</span></span><br><span class="line">Start</span><br><span class="line">Continue</span><br><span class="line">End.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res1 <span class="comment"># 一次性生成了完整的列表</span></span><br><span class="line">[<span class="string">'AAA'</span>, <span class="string">'BBB'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res2 = (x * <span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> gen_AB())  <span class="comment"># 这里其实有连个生成器</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res2   <span class="comment"># 返回了一个生成器对象，并没有一次性生成所有数据，惰性</span></span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x000001D6D34D4408</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> res2:</span><br><span class="line"><span class="meta">... </span>    print(i)</span><br><span class="line"><span class="meta">... </span>   </span><br><span class="line">Start</span><br><span class="line">AAA</span><br><span class="line">Continue</span><br><span class="line">BBB</span><br><span class="line">End.</span><br></pre></td></tr></table></figure>
<p><strong><em>解释：</em></strong>由于<code>gen_AB()</code>是个生成器函数，所以<code>(x * 3 for x in gen_AB())</code>包含了两个生成器对象，其中一个是由<code>gen_AB()</code>创建的，是不是有点嵌套生成器的意思？</p>
<p>现在我们使用<code>re.finditer</code>将第2版的<code>Sentence</code>改为惰性版本，并使用生成器表达式进一步简化代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码3.4</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text  <span class="comment"># 去掉了self.words</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (match.group() <span class="keyword">for</span> match <span class="keyword">in</span> RE_WORD.finditer(self.text))</span><br><span class="line">        <span class="comment"># 不适用生成器表达式的版本如下：</span></span><br><span class="line">        <span class="comment"># for match in RE_WORD.finditer(self.text):</span></span><br><span class="line">        <span class="comment">#     yield match.group()</span></span><br></pre></td></tr></table></figure>
<p><strong><em>友情提醒：</em></strong>在Python3中，如果想把某种实现变成惰性版本，一般都是可以的......</p>
<p><strong>生成器表达式</strong>是创建生成器的简洁语法，这样就无需定义生成器函数，一般在情况简单时使用。不过，<strong>生成器函数</strong>灵活得多，可以使用多个语句实现更复杂的逻辑，也可以作为<strong>协程</strong>使用，还可以重用代码。</p>
<h2 id="itertools模块">3.4 itertools模块</h2>
<p>该模块包含了很多有用的生成器函数，这里介绍两个生成器函数<code>itertools.count</code>和<code>itertools.takewhile</code>。</p>
<p>前面介绍的生成器中的数据都是有穷集合，而<code>itertools.count</code>则生成无穷集合。它有两个参数起始数值<code>start</code>和步长<code>step</code>，<code>start</code>默认是<code>0</code>，<code>step</code>默认是<code>1</code>。这两个参数都支持多种数字类型，比如<code>int</code>，<code>float</code>，<code>decimal.Decimal</code>和<code>fractions.Fraction</code>。以下是它的一个示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码3.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> itertools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen = itertools.count(<span class="number">1</span>, <span class="number">0.5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(gen)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(gen)</span><br><span class="line"><span class="number">1.5</span></span><br></pre></td></tr></table></figure>
<p>由于<code>itertools.count</code>不停止生成数据，所以如果调用<code>list(count())</code>，你的电脑会疯狂运转，直到超出内存限制。</p>
<p><code>itertools.takewhile</code>函数则不同，它会生成一个使用另一个生成器的生成器，在指定的函数返回<code>False</code>时停止。因此，这两个迭代器可以结合使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码3.6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen = itertools.takewhile(<span class="keyword">lambda</span> n: n &lt; <span class="number">3</span>, itertools.count(<span class="number">1</span>, <span class="number">0.5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(gen)</span><br><span class="line">[<span class="number">1</span>, <span class="number">1.5</span>, <span class="number">2.0</span>, <span class="number">2.5</span>]</span><br></pre></td></tr></table></figure>
<p>标准库中还有很多非常有用的生成器函数，这里就不一一列出了。</p>
<h2 id="yield-from">3.5 yield from</h2>
<p>如果生成器函数需要产出另一个生成器生成的值，传统的解决方法是使用嵌套<code>for</code>循环，比如如下函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码3.7</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chain</span><span class="params">(*iterables)</span>:</span>  <span class="comment"># iterables中的元素是可迭代对象</span></span><br><span class="line">    <span class="keyword">for</span> it <span class="keyword">in</span> iterables:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> it:</span><br><span class="line">            <span class="keyword">yield</span> i</span><br></pre></td></tr></table></figure>
<p>而如果使用<code>yield from</code>句法则可以使代码更简洁：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码3.8</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chain</span><span class="params">(*iterables)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> it <span class="keyword">in</span> iterables:</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> it</span><br></pre></td></tr></table></figure>
<p><code>yield from</code>语法不仅仅是语法糖，除了代替循环之外，<code>yield from</code>还会创建通道，把生成器当做协程使用。</p>
<h2 id="把生成器当做协程">3.6 把生成器当做协程</h2>
<p>从Python2.5起，生成器加入了一个名为<code>.send()</code>的方法，与<code>.__next__</code>方法一样，<code>.send</code>方法致使生成器推进到下一个<code>yield</code>语句。但<code>.send</code>方法还允许生成器的调用者向生成器传入参数，把这个参数作为对应的<code>yield</code>语句的返回值。这个方法让调用者和生成器之间能双向交换数据，而<code>.__next__</code>方法只允许调用者从生成器获取值。下面是这个方法的一个简单示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码3.9 省略了最后抛出的StopIteration异常</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">test_send</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    a = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"At the end of function, a = "</span>, a)</span><br><span class="line"><span class="meta">... </span>   </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = test_send()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</span><br><span class="line">At the end of function, a =  <span class="literal">None</span>   <span class="comment"># 可以看出，yield表达式是有返回值的，默认返回None</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = test_send()  <span class="comment"># 新建一个生成器</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)   <span class="comment"># 在调用send()之前，必须先至少调用过一次next()</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.send(<span class="string">"msg"</span>)</span><br><span class="line">At the end of function, a =  msg   <span class="comment"># 把我们传入的参数作为了yield表达式的返回值</span></span><br></pre></td></tr></table></figure>
<p>这一项重要改进甚至改变了生成器的本性：像这样用的话，生成器就变为了协程。</p>
<p>这里是想提醒大家，请慎重使用这个方法！生成器用于生产供迭代的数据，协程是数据的消费者。为了避免不必要的麻烦，请严格区分协程和迭代，虽然协程也用到到了<code>yield</code>，但协程和迭代没有关系！</p>
<p>关于协程的内容将会在后面的文章中介绍。</p>
<h1 id="总结">4. 总结</h1>
<p>本篇首先介绍了可迭代对象与迭代器，内容包括迭代的原理以及<code>iter()</code>和<code>next()</code>函数所做的工作，然后实现了一个经典的迭代器。随后，为了让这个经典的迭代器更符合Python风格，我们讨论了生成器。这期间讲到了生成器和迭代器的关系，生成器函数及其工作原理，惰性实现和生成器表达式。根据这些内容，我们将之前传统的迭代器进行了简化。随后补充了三个内容：<code>itertools</code>模块中的生成器函数，<code>yield from</code>语法和生成器的<code>.send()</code>。</p>
<p>最后，建议大家一定要多了解标准库中的生成器函数，尤其是<code>itertools</code>模块。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python进阶</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python进阶</tag>
        <tag>迭代器</tag>
        <tag>生成器</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路33-上下文管理器和else块</title>
    <url>/2018/06/07/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF33-%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8%E5%92%8Celse%E5%9D%97/</url>
    <content><![CDATA[<blockquote>
<p>《流畅的Python》笔记。</p>
<p>本篇主要讨论Python用户常忽略掉的一些流程控制特性，包括上下文管理器和else块。内容包括else与非if关键字的搭配；Python中的上下文管理器，如何自定义上下文管理器，以及contextlib模块中@contextmanager装饰器的用法。</p>
</blockquote>
<a id="more"></a>
<h1 id="if语句之外的else块">1. if语句之外的else块</h1>
<p><code>else</code>除了和<code>if</code>搭配之外，在Python中，它还能与<code>for</code>，<code>while</code>和 <code>try</code>搭配：</p>
<ul>
<li><code>for</code>：仅当<code>for</code>循环运行完毕时才运行<code>else</code>块</li>
<li><code>while</code>：仅当<code>while</code>循环因为条件为假而退出时才运行<code>else</code>块</li>
<li><code>try</code>：仅当<code>try</code>块中没有抛出异常时才运行<code>else</code>块，且<code>else</code>块中抛出的异常不会被前面的<code>except</code>子句处理</li>
<li>在上述三个情况中，如果异常、<code>return</code>、<code>break</code>或<code>continue</code>语句导致控制权跳到了复合语句的主块之外，<code>else</code>子句会被跳过。</li>
</ul>
<p>在这些语句中使用<code>else</code>字块有事能让代码更易读，而且能省去一些麻烦，不用设置控制标志或者添加额外的<code>if</code>语句，尤其是在和<code>try</code>复合时。<code>try</code>块中的代码应该只含有预计会抛出异常的语句，以下是两种写法的对比：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码1.1，只有dangerous_all()可能会抛出异常</span></span><br><span class="line"><span class="comment"># 写法1</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    dangerous_all()</span><br><span class="line">    after_call()</span><br><span class="line"><span class="keyword">except</span> OSError:</span><br><span class="line">    log(<span class="string">"OSError..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写法2，此写法比上述写法更明确</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    dangerous_all()</span><br><span class="line"><span class="keyword">except</span> OSError:</span><br><span class="line">    log(<span class="string">"OSError..."</span>)</span><br><span class="line"><span class="keyword">else</span>:   <span class="comment"># 但其实这么写也是多余的</span></span><br><span class="line">    after_call()</span><br></pre></td></tr></table></figure>
<p>但是，<strong>并不建议大家在这些关键字后面加<code>else</code>块</strong>，因为这很容易造成歧异，比如笔者第一眼看到<code>for/else</code>时的理解是：如果不能进入<code>for</code>块，则运行<code>else</code>中的内容，但实际刚好相反。在其他语言中，此时的<code>else</code>一般由关键字<code>then</code>代替，但Python的创建人非常讨厌添加新关键字，所以让<code>else</code>担起了这个职责。许多编程规范的书中也不建议在这些关键字后面添加<code>else</code>块。</p>
<p><strong><em>补充：</em></strong>在Python中，<code>try/except</code>不仅用于错误处理，还和<code>if/else</code>一样，常用于控制流程，因此，这就形成了两种代码风格：</p>
<ul>
<li>EAFP：“取得原谅比获得许可更容易”(Easier to Ask for Forgiveness than Permission)，通俗讲就是“不管会不会抛异常，先运行再说，等抛出了异常再处理”，这种风格的特点就是代码中有很多<code>try/except</code>块；</li>
<li>LBYL：“三思而后行”(Look Before You Leap)，这种风格就是显式测试前提条件，通俗讲就是“必须合规后才能运行”，这种风格的特点就是代码中有很多<code>if/else</code>块。</li>
</ul>
<h1 id="上下文管理器和with块">2. 上下文管理器和with块</h1>
<p>说到<strong>上下文管理器</strong>，那首先就得说说什么是<strong>上下文</strong>。笔者第一次接触这个概念的时候很费解，笔者是按语文里的概念来理解的：不就是前一句话后一句话，前一段话后一段话吗，这有什么可管理的？虽然至今笔者也没看到关于“上下文”这个概念的准确定义，但用多了之后，大致能理解为：</p>
<blockquote>
<p>某段代码B将整个程序分成了3段，从前到后分别为A，B，C。当运行代码段B时，程序运行环境的某些设定需要发生改变；当退出代码段B后，这些被改变的设置需恢复原样，即保持A和C的一致性。A和B，B和C就称之为<strong>上下文</strong>。由于某些原因(如程序员大意、抛出异常强制退出等)，B中所改变的设置并不总能手动恢复回去，所以，通常将这些设置交由某些对象统一管理，这些对象就叫做<strong>上下文管理器</strong>。</p>
</blockquote>
<h2 id="python中的上下文管理器">2.1 Python中的上下文管理器</h2>
<p>上下文管理器采用的是鸭子类型技术，实现了<code>__enter__</code>和<code>__exit__</code>两个抽象方法的对象就是上下文管理器。</p>
<p>上下文管理器对象的存在目的是为了管理<code>with</code>语句，而<code>with</code>语句的目的是简化<code>try/finally</code>模式。</p>
<p><code>with</code>块的经典用法之一就是读写文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码2.1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">"text.txt"</span>) <span class="keyword">as</span> fp:  <span class="comment"># 变量fp还有一个称呼，叫"句柄"</span></span><br><span class="line"><span class="meta">... </span>     <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp</span><br><span class="line">&lt;_io.TextIOWrapper name=<span class="string">"text.txt"</span> mode=<span class="string">"r"</span> encoding=<span class="string">"UTF-8"</span>&gt;</span><br></pre></td></tr></table></figure>
<p><strong><em>解释</em></strong>：</p>
<ul>
<li><code>with</code>后面的表达式（不包括<code>as</code>部分）得到的结果就是一个上下文管理器。此处<code>open()</code>函数返回了一个<code>TextIOWrapper</code>对象，Python解释器会临时保存这个对象，我们这里将其取名为<code>a</code>；</li>
<li>在<code>with</code>语句块中，Python得到上下文管理器后会首先调用它的<code>__enter__</code>方法，如果<code>with</code>后面跟了<code>as</code>关键字，则该方法的返回值会赋给<code>as</code>后面的变量。上述代码中，当Python得到了<code>a</code>后，调用它的<code>__enter__</code>方法，该方法返回<code>a</code>对象自身(<code>return self</code>)，然后变量<code>fp</code>接收这个值。但请注意，<strong>并不是所有的上下文管理器的<code>__enter__</code>都返回实例自身</strong>。</li>
<li>当退出<code>with</code>块时，Python会调用<strong>上下文管理器</strong>的<code>__exit__</code>方法，做最后处理。上述代码中，Python并不是调用<code>fp.__exit__()</code>，而是调用<code>a.__exit__()</code>；</li>
<li>与函数和模块不同，<code>with</code>块没有定义新的作用域，所以即便退出了<code>with</code>块，变量<code>fp</code>依然存在。</li>
</ul>
<h2 id="自定义上下文管理器">2.2 自定义上下文管理器</h2>
<p>下面我们自定义一个上下文管理器来说明上述四条解释：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码2.2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LookingGlass</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span>  <span class="comment"># 该方法只要self一个参数</span></span><br><span class="line">        <span class="keyword">import</span> sys</span><br><span class="line">        self.original_write = sys.stdout.write  <span class="comment"># 保存原方法</span></span><br><span class="line">        sys.stdout.write = self.reverse_write   <span class="comment"># 猴子补丁，临时替换原本的方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"JABBERWOCKY"</span>  <span class="comment"># 并不一定是返回self！</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse_write</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.original_write(text[::<span class="number">-1</span>])   <span class="comment"># 反转text内容</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span>  <span class="comment"># 该方法有4个参数！</span></span><br><span class="line">        <span class="keyword">import</span> sys  <span class="comment"># 由于Python会缓存导入的模块，重复导入不会消耗很多资源</span></span><br><span class="line">        sys.stdout.write = self.original_write  <span class="comment"># 恢复到原本的方法</span></span><br><span class="line">        <span class="keyword">if</span> exc_type <span class="keyword">is</span> ZeroDivisionError:</span><br><span class="line">            print(<span class="string">"Please DO NOT divide by zero!"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span>   <span class="comment"># 返回True，表示异常已经正常处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 控制台中运行</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> mirror <span class="keyword">import</span> LookingGlass</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> LookingGlass() <span class="keyword">as</span> what:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"Alice, Kitty and SnowDrop"</span>)</span><br><span class="line"><span class="meta">... </span>    print(what)</span><br><span class="line"><span class="meta">... </span>   </span><br><span class="line">porDwonS dna yttiK ,ecilA</span><br><span class="line">YKCOWREBBAJ</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>what</span><br><span class="line"><span class="string">'JABBERWOCKY'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"Back to normal!"</span>)</span><br><span class="line">Back to normal!</span><br></pre></td></tr></table></figure>
<p><strong><em>解释：</em></strong></p>
<ul>
<li><p><code>__enter__</code>方法只有一个参数，即隐式的<code>self</code>；</p></li>
<li><p><code>__exit__</code>有四个参数，第一个参数是<code>self</code>，其余三个参数主要用于处理<code>with</code>块运行期间发生的异常，分别是：</p>
<ul>
<li><code>exc_type</code>：异常<strong>类</strong></li>
<li><code>exc_val</code>：异常<strong>实例</strong>，<code>with</code>块中发生异常时抛出的对象。如果<code>__exit__</code>想要向上抛出异常，那么在创建异常对象时传入的某些参数可从<code>exc_val.args</code>中获取，比如错误信息。</li>
<li><code>exc_tb</code>：<code>traceback</code>对象。</li>
</ul>
<p>如果<code>with</code>块中没有抛出异常，Python调用<code>__exit__</code>方法时传入的参数是<strong>三个<code>None</code></strong>，否则传入异常数据。</p></li>
<li><p>当<code>with</code>块中发生异常时：如果<code>__exit__</code>返回<code>True</code>，表示异常已正确处理，Python解释器会压制异常；如果返回的是其它值，<code>with</code>块中的任何异常都会向上冒泡。如果<code>with</code>块中没有发生异常，则不用关注<code>__exit__</code>的返回值。</p></li>
</ul>
<h2 id="contextlib模块">2.3 contextlib模块</h2>
<p>该模块包含了很多管理上下文的使用工具，下面列举出5个：</p>
<ul>
<li><code>closing</code>：如果对象提供了<code>close()</code>方法，但没有实现<code>__enter__/__exit__</code>协议，则可以使用这个函数构建上下文管理器</li>
<li><code>suppress</code>：构建临时忽略指定异常的上下文管理器</li>
<li><code>@contextmanager</code>：<strong>这个装饰器很常用</strong>，它把简单的<strong>生成器函数</strong>变成上下文管理器，这样就不用创建类去实现管理器协议</li>
<li><code>ContextDecorator</code>：这是个基类，用于定义基于类的上下文管理器。这种上下文管理器也能用于装饰函数，在受管理的上下文中运行整个函数</li>
<li><code>ExitStack</code>：这个上下文管理器能保存多个上下文管理器。它是一个栈，<code>with</code>结束时，依次调用栈中各个上下文管理器的<code>__exit__</code>方法。如果事先不知道<code>with</code>块要进入多少个上下文管理器，可以使用这个类。例如，同时打开任意一个文件列表中的所有文件。</li>
</ul>
<h2 id="contextmanager">2.4 <span class="citation" data-cites="contextmanager">@contextmanager</span></h2>
<p><code>@contextmanager</code>装饰器能减少创建上下文管理器的样板代码量，不用编写一个完整的类，然后再实现<code>__enter__</code>和<code>__exit__</code>方法，而是只需实现一个仅含单个<code>yield</code>语句的生成器，生成想让<code>__enter__</code>方法返回的值。</p>
<p>在使用<code>@contextmanager</code>装饰的生成器中，<code>yield</code>语句的作用是把函数的定义体分成两部分：<code>yield</code>语句前面的所有代码在<code>with</code>块开始时(即解释器调用<code>__enter__</code>方法时)执行，<code>yield</code>之后的代码在<code>with</code>块结束时(即调用<code>__exit__</code>方法时)执行。</p>
<p>下面我们将之前的<code>LookingGlass</code>类改写为生成器版本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码2.3</span></span><br><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">looking_glass</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    original_write = sys.stdout.write</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse_write</span><span class="params">(text)</span>:</span></span><br><span class="line">        original_write(text[::<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">    sys.stdout.write = reverse_write</span><br><span class="line">    msg = <span class="string">""</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">"JABBERWOCKY"</span>  <span class="comment"># 如果有异常，会在这里抛出</span></span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:  </span><br><span class="line">        <span class="comment"># 该装饰器默认所有异常都得到了处理，如果不想异常被压制，请在此处抛出</span></span><br><span class="line">        msg = <span class="string">"Please DO NOT divide by zero!"</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        sys.stdout.write = original_write</span><br><span class="line">        <span class="keyword">if</span> msg:</span><br><span class="line">            print(msg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用法和之前的版本一样：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> looking_glass() <span class="keyword">as</span> what:   <span class="comment"># 这里是唯一的变化</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"Alice, Kitty and SnowDrop"</span>)</span><br><span class="line"><span class="meta">... </span>    print(what)</span><br><span class="line"><span class="meta">... </span>   </span><br><span class="line">porDwonS dna yttiK ,ecilA</span><br><span class="line">YKCOWREBBAJ</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>what</span><br><span class="line"><span class="string">'JABBERWOCKY'</span></span><br></pre></td></tr></table></figure>
<p><code>contextlib.contextmanager</code>装饰器会把函数包装成实现了<code>__enter__</code>和<code>__exit__</code>方法的类。</p>
<p>这个类的<code>__enter__</code>方法有如下作用：</p>
<ul>
<li>调用生成器函数，保存生成器对象（这里称其为<code>gen</code>）</li>
<li>调用<code>next(gen)</code>，执行到<code>yield</code>关键字所在的位置</li>
<li>返回<code>next(gen)</code>生成的值，将其绑定到<code>with/as</code>语句中的目标变量上</li>
</ul>
<p>它的<code>__exit__</code>方法有如下作用：</p>
<ul>
<li>检查有没有把异常传给<code>exc_type</code>；如果有，调用<code>gen.throw(exception)</code>，在生成器函数定义体中<code>yield</code>所在行抛出异常</li>
<li>否则，调用<code>next(gen)</code>，将生成器函数中剩余代码执行完。</li>
</ul>
<p>前面说到，对一般的上下文管理器，如果<code>with</code>中抛出了异常，Python解释器会根据<code>__exit__</code>的返回值来决定是否压制异常。但<code>@contextmanager</code>则不同：它提供的<code>__exit__</code>方法默认所有异常都得到了处理。如果不想让<code>@contextmanager</code>，必须在被装饰的函数中显式重新抛出异常。</p>
<h1 id="总结">3. 总结</h1>
<p>本篇分为了两个部分，首先介绍了<code>else</code>与<code>for</code>、<code>while</code>以及<code>try</code>的搭配用法（但并不建议这么做，只需要知道能这么用就行了）；随后是上下文管理器的内容，介绍了什么是“上下文”，什么是“上下文管理器”，Python中的上下文管理器以及<code>with</code>块，然后我们自定义了一个上下文管理器，最后介绍了<code>contextlib</code>模块，并用其中的<code>@contextmanager</code>装饰器改写了自定义的上下文管理器。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python进阶</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python进阶</tag>
        <tag>上下文管理器</tag>
        <tag>else块</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路32-运算符重载</title>
    <url>/2018/06/06/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF32-%E6%AD%A3%E7%A1%AE%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<blockquote>
<p>《流畅的Python》笔记。</p>
<p>本篇是“面向对象惯用方法”的第六篇，也是最后一篇。本篇将讨论Python中的运算符重载。</p>
</blockquote>
<a id="more"></a>
<h1 id="前言">1. 前言</h1>
<p>Python中的运算符重载和C++中的运算符重载并不一样，C++中同一运算符可以有多个重载函数，Python中的运算符重载其实是实现运算符的同名特殊方法。</p>
<p>本篇只讨论一元运算符和中缀运算符，内容如下：</p>
<ul>
<li>Python如何处理中缀运算符中不同类型的操作数；</li>
<li>使用鸭子类型或白鹅类型处理不同类型的操作数；</li>
<li>中缀运算符如何表明自己无法处理操作数；</li>
<li>众多比较运算符的特殊行为；</li>
<li>增量运算符的默认处理方式和重载方式。</li>
</ul>
<p>不过，需要说明的是，并不是所有的运算符都能重载：</p>
<ul>
<li>不能重载内置类型的运算符；</li>
<li>不能新建运算符，只能重载现有的；</li>
<li><code>is</code>，<code>and</code>，<code>or</code>和<code>not</code>不能重载。</li>
</ul>
<p>本文中的示例延用<a href="http://www.vpointer.net/articles/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF29-%E5%BA%8F%E5%88%97%E7%9A%84%E4%BF%AE%E6%94%B9%E3%80%81%E6%95%A3%E5%88%97%E5%92%8C%E5%88%87%E7%89%87/" target="_blank" rel="noopener">《Python学习之路29》</a>中的多维向量<code>Vector</code>。</p>
<h1 id="一元运算符">2. 一元运算符</h1>
<p>本节主要介绍4个一元运算符，它们分别是：</p>
<ul>
<li><code>-</code> (<code>__neg__</code>)：一元取负运算符，如<code>x = 2</code>，则<code>-x == 2</code>；</li>
<li><code>+</code>(<code>__pos__</code>)：一元取正运算符，通常是<code>x == +x</code>，但也有特例；</li>
<li><code>~</code>(<code>__invert__</code>)：对整数按位取反，定义为<code>~x == -(x + 1)</code>；</li>
<li><code>abs()</code>函数：Python语言参考手册把它也列为了一元运算符，它对应的就是之前多次用到的<code>__abs__</code>。</li>
</ul>
<p>在实现过程中需要遵循<strong>这些</strong>运算符的一个基本规则：<strong>始终返回一个新对象</strong>！也就是说不能修改<code>self</code>，要创建并返回合适类型的实例。以下补充两个<code>Vector</code>类的运算符重载：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__neg__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Vector(-x <span class="keyword">for</span> x <span class="keyword">in</span> self)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__pos__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Vector(self)</span><br></pre></td></tr></table></figure>
<p><strong><code>x</code>和<code>+x</code>何时不等</strong>？以下是两个例子：</p>
<ul>
<li><p>如果<code>decimal.Decimal</code>所在上下文的精度不同，则有可能不等，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> decimal</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ctx = decimal.getcontext()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ctx.prec = <span class="number">40</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one_third = decimal.Decimal(<span class="string">"1"</span>) / decimal.Decimal(<span class="string">"3"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one_third</span><br><span class="line">Decimal(<span class="string">'0.3333333333333333333333333333333333333333'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one_third == +one_third</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ctx.prec = <span class="number">28</span>    <span class="comment"># 这是默认精度</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one_third == +one_third</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>+one_third</span><br><span class="line">Decimal(<span class="string">'0.3333333333333333333333333333'</span>)</span><br></pre></td></tr></table></figure></li>
<li><p><code>collections.Counter</code>在相加时，负值和零值计数会从结果中剔除，而一元运算符<code>+</code>对它来说等同于加上一个空<code>Counter</code>，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct = Counter(<span class="string">"abracadabra"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct[<span class="string">"r"</span>] = <span class="number">-3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct[<span class="string">"d"</span>] = <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct</span><br><span class="line">Counter(&#123;<span class="string">'a'</span>: <span class="number">5</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">1</span>, <span class="string">'d'</span>: <span class="number">0</span>, <span class="string">'r'</span>: <span class="number">-3</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>+ct   <span class="comment"># 与ct不等</span></span><br><span class="line">Counter(&#123;<span class="string">'a'</span>: <span class="number">5</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="重载向量加法运算符">3. 重载向量加法运算符+</h1>
<p>目前版本的<code>Vector</code>不支持向量相加，因为没有重载<code>+</code>运算符。我们的要求如下：</p>
<ul>
<li>它能实现两个<code>Vector</code>相加，并且两个长度不等的<code>Vector</code>也能相加，短的那个用<code>0.0</code>填充；</li>
<li>能与任何可迭代对象相加，但当这个可迭代对象中的元素不能与浮点数做加法运算时，则抛出<code>NotImplemented</code>异常；</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        pairs = itertools.zip_longest(self, other, fillvalue=<span class="number">0.0</span>)  <span class="comment"># 自动填充</span></span><br><span class="line">        <span class="keyword">return</span> Vector(a + b <span class="keyword">for</span> a, b <span class="keyword">in</span> pairs)</span><br><span class="line">    <span class="keyword">except</span> TypeError:</span><br><span class="line">        <span class="comment"># 它不是一个异常类，而是一个单例值！所以用的是return，而不是raise</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span>   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__radd__</span><span class="params">(self, other)</span>:</span>   <span class="comment"># 实现反向相加</span></span><br><span class="line">    <span class="keyword">return</span> self + other</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在控制台中运行的示例，省略了import语句</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 + Vector([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])  <span class="comment"># 可以和同类型的相加</span></span><br><span class="line">Vector([<span class="number">3.0</span>, <span class="number">5.0</span>, <span class="number">7.0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 + (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)   <span class="comment"># 和其他可迭代对象也能相加</span></span><br><span class="line">Vector([<span class="number">2.0</span>, <span class="number">4.0</span>, <span class="number">6.0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 + (<span class="number">1</span>, <span class="number">2</span>)    <span class="comment"># 长度不同也能相加</span></span><br><span class="line">Vector([<span class="number">2.0</span>, <span class="number">4.0</span>, <span class="number">3.0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 + Vector2d(<span class="number">1</span>, <span class="number">2</span>)   <span class="comment"># 由于我们之前实现的Vector2d也是可迭代对象，所以也能和Vector相加</span></span><br><span class="line">Vector([<span class="number">2.0</span>, <span class="number">4.0</span>, <span class="number">3.0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) + v1   <span class="comment"># &lt;1&gt; 反向也能相加，见解释</span></span><br><span class="line">Vector([<span class="number">2.0</span>, <span class="number">4.0</span>, <span class="number">6.0</span>])</span><br></pre></td></tr></table></figure>
<p><strong><em>解释</em></strong>：</p>
<ul>
<li><p>像<code>__radd__</code>，<code>__rsub__</code>这种前面带<code>r</code>的方法一般被称作“反向”运算方法或“右向”运算方法，如果没有实现这种方法，上述代码<code>&lt;1&gt;</code>处的语句就会抛出<code>TypeError</code>；</p></li>
<li><p>对于表达式<code>a + b</code>来说，解释器会执行如下几步：</p>
<ul>
<li>如果<code>a</code>有<code>__add__</code>方法，调用<code>a.__add__(b)</code>；</li>
<li>如果<code>a.__add__(b)</code>返回<code>NotImplemented</code>，或者<code>a</code>没有<code>__add__</code>方法，则检查<code>b</code>有没有<code>__radd__</code>方法，如果有，则调用<code>b.__radd__(a)</code>；</li>
<li>如果<code>b.__radd__(a)</code>返回<code>NotImplemented</code>，或者<code>b</code>没有<code>__radd__</code>方法，则抛出<code>TypeError</code>，并在错误消息中指明<strong>操作数类型不支持</strong>。</li>
</ul>
<p>其他有反向运算方法的运算符在调用时也是上面这个逻辑。</p></li>
<li><p><code>__radd__</code>等反向运算的实现通常就如上述代码这么简单暴力：直接委托给正向运算。</p></li>
<li><p>在实现<code>__add__</code>时，我们并没有去判断<code>other</code>的类型或者它的元素的类型，而是捕获<code>TypeError</code>异常。这是在给<code>other</code>调用反向运算方法的一个机会。如果调用成功，<code>other</code>就能被当做另一个操作数的“同类”，这也遵循了鸭子类型精神。</p></li>
</ul>
<h1 id="重载乘法运算符">4. 重载乘法运算符</h1>
<h2 id="重载数乘运算">4.1 重载数乘运算*</h2>
<p>这里实现的是向量的数乘运算，我们希望<strong>任何实数</strong>都能和<code>Vector</code>做数乘预算（也叫做元素级乘法, elementwise multiplication），添加的两个方法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__mul__</span><span class="params">(self, scalar)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(scalar, numbers.Real):  </span><br><span class="line">        <span class="keyword">return</span> Vector(n * scalar <span class="keyword">for</span> n <span class="keyword">in</span> self)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__rmul__</span><span class="params">(self, scalar)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self * scalar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下是在控制台中运行的示例</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> * v1</span><br><span class="line">Vector([<span class="number">2.0</span>, <span class="number">4.0</span>, <span class="number">6.0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 * <span class="literal">True</span>    <span class="comment"># bool是int的子类</span></span><br><span class="line">Vector([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 * Fraction(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">Vector([<span class="number">0.3333333333333333</span>, <span class="number">0.6666666666666666</span>, <span class="number">1.0</span>])</span><br></pre></td></tr></table></figure>
<p><strong><em>解释</em></strong>：这里并没有像<code>__add__</code>中那样，采用鸭子类型技术，在<code>__mul__</code>中捕获<code>TyperError</code>；而是采用更易于理解和更合理的方式，即白鹅类型，使用<code>isinstance()</code>函数来判断操作数是否为实数。</p>
<h2 id="重载点乘运算">4.2 重载点乘运算@</h2>
<p>从Python3.5开始，已经支持点乘运算符<code>@</code>，它相应的特殊方法时<code>__matmul__</code>（矩阵乘法”matrix multiplication”的缩写），以下是对点乘运算的重载：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__matmul__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> sum(a * b <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(self, other))</span><br><span class="line">    <span class="keyword">except</span> TypeError:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__rmatmul__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self @ other</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面是它的运行示例：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Vector([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) @ Vector([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] @ Vector([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"><span class="number">32</span></span><br></pre></td></tr></table></figure>
<h1 id="比较运算符">5. 比较运算符</h1>
<p>Python对比较运算符的处理与前文类似，不过在两个方面有重大区别：</p>
<ul>
<li>正向和反向调用使用的是同一系列方法，即没有<code>r</code>前缀。例如，对于<code>==</code>来说，正向和反向调用都是<code>__eq__</code>方法，只是掉换个参数；正向的<code>__gt__</code>方法调用的则是反向的<code>__lt__</code>方法，并调换参数。</li>
<li>对<code>==</code>和<code>!=</code>来说，如果反向调用失败，Python会比较对象的ID，而不是抛出<code>TypeError</code>。</li>
</ul>
<h2 id="重载">5.1 重载 ==</h2>
<p>之前版本的<code>Vector</code>中，<code>__eq__</code>的实现与行为如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (len(self) == len(other) <span class="keyword">and</span> all(a == b <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(self, other)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 它的行为如下：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Vector([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) == (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  <span class="comment"># 除此之外还能和Vector与Vector2d比较</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>有时候我们并不想兼容这么多类型的操作数，但当遇到某些类型时（比如上面的元组），我们也不想武断地直接抛出<code>TypeError</code>，而是让另一个操作数判断这俩是否相等，于是我们将上述代码改为如下形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(other, Vector):</span><br><span class="line">        <span class="keyword">return</span> (len(self) == len(other) <span class="keyword">and</span> all(a == b <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(self, other)))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 它的行为如下：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>va = Vector([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t3 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>va == t3</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>以下是<code>Vector([1, 2, 3]) == (1, 2, 3)</code>这段代码的运行过程：</p>
<ul>
<li>为计算<code>va == t3</code>，Python调用<code>Vector.__eq__(va, t3)</code>；</li>
<li>由于<code>t3</code>不是<code>Vector</code>类，所以上述调用返回<code>NotImplemented</code>；</li>
<li>Python得到<code>NotImplemented</code>结果，尝试调用<code>tuple.__eq__(t3, va)</code>；</li>
<li>由于<code>tuple.__eq__(t3, va)</code>不知道<code>Vector</code>是什么，因此返回<code>NotImplemented</code>；</li>
<li>对<code>==</code>来说，如果反向调用也返回了<code>NotImplemented</code>，则最后比较对象的ID，发现两者不等，返回<code>False</code></li>
</ul>
<h2 id="重载-1">5.2 重载 !=</h2>
<p><strong><code>!=</code>不用重载</strong>！从<code>object</code>继承而来的<code>__ne__</code>已经够用了，由于原版的<code>__ne__</code>是用C语言写到，下面的代码是它的Python版本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__ne__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    eq_result = self == other</span><br><span class="line">    <span class="keyword">if</span> eq_result <span class="keyword">is</span> <span class="built_in">NotImplemented</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> eq_result</span><br></pre></td></tr></table></figure>
<p>意思就是：如果<code>__eq__</code>返回<code>NotImplemented</code>，那它也返回这个值；否则，返回<code>__eq__</code>结果的相反值。</p>
<h1 id="增量赋值运算符">6. 增量赋值运算符</h1>
<p>其实目前版本的<code>Vector</code>已经支持了<code>+=</code>和<code>*=</code>操作，因为我们为它实现了<code>__add__</code>，<code>__mul__</code>操作，当运行<code>a += b</code>时，会被转换成<code>a = a + b</code>。但也正因此，大家可以看出，这不是一个就地运算，这样的<code>+=</code>和<code>*=</code>会创建新的实例。如果想实现就地预算，则需要重写以<code>i</code>开头的特殊方法，比如<code>+=</code>对应的<code>__iadd__</code>。</p>
<p>由于<code>Vector</code>被定义为不可变类型，这里我们新建一个简单的<code>MyList</code>类来示范<code>+=</code>运算符的重载。为简答起见，以两个操作数的最小长度为准：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyList</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, iterable)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self._list = list(iterable)</span><br><span class="line">...</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__iadd__</span><span class="params">(self, other)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">for</span> i <span class="keyword">in</span> range(min(len(self._list), len(other))):</span><br><span class="line"><span class="meta">... </span>            self._list[i] += other[i]</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> self</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test = MyList(range(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(test)</span><br><span class="line"><span class="number">2848410583560</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test += range(<span class="number">9</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(test)</span><br><span class="line"><span class="number">2848410583560</span>   <span class="comment"># ID没有改变</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test </span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">9</span>]   <span class="comment"># 确实是就地运算</span></span><br></pre></td></tr></table></figure>
<p>其实这里只为强调一点：<strong>增量赋值特殊方法最后一定要返回<code>self</code>!</strong></p>
<h1 id="总结">7. 总结</h1>
<p>本文开篇先介绍了不能重载运算符的情况，随后依次介绍了一元运算符，中缀运算符（包括加法、乘法和比较运算）和增量运算符的重载情况。</p>
<p>其中需要注意<code>NotImplemented</code>这个值，它不是异常，而是个单例值，Python在进行中缀运算时会专门检测这个值。</p>
<p>期间，我们还讨论了如何处理不同类型的操作数：是按照鸭子类型技术，捕获<code>TypeError</code>，还是根据白鹅类型，用<code>isinstance</code>进行类型判断。这两种方式各有利弊：鸭子类型更灵活，但白鹅类型更能预知结果。如果选用<code>isinstance</code>，则不要检测具体类，而应检测抽象基类，比如<code>numbers.Real</code>。</p>
<p>最后给出各运算符对应的特殊方法的表格，第一个表格是中缀运算符的名称：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">运算符</th>
<th style="text-align: center;">正向方法</th>
<th style="text-align: center;">反向方法</th>
<th style="text-align: center;">就地方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>+</code></td>
<td style="text-align: center;"><code>__add__</code></td>
<td style="text-align: center;"><code>__radd__</code></td>
<td style="text-align: center;"><code>__iadd__</code></td>
<td>加法或拼接</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>-</code></td>
<td style="text-align: center;"><code>__sub__</code></td>
<td style="text-align: center;"><code>__rsub__</code></td>
<td style="text-align: center;"><code>__isub__</code></td>
<td>减法</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>*</code></td>
<td style="text-align: center;"><code>__mul__</code></td>
<td style="text-align: center;"><code>__rmul__</code></td>
<td style="text-align: center;"><code>__imul__</code></td>
<td>乘法或重复复制</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>/</code></td>
<td style="text-align: center;"><code>__truediv__</code></td>
<td style="text-align: center;"><code>__rtruediv__</code></td>
<td style="text-align: center;"><code>__itruediv__</code></td>
<td>除法</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>//</code></td>
<td style="text-align: center;"><code>__floordiv__</code></td>
<td style="text-align: center;"><code>__rfloordiv__</code></td>
<td style="text-align: center;"><code>__ifloordiv__</code></td>
<td>整除</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>%</code></td>
<td style="text-align: center;"><code>__mod__</code></td>
<td style="text-align: center;"><code>__rmod__</code></td>
<td style="text-align: center;"><code>__imod__</code></td>
<td>取模</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>divmod()</code></td>
<td style="text-align: center;"><code>__divmod__</code></td>
<td style="text-align: center;"><code>__rdivmod__</code></td>
<td style="text-align: center;"><code>__idivmod__</code></td>
<td>返回由整除的商和模构成的元组</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>**</code>，<code>pow()</code></td>
<td style="text-align: center;"><code>__pow__</code></td>
<td style="text-align: center;"><code>__rpow__</code></td>
<td style="text-align: center;"><code>__ipow__</code></td>
<td>幂运算</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>@</code></td>
<td style="text-align: center;"><code>__matmul__</code></td>
<td style="text-align: center;"><code>__rmatmul__</code></td>
<td style="text-align: center;"><code>__imatmul__</code></td>
<td>矩阵乘法</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>&amp;</code></td>
<td style="text-align: center;"><code>__and__</code></td>
<td style="text-align: center;"><code>__rand__</code></td>
<td style="text-align: center;"><code>__iand__</code></td>
<td>位与</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>|</code></td>
<td style="text-align: center;"><code>__or__</code></td>
<td style="text-align: center;"><code>__ror__</code></td>
<td style="text-align: center;"><code>__ior__</code></td>
<td>位或</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>^</code></td>
<td style="text-align: center;"><code>__xor__</code></td>
<td style="text-align: center;"><code>__rxor__</code></td>
<td style="text-align: center;"><code>__ixor__</code></td>
<td>位异或</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>&lt;&lt;</code></td>
<td style="text-align: center;"><code>__lshift__</code></td>
<td style="text-align: center;"><code>__rlshift__</code></td>
<td style="text-align: center;"><code>__ilshift__</code></td>
<td>按位左移</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>&gt;&gt;</code></td>
<td style="text-align: center;"><code>__rshift__</code></td>
<td style="text-align: center;"><code>__rrshift__</code></td>
<td style="text-align: center;"><code>__irshift__</code></td>
<td>按位右移</td>
</tr>
</tbody>
</table>
<p>下面这个表格是比较运算符的名称：</p>
<table>
<thead>
<tr class="header">
<th>分组</th>
<th style="text-align: center;">中缀运算符</th>
<th style="text-align: center;">正向方法调用</th>
<th style="text-align: center;">反向方法调用</th>
<th>后备机制</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>相等性</td>
<td style="text-align: center;"><code>a == b</code></td>
<td style="text-align: center;"><code>a.__eq__(b)</code></td>
<td style="text-align: center;"><code>b.__eq__(a)</code></td>
<td>返回<code>id(a) == id(b)</code></td>
</tr>
<tr class="even">
<td></td>
<td style="text-align: center;"><code>a != b</code></td>
<td style="text-align: center;"><code>a.__ne__(b)</code></td>
<td style="text-align: center;"><code>b.__ne__(a)</code></td>
<td>返回<code>not (a == b)</code></td>
</tr>
<tr class="odd">
<td>排序</td>
<td style="text-align: center;"><code>a &gt; b</code></td>
<td style="text-align: center;"><code>a.__gt__(b)</code></td>
<td style="text-align: center;"><code>b.__lt__(a)</code></td>
<td>抛出<code>TypeError</code></td>
</tr>
<tr class="even">
<td></td>
<td style="text-align: center;"><code>a &lt; b</code></td>
<td style="text-align: center;"><code>a.__lt__(b)</code></td>
<td style="text-align: center;"><code>b.__gt__(a)</code></td>
<td>抛出<code>TypeError</code></td>
</tr>
<tr class="odd">
<td></td>
<td style="text-align: center;"><code>a &gt;= b</code></td>
<td style="text-align: center;"><code>a.__ge__(b)</code></td>
<td style="text-align: center;"><code>b.__le__(a)</code></td>
<td>抛出<code>TypeError</code></td>
</tr>
<tr class="even">
<td></td>
<td style="text-align: center;"><code>a &lt;= b</code></td>
<td style="text-align: center;"><code>a.__le__(b)</code></td>
<td style="text-align: center;"><code>b.__ge__(a)</code></td>
<td>抛出<code>TypeError</code></td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python进阶</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python进阶</tag>
        <tag>面向对象</tag>
        <tag>运算符重载</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路31-继承的利弊</title>
    <url>/2018/06/06/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF31-%E7%BB%A7%E6%89%BF%E7%9A%84%E5%88%A9%E5%BC%8A/</url>
    <content><![CDATA[<blockquote>
<p>《流畅的Python》笔记</p>
<p>本篇是“面向对象惯用方法”的第五篇，我们将继续讨论继承，重点说明两个方面：继承内置类型时的问题以及多重继承。概念比较多，较为枯燥。</p>
</blockquote>
<a id="more"></a>
<h1 id="继承内置类型">1. 继承内置类型</h1>
<p><strong>内置类型（C语言编写）的方法通常会忽略用户重写的方法</strong>，这种行为体现在两方面：</p>
<ul>
<li>内置类型<code>A</code>的子类<code>ChildA</code>即使重写了<code>A</code>中的方法，当<code>ChildA</code>调用这些方法时，也不一定调用的就是重写的版本，而依然可能调用<code>A</code>中的版本；</li>
<li>内置类型<code>B</code>调用<code>ChildA</code>的方法时，调用的也不一定是被<code>ChildA</code>重写的方法，可能依然会调用<code>A</code>的版本。</li>
</ul>
<p>以<code>dict</code>的<code>__getitem__</code>方法为例，即使这个方法被子类重写了，内置类型的<code>get()</code>方法也不一定调用重写的版本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码1.1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyDict</span><span class="params">(dict)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">"Test"</span>   <span class="comment"># 不管要获取谁，都返回"Test"</span></span><br><span class="line"><span class="meta">... </span>   </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>child = MyDict(&#123;<span class="string">"one"</span>:<span class="number">1</span>, <span class="string">"two"</span>:<span class="number">2</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>child</span><br><span class="line">&#123;<span class="string">'one'</span>: <span class="number">1</span>, <span class="string">'two'</span>: <span class="number">2</span>&#125;    <span class="comment"># 正常</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>child[<span class="string">"one"</span>]</span><br><span class="line"><span class="string">'Test'</span>    <span class="comment"># 此时也是正常的</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>child.get(<span class="string">"one"</span>)</span><br><span class="line"><span class="number">1</span>   <span class="comment"># 这里就不正常了，按理说应该返回"Test"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.update(child)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b  <span class="comment"># 并没有调用child的__getitem__方法</span></span><br><span class="line">&#123;<span class="string">'one'</span>: <span class="number">1</span>, <span class="string">'two'</span>: <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>
<p>这是在CPython中的情况，这些行为其实违背了面向对象编程的一个基本原则，即应该始终从实例所属的类开始搜索方法，即使在超类实现的类中调用也应该如此。但实际是可能直接调用基类的方法，而不先搜索子类。这种设定并不能说是错误的，这只是一种取舍，毕竟这也是CPython中的内置类型运行得快的原因之一，但这种方式就给我们出了难题。这种问题的解决方法有两个：</p>
<ul>
<li>重写从内置类型继承来的所有方法（要真这样，那我还继承干啥？），或者查看源码，把相关的方法都给重写了（谁的记性能这么好？）；</li>
<li>第二种方法才是<strong>推荐</strong>的方法：<strong>如果要继承内置类型，请从<code>collections</code>模块中继承</strong>，比如继承自<code>UserList</code>、<code>UserDict</code>，<code>UserString</code>。这些类不是用C语言写的，而是用纯Python写的，并且严格遵循了上述面向对象的原则。如果上述代码中的<code>MyDict</code>继承自<code>UserDict</code>，行为则会合乎预期。</li>
</ul>
<p><strong><em>强调</em></strong>：本节所述问题只发生在C语言实现的内置类型内部的方法委托上，而且只影响直接继承内置类型的自定义类。如果子类继承自纯Python编写的类，则不会有此问题。</p>
<h1 id="多重继承">2.多重继承</h1>
<p>任何实现多重继承的语言都要处理潜在的命名冲突，这种冲突由不相关的超类实现同名方法引起。这种冲突称为”菱形冲突“。</p>
<h2 id="多重继承的示例">2.1 多重继承的示例</h2>
<p>下面是我们要实现的类的UML图：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1528263252/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF31-%E7%BB%A7%E6%89%BF%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9/multiple_inheritance.png" /></p>
<p>红线表示超类的调用顺序，以下是它的实现：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码2.1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ping</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"ping in A:"</span>, self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pong</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"pong in B:"</span>, self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pong</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"PONG in C:"</span>, self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B, C)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ping</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().ping()</span><br><span class="line">        print(<span class="string">"ping in D:"</span>, self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pingpong</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.ping()</span><br><span class="line">        super().ping()</span><br><span class="line">        self.pong()</span><br><span class="line">        super().pong()</span><br><span class="line">        C.pong(self)   <span class="comment"># 在定义时调用特定父类的写法，显示传入self参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面是它在控制台中的调用情况</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> diamond <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = D()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.pong()</span><br><span class="line">pong <span class="keyword">in</span> B: &lt;mytest.D object at <span class="number">0x0000013E66313048</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.pingpong()</span><br><span class="line">ping <span class="keyword">in</span> A: &lt;mytest.D object at <span class="number">0x0000013E66313048</span>&gt;   <span class="comment"># self.ping()</span></span><br><span class="line">ping <span class="keyword">in</span> D: &lt;mytest.D object at <span class="number">0x0000013E66313048</span>&gt;</span><br><span class="line">ping <span class="keyword">in</span> A: &lt;mytest.D object at <span class="number">0x0000013E66313048</span>&gt;   <span class="comment"># super().ping()</span></span><br><span class="line">pong <span class="keyword">in</span> B: &lt;mytest.D object at <span class="number">0x0000013E66313048</span>&gt;   <span class="comment"># self.pong()</span></span><br><span class="line">pong <span class="keyword">in</span> B: &lt;mytest.D object at <span class="number">0x0000013E66313048</span>&gt;   <span class="comment"># super().pong()</span></span><br><span class="line">PONG <span class="keyword">in</span> C: &lt;mytest.D object at <span class="number">0x0000013E66313048</span>&gt;   <span class="comment"># C.pong(self)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C.pong(d)    <span class="comment"># 在运行时调用特定父类的写法，显示传入实例参数</span></span><br><span class="line">PONG <span class="keyword">in</span> C: &lt;mytest.D object at <span class="number">0x0000013E66313048</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>D.__mro__   <span class="comment"># Method Resolutino Order，方法解析顺序，上一篇文章中有所提及</span></span><br><span class="line">(&lt;class 'mytest.D'&gt;, &lt;class 'mytest.B'&gt;, &lt;class 'mytest.C'&gt;, </span><br><span class="line"> &lt;class 'mytest.A'&gt;, &lt;class 'object'&gt;)</span><br></pre></td></tr></table></figure>
<p>类都有一个名为<code>__mro__</code> 的属性，它的值是一个元组，按一定顺序列举超类，这个顺序由<a href="https://www.python.org/download/releases/2.3/mro/" target="_blank" rel="noopener">C3算法</a>计算。</p>
<p>方法解析顺序不仅考虑继承图，还考虑子类声明中列出超类的顺序。例如，如果<code>D</code>类的声明改为<code>class D(C, B)</code>，那么<code>D</code>则会先搜索<code>C</code>，再搜索<code>B</code>。</p>
<p>若想把方法调用委托给超类，推荐的做法是使用内置的<code>super()</code>函数；同时，还请注意上述调用特定超类的语法。然而，使用<code>super()</code>是最安全的，也不易过时。调用框架或不受自己控制的类层次结构中的方法时，尤其应该使用<code>super()</code>。</p>
<h2 id="处理多重继承的建议">2.2 处理多重继承的建议</h2>
<p>继承有很多用途，而多重继承增加了可选方案和复杂度。使用多重继承容易得出令人费解和脆弱的设计。以下是8条避免产生混乱类图的建议：</p>
<ol type="1">
<li><p><strong>把接口继承和实现继承区分开</strong></p>
<p>在使用多重继承时，一定要明白自己为什么要创建子类：</p>
<ul>
<li>继承接口，创建子类，实现“是什么（”is-a”）”关系；</li>
<li>继承实现，通过重用避免代码重复</li>
</ul>
<p>其实这俩经常同时出现，不过只要有可能，一定要明确这么做的意图。通过继承重用代码是实现细节，通常可以换成用组合和委托的模式，而接口继承则是框架的支柱。</p></li>
<li><p><strong>使用抽象基类显示表示接口</strong></p>
<p>如果类的作用是定义接口，应该将其明确定义为抽象基类。</p></li>
<li><p><strong>通过“混入类”实现代码重用</strong></p>
<p>如果一个类的作用是为多个不相关的子类提供方法实现，从而实现重用，但不体现“is-a”关系，则应该把那个类明确定义为<strong>混入类</strong>(mixin class)。从概念上讲，混入不定义新类型，只是打包方法，便于重用。混入类绝对不能实例化，而且具体类不能只继承混入类。混入类应该提供某方面的特定行为，只实现少量关系非常紧密的方法。</p></li>
<li><p><strong>在名称中明确指明混入</strong></p>
<p>由于Python没有把类明确声明为混入的正式方式，实际的做法是在类名后面加入<code>Mixin</code>后缀。Python的GUI库Tkinter没有采用这种方法，这也是它的类图十分混乱的原因之一，而Django则采用了这种方式。</p></li>
<li><p><strong>抽象基类可以作为混入类，但混入类不能作为抽象基类</strong></p>
<p>抽象基类可以实现具体方法，因此可以作为混入类使用。但抽象基类能定义数据类型，混入类则做不到。此外，抽象基类可以作为其他类的唯一基类，混入类则决不能作为唯一的基类，除非这个混入类继承了另一个更具体的混入（这种做法非常少见）。</p>
<p>但值得注意的是，抽象基类中的具体方法只是一种便利措施，因为它只能调用抽象基类及其超类中定义了的方法，那么用户自行调用这些方法也可以实现同样的功能，所以，抽象基类也并不常作为混入类。</p></li>
<li><p><strong>不要从多个具体类继承</strong></p>
<p>应该尽量保证具体类没有或者最多只有一个具体超类。也就是说，具体类的超类中除了这一个具体超类外，其余的都应该是抽象基类或混入类。</p></li>
<li><p><strong>为用户提供聚合类</strong></p>
<p><strong>如果抽象基类或混入类的组合对客户代码非常有用</strong>，那就提供一个类，使用易于理解的方式把它们结合起来，这种类被称为聚合类。比如<code>tkinter.Widget</code>类，它的定义如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码2.2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span><span class="params">(BaseWidget, Pack, Place, Grid)</span>:</span>  <span class="comment"># 省略掉了文档注释</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>它的定义体是空的，但通过这一个类，提供了四个超类的全部方法。</p></li>
<li><p><strong>优先使用对象组合，而不是类继承</strong></p>
<p>优先使用组合能让设计更灵活。即便是单继承，这个原则也能提升灵活性，因为继承是一种紧耦合，而且较高的继承树容易倒。组合和委托还可以代替混入类，把行为提供给不同的类，但它不能取代接口继承，因为接口继承定义的是类层次结构。</p></li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python进阶</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python进阶</tag>
        <tag>面向对象</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路30-接口：从协议到抽象基类</title>
    <url>/2018/06/05/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF30-%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E5%8D%8F%E8%AE%AE%E5%88%B0%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB/</url>
    <content><![CDATA[<blockquote>
<p>《流畅的Python》笔记。</p>
<p>本篇是“面向对象惯用方法”的第四篇，主要讨论接口。本篇内容将从鸭子类型的动态协议，逐渐过渡到使接口更明确、能验证实现是否符合规定的抽象基类(Abstract Base Class, ABC)。</p>
</blockquote>
<a id="more"></a>
<h1 id="前言">1. 前言</h1>
<p>本篇讨论Python中接口的实现问题，主要内容如下：</p>
<ul>
<li>补充用鸭子协议实现部分接口的一种重要方法：猴子补丁；</li>
<li>说明抽象基类的常见用途，即，实现接口时作为超类使用；</li>
<li>说明抽象基类如何检查具体子类是否符合接口定义，以及如何使用注册机制声明一个类实现了某个接口；</li>
<li>说明如何不通过子类化或注册，也能让抽象基类自动“识别”任何符合接口的类。</li>
</ul>
<p><strong>补充在正文之前</strong>：</p>
<ul>
<li>在Python中，“X类对象”，“X协议”和“X接口”都是一个意思。并且，除了抽象基类，类实现或继承的公开属性（方法或数据属性），包括特殊方法，都可以看做接口。</li>
<li>关于接口，还有一个很实用的补充定义：对象公开方法的子集，让对象在系统中扮演特定的角色。</li>
</ul>
<h1 id="猴子补丁">2. 猴子补丁</h1>
<p>猴子补丁并不是Python特有，它指动态语言中，不用修改源代码，在运行时就能对代码的功能进行动态的追加或变更。下面的代码展示了猴子补丁的用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码2.1</span></span><br><span class="line"><span class="comment"># 在文件中定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, iterable)</span>:</span></span><br><span class="line">        self._data = list(iterable)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._data[index]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面的代码在控制台运行</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> random <span class="keyword">import</span> shuffle</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> my_list <span class="keyword">import</span> MyList</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mylist = MyList(range(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">set_item</span><span class="params">(temp, i, item)</span>:</span></span><br><span class="line"><span class="meta">... </span>    temp._data[i] = item</span><br><span class="line"><span class="meta">... </span>   </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>MyList.__setitem__ = set_item</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shuffle(mylist)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck[:]</span><br><span class="line">[<span class="number">6</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure>
<p><strong>解释</strong>：</p>
<ul>
<li>Python中，交互式控制台中也支持猴子补丁；</li>
<li>要使用<code>random.shuffle</code>函数，对象必须实现<code>__setitem__</code>方法，上述代码在运行时动态添加所需方法；</li>
<li>猴子补丁很强大，但打补丁的代码与要打补丁的程序耦合十分紧密，而且往往要处理隐藏的部分（比如“受保护的”属性）和没有文档的部分。</li>
<li>上述代码中<code>set_item</code>函数的第一个参数并不是<code>self</code>，这是想说明，每个Python方法说到底都是普通函数，把第一个参数命名为<code>self</code>只是一种约定（但别随意打破这种约定）。</li>
</ul>
<p>这里之所以讲猴子补丁，主要是为了说明<strong>协议可以是动态的</strong>：即使对象最初没有实现某个协议，当需要时，我们也能为它动态添加。</p>
<h1 id="抽象基类">3. 抽象基类</h1>
<p>介绍完动态实现接口后，现在开始讨论抽象基类，它属于静态显示地实现接口。</p>
<h2 id="基本概要说明">3.1 基本概要说明</h2>
<p>有时候我们需要明确区分“抽象类”（并不是指“抽象基类”）与“接口”：以自然界为例，“抽象类”一般用于<strong>同一物种同一行为</strong>，而“接口”则用于<strong>不同物种同一行为</strong>。当然，这两个概念有交叉的部分，某些行为既可以归到“接口“，也可以归到”抽象类“，而最后归到谁就见仁见智了。但这两个概念又有很大的相似之处，它们的实质都是：<strong>让某些对象拥有同名的方法或属性，但具体实现不一定相同</strong>。</p>
<p>Java更注重这两者的特性，而Python、C++则更注重这两者的共性。也因此，Java不支持多重继承（当然，也是为了降低复杂性），用明确的接口类<code>interface</code>来区分与<code>abstract class</code>；而在Python和C++中，则用<strong>抽象基类充当接口</strong>。所以，在Python中，<strong>直接</strong>继承自抽象基类，更多表明的是”要实现某种接口或协议“，而非”要新建某个具体类的子类“。</p>
<p>如果要测试是否继承自抽象基类，推荐使用<code>isinstance</code>和<code>issubclass</code>方法，而不是<code>is</code>运算。但也不要滥用这类方法，因为这种代码用多了说明面向对象设计得不好。</p>
<p>说道<code>isinstance</code>，还有个与之相关的概念，相当于“鸭子类型”的强化版：</p>
<ul>
<li>白鹅类型(goose typing)：只要<code>cls</code>是抽象基类，即<code>cls</code>的元素是<code>abc.ABCMeta</code>，就可以使用<code>isinstance(obj, cls)</code>。</li>
</ul>
<p><strong><em>小插曲</em></strong>：这是书中给出的标准定义，笔者读到这的时候一脸懵逼。“白鹅类型”是个名词，但这定义却是对一个过程的描述，所以“白鹅类型”到底是个啥（这到底是翻译的锅还是作者的锅）？后来谷歌了一下，再自己反复推敲，得出如下总结：鸭子类型是指某个实例实现了某个方法，就可以说它属于某个类型，不一定要继承；而白鹅类型则是指<strong>能被判定成某抽象基类的子类的实例</strong>，即，<strong>能使<code>isinstance(obj, cls)</code>返回<code>True</code>的<code>obj</code>就是白鹅类型</strong>，其中<code>cls</code>是抽象基类。<strong>注意</strong>，这些子类并不一定是通过继承而来，也可能是通过注册而来，还可能是通过实现某些方法而来。</p>
<p><strong><em>特别提醒</em></strong>：对于抽象基类（还有元类）的使用，并<strong>不建议在生产代码中自行定义新的抽象基类和元类</strong>。定义抽象基类和元类的工作一般由比较资深的Python程序员来做，适用于写框架的程序员。而即便是资深Python程序员也不常自己定义抽象基类和元类。</p>
<h2 id="标准库中的抽象基类">3.2 标准库中的抽象基类</h2>
<p>从Python2.6开始，标准库提供了抽象基类。大多数抽象基类在<code>collections.abc</code>模块中定义，<code>numbers</code>和<code>io</code>中也有一些。</p>
<p>以下是<code>collections.abc</code>中16个抽象基类的UML图（关于多重继承的内容将在以后的文章中讲解）：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1528199159/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF30-%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E5%8D%8F%E8%AE%AE%E5%88%B0%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB/collections-abc.png" /></p>
<p>有几个抽象基类值得注意：</p>
<ul>
<li><code>Iterable</code>、<code>Container</code>和<code>Sized</code>：各个集合类应该继承这三个抽象基类，或者至少实现兼容的协议。<code>Iterable</code>通过<code>__iter__</code>方法支持迭代；<code>Container</code>通过<code>__contains__</code>方法支持<code>in</code>运算；<code>Sized</code>通过<code>__len__</code>方法支持<code>len()</code>函数；</li>
<li><code>Sequence</code>、<code>Mapping</code>和<code>Set</code>：这三个是主要的不可变集合类型，而且各自都有可变的子类，即<code>MutableSequence</code>、<code>MutableMapping</code>和<code>MutableSet</code>。</li>
<li><code>Callable</code>和<code>Hashable</code>：从图上可以看出，这两个抽象基类在标准库中没有子类。</li>
</ul>
<p>在<code>numbers</code>包中的抽象基类的继承关系则很简单，都是线性的（“数字塔”）。下面5个类从左到右依次派生：</p>
<ul>
<li><code>Number</code>，<code>Complex</code>，<code>Real</code>，<code>Rational</code>，<code>Integral</code></li>
</ul>
<p>下面我们将自行定义一个抽象基类并继承出它的子类。但这并不是鼓励各位在生产代码中自定义抽象基类！</p>
<h2 id="自定义抽象基类">3.3 自定义抽象基类</h2>
<p>我们将模拟一个随机抽奖机，它的抽象基类是<code>Tombola</code>，它的4个方法如下：</p>
<ul>
<li><code>.load(...)</code>：抽象方法，把元素放入容器；</li>
<li><code>.pick()</code>：抽象方法，从容器中随机返回一个元素，并从容器中删除该元素；</li>
<li><code>.loaded()</code>：当容器不为空是返回<code>True</code>；</li>
<li><code>.inspect()</code>：返回一个有序元组，由容器中的现有元素构成，不修改容器的内容（容器内部元素顺序不保留）。</li>
</ul>
<p>它和它的三个子类的UML图如下：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1528200583/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF30-%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E5%8D%8F%E8%AE%AE%E5%88%B0%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB/tombola.png" /></p>
<p>以下是<code>Tombola</code>的定义：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码3.1</span></span><br><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tombola</span><span class="params">(abc.ABC)</span>:</span></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load</span><span class="params">(self, iterable)</span>:</span></span><br><span class="line">        <span class="string">"""从可迭代对象中添加元素"""</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""随机删除元素，然后将其返回。</span></span><br><span class="line"><span class="string">        如果实例为空，这个方法应该抛出LookupError，</span></span><br><span class="line"><span class="string">        这个异常是IndexError和KeyError的基类"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loaded</span><span class="params">(self)</span>:</span>   <span class="comment"># 比较耗时，子类可重写</span></span><br><span class="line">        <span class="string">"""当容器不为空时返回True"""</span></span><br><span class="line">        <span class="keyword">return</span> bool(self.inspect())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inspect</span><span class="params">(self)</span>:</span>  <span class="comment"># 这只是提供一种实现方式，子类可覆盖该方法</span></span><br><span class="line">        <span class="string">"""返回一个有序元组，由当前元素构成"""</span></span><br><span class="line">        items = []</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:  <span class="comment"># 之所以这么获取元素，是因为不知道子类如何存储元素</span></span><br><span class="line">                items.append(self.pick())</span><br><span class="line">            <span class="keyword">except</span> LookupError:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        self.load(items)</span><br><span class="line">        <span class="keyword">return</span> tuple(sorted(items))</span><br></pre></td></tr></table></figure>
<p><strong><em>解释及补充</em></strong>：</p>
<ul>
<li>导入时，Python并不会检查抽象方法的实现，在运行时才会真正检测；</li>
<li>如果子类并没有实现抽象基类中所有的抽象方法，那么这个子类依然是抽象基类；</li>
<li>抽象方法中可以有实现代码。即便实现了，子类也必须覆盖抽象方法，但可以使用<code>super()</code>函数调用抽象方法，为它添加功能，而不是从头开始写；</li>
<li><strong>抽象基类中的具体方法只能依赖抽象基类定义的接口</strong>。</li>
<li>标准库中有两个名为<code>abc</code>的模块，一个是前面说的<code>collections.abc</code>，另一个就是这里的<code>abc</code>模块。只有在新定义抽象基类的时候才用得到<code>abc.ABC</code>，每个抽象基类都依赖这个类。</li>
</ul>
<p>在<code>abc</code>模块中本来还有<code>@abstractclassmethod</code>，<code>@abstractstaticmethod</code>和<code>@abstractproperty</code>三个装饰器，但这三个从Python3.3起被废除了，因为这三个的功能都能在<code>@abstractmethod</code>上堆叠其他装饰器得到，比如实现<code>@abstractclassmethod</code>的功能：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码3.2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyABC</span><span class="params">(abc.ABC)</span>:</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">an_abstract_classmethod</span><span class="params">(cls, ...)</span>:</span> <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h2 id="定义子类">3.4 定义子类</h2>
<p>以下是它的两个子类的实现代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># # 代码3.3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BingoCage</span><span class="params">(Tombola)</span>:</span>  <span class="comment"># loaded()和inspect()延用抽象基类的实现</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, items)</span>:</span></span><br><span class="line">        self._randomizer = random.SystemRandom()  <span class="comment"># 它会调用os.urandom()</span></span><br><span class="line">        self._items = []</span><br><span class="line">        self.load(items)   <span class="comment"># 委托给load()方法实现初始加载</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load</span><span class="params">(self, items)</span>:</span>  <span class="comment"># 必须实现抽象方法！</span></span><br><span class="line">        self._items.extend(items)</span><br><span class="line">        self._randomizer.shuffle(self._items)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self)</span>:</span>  <span class="comment"># 必须实现抽象方法！</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self._items.pop()</span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            <span class="keyword">raise</span> LookupError(<span class="string">"pick from empty BingoCage"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.pick()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LotteryBlower</span><span class="params">(Tombola)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, iterable)</span>:</span></span><br><span class="line">        self._balls = list(iterable)  <span class="comment"># 副本</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load</span><span class="params">(self, iterable)</span>:</span></span><br><span class="line">        self._balls.extend(iterable)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            position = random.randrange(len(self._balls))</span><br><span class="line">        <span class="keyword">except</span> ValueError:  <span class="comment"># 为了兼容Tombola，并不是抛出ValueError</span></span><br><span class="line">            <span class="keyword">raise</span> LookupError(<span class="string">"pick from empty LotteryBlower"</span>)</span><br><span class="line">        <span class="keyword">return</span> self._balls.pop(position)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loaded</span><span class="params">(self)</span>:</span>  <span class="comment"># 覆盖了抽象基类低效的版本</span></span><br><span class="line">        <span class="keyword">return</span> bool(self._balls)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inspect</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> tuple(sorted(self._balls))</span><br></pre></td></tr></table></figure>
<h2 id="虚拟子类">3.5 虚拟子类</h2>
<p>上面两个子类都是直接继承自<code>Tombola</code>，而白鹅类型有一个基本<strong>特性</strong>：即便不用继承，也能将一个类注册为抽象基类的虚拟子类。下面是<code>TomboList</code>的实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码3.4</span></span><br><span class="line"><span class="meta">@Tombola.register  # 把TomboList注册为Tombola的虚拟子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TomboList</span><span class="params">(list)</span>:</span>  <span class="comment"># 它同时还是list的真实子类，而list其实是MutableSequence的虚拟子类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self:</span><br><span class="line">            position = random.randrange(len(self))</span><br><span class="line">            <span class="keyword">return</span> self.pop(position)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> LookupError(<span class="string">"pick from empty LotteryBlower"</span>)</span><br><span class="line"></span><br><span class="line">    load = list.extend  <span class="comment"># 当我看到居然这么实现方法时，感觉自己好肤浅......</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loaded</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> bool(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inspect</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> tuple(sorted(self))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Tombola.register(TomboList) 这是register的函数调用版本</span></span><br></pre></td></tr></table></figure>
<p>下面是这个子类的简单使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码3.5</span></span><br><span class="line">&gt;&gt;&gt; issubclass(TomboList, Tombola)</span><br><span class="line">True   <span class="comment"># TomboList是Tombola的子类</span></span><br><span class="line">&gt;&gt;&gt; t = TomboList(range(100))</span><br><span class="line">&gt;&gt;&gt; isinstance(t, Tombola)</span><br><span class="line">True   <span class="comment"># TomboList的实例也是Tombola类型</span></span><br><span class="line">&gt;&gt;&gt; TomboList.__mro__</span><br><span class="line">(&lt;class <span class="string">'mytest.TomboList'</span>&gt;, &lt;class <span class="string">'list'</span>&gt;, &lt;class <span class="string">'object'</span>&gt;)</span><br><span class="line">&gt;&gt;&gt; TomboList.__subclasses__()</span><br><span class="line">[&lt;class <span class="string">'mytest.BingoCage'</span>&gt;, &lt;class <span class="string">'mytest.LotteryBlower'</span>&gt;]</span><br></pre></td></tr></table></figure>
<p><strong><em>解释及补充</em></strong>：</p>
<ul>
<li>虚拟子类不会继承注册的抽象基类，而且任何时候都不会检查它是否符合抽象基类的接口，即便在实例化时也不会检查（如果你的虚拟子类没有实现抽象方法，在实例化时不会报错，但如果是继承而来的话则会报错），所以为了避免运行时错误，虚拟子类应该实现抽象基类的全部方法；</li>
<li>类的继承关系存储在一个特殊的类属性<code>__mro__</code>中，即方法解析顺序(Method Resolution Order)。它按顺序列出类及其超类，Python则会按照这个顺序搜索方法。从上述结果可以看出，这个属性只存储了“真实的”超类。</li>
<li><code>__subclasses__</code>方法返回类的直接子类列表，不含虚拟子类；</li>
<li>虽然现在<code>register</code>可以当做装饰器用，但更常用的做法还是把它当函数使用。</li>
</ul>
<h2 id="另一种虚拟子类">3.6 另一种虚拟子类</h2>
<p>鹅的行为有可能像鸭子。先看如下代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码3.6</span></span><br><span class="line">&gt;&gt;&gt; class Struggle:</span><br><span class="line">...     def __len__(self): <span class="built_in">return</span> 23</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; from collections import abc</span><br><span class="line">&gt;&gt;&gt; isinstance(Struggle(), abc.Sized)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; issubclass(Struggle, abc.Sized)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>这里既没有继承，也没有注册，但<code>Struggle</code>依然被<code>issubclass</code>判断为<code>abc.Sized</code>的子类。之所以会这样，是因为<code>abc.Sized</code>实现了一个特殊的类方法<code>__subclasshook__</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># # 代码3.7，abc.Sized的实现在 _collections_abc.py 中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sized</span><span class="params">(metaclass=ABCMeta)</span>:</span></span><br><span class="line"></span><br><span class="line">    __slots__ = ()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__subclasshook__</span><span class="params">(cls, C)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">is</span> Sized:</span><br><span class="line">            <span class="comment"># 源代码中是 return _check_methods(C, "__len__")，这里修改了一下</span></span><br><span class="line">            <span class="keyword">if</span> any(<span class="string">"__len__"</span> <span class="keyword">in</span> B.__dict__ <span class="keyword">for</span> B <span class="keyword">in</span> C.__mro__):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br></pre></td></tr></table></figure>
<p>这像不像鸭子类型？只要实现了<code>__len__</code>方法，这个类就是<code>abc.Sized</code>的子类。</p>
<p>在自定义的抽象基类中并不一定要实现<code>__subclasshook__</code>方法，因为即使在Python源码中，目前也只见到<code>Sized</code>这一个抽象基类实现了<code>__subclasshook__</code>方法，而且<code>Sized</code>只有一个特殊方法。在决定自行实现<code>__subclasshook__</code>方法之前，请想清楚你一定需要这个方法吗？你的能力能够保证这个方法的可靠性吗？</p>
<h1 id="总结">4. 总结</h1>
<p>本篇讨论的话题只有一个，即“接口”。首先我们讨论了鸭子类型的高度动态性，它实现的是动态协议，也是非正式接口；随后我们借助“白鹅类型”，使用抽象基类明确地、显示地声明接口，然后通过子类或注册来实现这些接口。期间，我们自定义了一个抽象基类，并通过继承实现了它的两个子类，还通过注册实现了它的一个虚拟子类。</p>
<p>最后，还是那句话：不要轻易自定义抽象基类，除非你想构件允许用户扩展的框架。日常使用中，我们与抽象基类的联系应该是创建现有抽象基类的子类，或者使用现有的抽象基类注册。自己从头编写新抽象基类的情况非常少。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python进阶</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python进阶</tag>
        <tag>面向对象</tag>
        <tag>接口</tag>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路29-序列的修改、散列和切片</title>
    <url>/2018/06/03/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF29-%E5%BA%8F%E5%88%97%E7%9A%84%E4%BF%AE%E6%94%B9%E3%80%81%E6%95%A3%E5%88%97%E5%92%8C%E5%88%87%E7%89%87/</url>
    <content><![CDATA[<blockquote>
<p>《流畅的Python》笔记。</p>
<p>本篇是“面向对象惯用方法”的第三篇。本篇将以上一篇中的Vector2d为基础，定义多维向量Vector。</p>
</blockquote>
<a id="more"></a>
<h1 id="前言">1. 前言</h1>
<p>自定义<code>Vector</code>类的行为将与Python标准中的不可变扁平序列一样，它将支持如下功能：</p>
<ul>
<li>基本的序列协议：<code>__len__</code>和<code>__getitem__</code>；</li>
<li>正确表述拥有很多元素的实例；</li>
<li>适当的切片支持，用于生成新的<code>Vector</code>实例；</li>
<li>综合各个元素的值计算散列值；</li>
<li>自定义的格式语言扩展。</li>
</ul>
<p>本篇还将通过<code>__getattr__</code>方法实现属性的动态存取（虽然序列类型通常不会这么做），以及穿插讨论一个概念：把协议当做正式接口。我们将说明协议和<strong>鸭子类型</strong>之间的关系，以及对自定义类型的影响。</p>
<h1 id="初版vector">2. 初版Vector</h1>
<p><code>Vector</code>的构造方法将和所有内置序列类型一样，以可迭代对象为参数。如果其中元素过多，<code>repr()</code>函数返回的字符串将会使用<code>...</code>省略一部分内容，它的初始版本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码1</span></span><br><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    typecode = <span class="string">"d"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, components)</span>:</span>  <span class="comment"># 以可迭代对象为参数</span></span><br><span class="line">        self._components = array(self.typecode, components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> iter(self._components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        components = reprlib.repr(self._components)</span><br><span class="line">        components = components[components.find(<span class="string">"["</span>):<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Vector(&#123;&#125;)"</span>.format(components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>   <span class="comment"># 和Vector2d相同</span></span><br><span class="line">        <span class="keyword">return</span> str(tuple(self))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bytes__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (bytes([ord(self.typecode)]) + bytes(self._components))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span>   <span class="comment"># 和Vector2d相同</span></span><br><span class="line">        <span class="keyword">return</span> tuple(self) == tuple(other)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> math.sqrt(sum(x * x <span class="keyword">for</span> x <span class="keyword">in</span> self))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span>   <span class="comment"># 和Vector2d相同</span></span><br><span class="line">        <span class="keyword">return</span> bool(abs(self))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">frombytes</span><span class="params">(cls, octets)</span>:</span></span><br><span class="line">        typecode = chr(octets[<span class="number">0</span>])</span><br><span class="line">        memv = memoryview(octets[<span class="number">1</span>:]).cast(typecode)</span><br><span class="line">        <span class="keyword">return</span> cls(memv)   <span class="comment"># 去掉了Vector2d中的星号*</span></span><br></pre></td></tr></table></figure>
<p>之所以没有直接继承制<code>Vector2d</code>，既是因为这两个类的构造方法不兼容，也是因为我们要为<code>Vector</code>实现序列协议。</p>
<h1 id="协议和鸭子类型">3. 协议和鸭子类型</h1>
<p>协议和鸭子类型在之前的文章中也有所提及。在面向对象编程中，<strong>协议是非正式的接口</strong>，只在文档中定义，在代码中不定义。</p>
<p>在Python中，只要实现了协议需要的某些方法，其实就算实现了协议，而<strong>不一定需要继承</strong>。比如只要实现了<code>__len__</code>和<code>__getitem__</code>这两个方法，那么这个类就是满足序列协议的，而不需要从什么“序列基类”继承。</p>
<p>鸭子类型：和现实中相反，Python中确定一个东西是不是“鸭子”，不是测它的“DNA”是不是”鸭子“的DNA，而是看这东西像不像只鸭子。只要像”鸭子“，那它就是“鸭子”。比如，只要一个类实现了<code>__len__</code>和<code>__getitem__</code>方法，那它就是序列类，而不必管它是从哪来的；文件类对象也常是鸭子类型。</p>
<h1 id="第2版vector支持切片">4. 第2版Vector：支持切片</h1>
<p>让<code>Vector</code>变为序列类型，并能正确返回切片：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码2，将以下代码添加到初版Vector中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    -- snip --</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._components)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        cls = type(self)</span><br><span class="line">        <span class="keyword">if</span> isinstance(index, slice):  <span class="comment"># 如果index是个切片类型，则构造新实例</span></span><br><span class="line">            <span class="keyword">return</span> cls(self._components[index])</span><br><span class="line">        <span class="keyword">elif</span> isinstance(index, numbers.Integral):  <span class="comment"># 如果index是个数，则直接返回</span></span><br><span class="line">            <span class="keyword">return</span> self._components[index]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            msg = <span class="string">"&#123;cls.__name__&#125; indices must be integers"</span></span><br><span class="line">            <span class="keyword">raise</span> TypeError(msg.format(cls=cls))</span><br></pre></td></tr></table></figure>
<p>如果<code>__getitem__</code>函数直接返回切片：<code>return self._components[index]</code>，那么得到的数据将是<code>array</code>类型，而不是<code>Vector</code>类型。正是为了使切片的类型正确，这里才做了类型判断。</p>
<p>上述代码中用到了<code>slice</code>类型，它是Python的内置类型，这里顺便补充一下<strong>切片原理</strong>，直接上代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码3</span></span><br><span class="line">&gt;&gt;&gt; class MySeq:</span><br><span class="line">...     def __getitem__(self, index):</span><br><span class="line">...         <span class="built_in">return</span> index  <span class="comment"># 直接返回传给它的值</span></span><br><span class="line">...    </span><br><span class="line">&gt;&gt;&gt; s = MySeq()</span><br><span class="line">&gt;&gt;&gt; s[1]   </span><br><span class="line">1  <span class="comment"># 单索引，没啥新奇的</span></span><br><span class="line">&gt;&gt;&gt; s[1:3]</span><br><span class="line">slice(1, 3, None)  <span class="comment"># 返回来一个slice类型</span></span><br><span class="line">&gt;&gt;&gt; s[1:10:2]</span><br><span class="line">slice(1, 10, 2)    <span class="comment"># 注意slice类型的结构</span></span><br><span class="line">&gt;&gt;&gt; s[1:10:2, 9]</span><br><span class="line">(slice(1, 10, 2), 9)   <span class="comment"># 如果[]中有逗号，__getitem__收到的是元组</span></span><br><span class="line">&gt;&gt;&gt; s[1:10:2, 7:9]</span><br><span class="line">(slice(1, 10, 2), slice(7, 9, None))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; dir(slice)  <span class="comment"># 注意最后四个元素</span></span><br><span class="line">[<span class="string">'__class__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, </span><br><span class="line"><span class="string">'__getattribute__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__init_subclass__'</span>, <span class="string">'__le__'</span>,</span><br><span class="line"><span class="string">'__lt__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>,</span><br><span class="line"><span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'indices'</span>, <span class="string">'start'</span>, <span class="string">'step'</span>, <span class="string">'stop'</span>]</span><br></pre></td></tr></table></figure>
<p>当我们用<code>dir()</code>函数获取<code>slice</code>的属性时，发现它有<code>start</code>，<code>stop</code>和<code>step</code>数据属性，并且还有一个<code>indices</code>方法，这里重点说说这个<code>indices</code>方法。它接收一个长度参数<code>len</code>，并根据这个<code>len</code>将<code>slice</code>类型的<code>start</code>，<code>stop</code>和<code>step</code>三个参数正确转换成在长度范围内的非负数，具体用法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码4</span></span><br><span class="line">&gt;&gt;&gt; slice(None, 10, 2).indices(5)</span><br><span class="line">(0, 5, 2)  <span class="comment"># 将这些烦人的索引统统转换成明确的正向索引</span></span><br><span class="line">&gt;&gt;&gt; slice(-3, None, None).indices(5)</span><br><span class="line">(2, 5, 1)</span><br></pre></td></tr></table></figure>
<p>自定义<code>Vector</code>类中并没有使用这个方法，因为<code>Vector</code>的底层我们使用了<code>array.array</code>数据类型，切片的具体操作不用我们自行编写。但如果你的类没有这样的底层序列类型做支撑，那么<code>slice.indices</code>方法将为你节省大量时间。</p>
<h1 id="第3版vector动态存储属性">5. 第3版Vector：动态存储属性</h1>
<p>目前版本的<code>Vector</code>中，没有办法通过名称访问向量的分量（如<code>v.x</code>和<code>v.y</code>），而且现在的<code>Vector</code>可能存在大量分量。不过，如果能通过单个字母访问前几个分量的话，这样将很方便，也更人性化。现在，我们想用<code>x</code>，<code>y</code>，<code>z</code>，<code>t</code>四个字母分别代替<code>v[0]</code>，<code>v[1]</code>，<code>v[2]</code>和<code>v[3]</code>，但具体做法并不是为实例添加这四个属性，并且我们也不想在运行时实例能动态添加单个字母的属性，更不想实例能通过这四个字母修改<code>Vector</code>中<code>self._components</code>的值。换句话说，我们只想通过这四个字母提供一种较为方便的访问方式，仅此而已。而要实现这样的功能，则需要实现<code>__getattr__</code>和<code>__setattr__</code>方法，以下是它们的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码5.1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    -- snip --</span><br><span class="line">    </span><br><span class="line">    shortcut_name = <span class="string">"xyzt"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        cls = type(self)</span><br><span class="line">        <span class="keyword">if</span> len(name) == <span class="number">1</span>:   <span class="comment"># 如果属性是单个字母</span></span><br><span class="line">            pos = cls.shortcut_name.find(name)    </span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= pos &lt; len(self._components):  <span class="comment"># 判断是不是xyzt中的一个</span></span><br><span class="line">                <span class="keyword">return</span> self._components[pos]   </span><br><span class="line">        msg = <span class="string">"&#123;.__name__!r&#125; object has no attribute &#123;!r&#125;"</span>  <span class="comment"># 想要获取其他属性时则抛出异常</span></span><br><span class="line">        <span class="keyword">raise</span> AttributeError(msg.format(cls, name))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, name, value)</span>:</span></span><br><span class="line">        cls = type(self)</span><br><span class="line">        <span class="keyword">if</span> len(name) == <span class="number">1</span>:   <span class="comment"># 不允许创建单字母实例属性，即便是x,y,z,t</span></span><br><span class="line">            <span class="keyword">if</span> name <span class="keyword">in</span> cls.shortcut_name:  <span class="comment"># 如果name是xyzt中的一个，设置特殊的错误信息</span></span><br><span class="line">                error = <span class="string">"readonly attibute &#123;attr_name!r&#125;"</span></span><br><span class="line">            <span class="keyword">elif</span> name.islower():  <span class="comment"># 为小写字母设置特殊的错误信息</span></span><br><span class="line">                error = <span class="string">"can't set attributes 'a' to 'z' in &#123;cls_name!r&#125;"</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                error = <span class="string">""</span></span><br><span class="line">            <span class="keyword">if</span> error:   <span class="comment"># 当用户试图动态创建属性时抛出异常</span></span><br><span class="line">                msg = error.format(cls_name=cls.__name__, attr_name=name)</span><br><span class="line">                <span class="keyword">raise</span> AttributeError(msg)</span><br><span class="line">        super().__setattr__(name, value)</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ul>
<li><p>属性查找失败后，解释器会调用<code>__getattr__</code>方法。简单来说，对<code>my_obj.x</code>表达式，Python会检查<code>my_obj</code>实例有没有名为<code>x</code>的<strong>实例属性</strong>；如果没有，则到它所属的类中查找有没有名为<code>x</code>的<strong>类属性</strong>；如果还是没有，则顺着继承树继续查找。如果依然找不到，则会调用<code>my_obj</code>所属类中定义的<code>__getattr__</code>方法，传入<code>self</code>和属性名的字符串形式（如<code>'x'</code>）；</p></li>
<li><p><code>__getattr__</code>和<code>__setattr_</code>方法一般同时定义，否则对象的行为很容易出现不一致。比如，如果这里<strong>只</strong>定义<code>__getattr__</code>方法，则会出现如下尴尬的代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码5.2</span></span><br><span class="line">&gt;&gt;&gt; v = Vector(range(5))</span><br><span class="line">&gt;&gt;&gt; v</span><br><span class="line">Vector([0.0, 1.0, 2.0, 3.0, 4.0])</span><br><span class="line">&gt;&gt;&gt; v.x</span><br><span class="line">0.0</span><br><span class="line">&gt;&gt;&gt; v.x = 10  <span class="comment"># 按理说这里应该报错才对，因为不允许修改</span></span><br><span class="line">&gt;&gt;&gt; v.x</span><br><span class="line">10</span><br><span class="line">&gt;&gt;&gt; v  <span class="comment"># 其实是v创建了新实例属性x，这也是为什么我们要定义__setattr__</span></span><br><span class="line">Vector([0.0, 1.0, 2.0, 3.0, 4.0])   <span class="comment"># 行为不一致</span></span><br></pre></td></tr></table></figure></li>
<li><p>我们没有禁止动态添加属性，只是禁止为单个字母属性赋值，如果属性名的长度大于1，这样的属性是可以动态添加的；</p></li>
<li><p>如果你看过<a href="http://www.vpointer.net/articles/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF28-%E7%AC%A6%E5%90%88Python%E9%A3%8E%E6%A0%BC%E7%9A%84%E5%AF%B9%E8%B1%A1/" target="_blank" rel="noopener">上一篇文章</a>，那么你可能会想到用<code>__slots__</code>来禁止添加属性，但我们这里仍然选择实现<code>__setattr__</code>来实现此功能。<code>__slots__</code>属性最好只用于节省内存，而且仅在内存严重不足时才用它，别为了秀操作而写一些别人看着很别扭的代码（只写给自己看的除外）。</p></li>
</ul>
<h1 id="第4版vector散列和快速等值测试">6. 第4版Vector：散列和快速等值测试</h1>
<p>目前这个<code>Vector</code>是不可散列的，现在我们来实现<code>__hash__</code>方法。具体方法和<a href="http://www.vpointer.net/articles/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF28-%E7%AC%A6%E5%90%88Python%E9%A3%8E%E6%A0%BC%E7%9A%84%E5%AF%B9%E8%B1%A1/" target="_blank" rel="noopener">上一篇</a>一样，也是用各个分量的哈希值进行异或运算，由于<code>Vector</code>的分量可能很多，这里我们使用<code>functools.reduce</code>函数来归约异或值。同时，我们还将改写之前那个简洁版的<code>__eq__</code>，使其更高效（至少对大型向量来说更高效）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码6，请自行导入所需的模块</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    -- snip --</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">        hashs = (hash(x) <span class="keyword">for</span> x <span class="keyword">in</span> self._components)   <span class="comment"># 先求各个分量的哈希值</span></span><br><span class="line">        <span class="keyword">return</span> functools.reduce(operator.xor, hashs, <span class="number">0</span>)  <span class="comment"># 然后将所有哈希值归约成一个值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span> <span class="comment"># 不用像之前那样：生成元组只为使用元组的__eq__方法</span></span><br><span class="line">        <span class="keyword">return</span> len(self) == len(self) <span class="keyword">and</span> all(a == b <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(self, other))</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ul>
<li>此处的<code>__hash__</code>方法实际上执行的是一个映射归约的过程。每个分量被映射成了它们的哈希值，这些哈希值再归约成一个值；</li>
<li>这里的<code>functool.reduce</code>传入了第三个参数，并且建议最好传入第三个参数。传入第三个参数能避免这个异常：<code>TypeError: reduce() of empty sequence with no initial value</code>。如果序列为空，第三个参数就是返回值；否则，在归约中它将作为第一个参数；</li>
<li>在<code>__eq__</code>方法中先比较两序列的长度并不仅仅是一种捷径。<code>zip</code>函数并行遍历多个可迭代对象，如果其中一个耗尽，它会立即停止生成值，而且不发出警告；</li>
</ul>
<blockquote>
<p>补充一个小知识：<code>zip</code>函数和文件压缩没有关系，它的名字取自拉链头（zipper fastener），这个小物件把两个拉链条的链牙要合在一起，是不是很形象？</p>
</blockquote>
<h1 id="第5版vector格式化">7. 第5版Vector：格式化</h1>
<p><code>Vector2d</code>中，当传入<code>'p'</code>时，以极坐标的形式格式化数据；由于<code>Vector</code>的维度可能大于2，现在，当传入参数<code>'h'</code>时，我们使用球面坐标格式化数据，即<code>'&lt;r, Φ1, Φ2, Φ3&gt;'</code>。同时，还需要定义两个辅助方法：</p>
<ul>
<li><code>angle(n)</code>，用于计算某个角坐标；</li>
<li><code>angles()</code>，返回由所有角坐标构成的可迭代对象。</li>
</ul>
<p>至于这两个的数学原理就不解释了。以下是最后要添加的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码7</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    -- snip --</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">angle</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        r = math.sqrt(sum(x * x <span class="keyword">for</span> x <span class="keyword">in</span> self[n:]))</span><br><span class="line">        a = math.atan2(r, self[n - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> (n == len(self) - <span class="number">1</span>) <span class="keyword">and</span> (self[<span class="number">-1</span>] &lt; <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> math.pi * <span class="number">2</span> - a</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">angles</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (self.angle(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">1</span>, len(self)))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__format__</span><span class="params">(self, format_spec=<span class="string">""</span>)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> format_spec.endswith(<span class="string">"h"</span>):   <span class="comment"># 如果格式说明符以'h'结尾</span></span><br><span class="line">            format_spec = format_spec[:<span class="number">-1</span>]   <span class="comment"># 格式说明符前面部分保持不变</span></span><br><span class="line">            coords = itertools.chain([abs(self)], self.angles())  <span class="comment"># </span></span><br><span class="line">            outer_fmt = <span class="string">"&lt;&#123;&#125;&gt;"</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            coords = self</span><br><span class="line">            outer_fmt = <span class="string">"(&#123;&#125;)"</span></span><br><span class="line">        components = (format(c, format_spec) <span class="keyword">for</span> c <span class="keyword">in</span> coords)</span><br><span class="line">        <span class="keyword">return</span> outer_fmt.format(<span class="string">", "</span>.join(components))</span><br></pre></td></tr></table></figure>
<p><code>itertools.chain</code>函数生成生成器表达式，将多个可迭代对象连接成在一起进行迭代。关于生成器的更多内容将在以后的文章中介绍。</p>
<p>至此，多维<code>Vector</code>暂时告一段落。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python进阶</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python进阶</tag>
        <tag>面向对象</tag>
        <tag>序列</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路28-符合Python风格的对象</title>
    <url>/2018/06/02/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF28-%E7%AC%A6%E5%90%88Python%E9%A3%8E%E6%A0%BC%E7%9A%84%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<blockquote>
<p>《流畅的Python》笔记。</p>
<p>本篇是“面向对象惯用方法”的第二篇。前一篇讲的是内置对象的结构和行为，本篇则是自定义对象。本篇继续“Python学习之路20”，实现更多的特殊方法以让自定义类的行为跟真正的Python对象一样。</p>
</blockquote>
<a id="more"></a>
<h1 id="前言">1. 前言</h1>
<p>本篇要讨论的内容如下，重点放在了对象的各种输出形式上：</p>
<ul>
<li>实现用于生成对象其他表示形式的内置函数（如<code>repr()</code>，<code>bytes()</code>等）；</li>
<li>使用一个类方法实现备选构造方法；</li>
<li>扩展内置的<code>format()</code>函数和<code>str.format()</code>方法使用的格式微语言；</li>
<li>实现只读属性；</li>
<li>实现对象的可散列；</li>
<li>利用<code>__slots__</code>节省内存；</li>
<li>如何以及何时使用<code>@classmethod</code>和<code>@staticmethd</code>装饰器；</li>
<li>Python的私有属性和受保护属性的用法、约定和局限。</li>
</ul>
<p>本篇将通过实现一个简单的二维欧几里得向量类型，来涵盖上述内容。</p>
<p>不过在开始之前，我们需要补充几个概念：</p>
<ul>
<li><code>repr()</code>：以便于<strong>开发者</strong>理解的方式返回对象的<strong>字符串表示形式</strong>，它调用对象的<code>__repr__</code>特殊方法；</li>
<li><code>str()</code>：以便于<strong>用户</strong>理解的方式返回对象的<strong>字符串表示形式</strong>，它调用对象的<code>__str__</code>特殊方法；</li>
<li><code>bytes()</code>：获取对象的<strong>字节序列表示形式</strong>，它调用对象的<code>__bytes__</code>特殊方法；</li>
<li><code>format()</code>和<code>str.format()</code>：<strong>格式化</strong>输出对象的字符串表示形式，调用对象的<code>__format__</code>特殊方法。</li>
</ul>
<h1 id="自定义向量类vector2d">2. 自定义向量类Vector2d</h1>
<p>我们希望这个类具备如下行为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码1</span></span><br><span class="line">&gt;&gt;&gt; v1 = Vector2d(3, 4)</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(v1.x, v1.y)  <span class="comment"># Vector2d实例的分量可直接通过实例属性访问，无需调用读值方法</span></span><br><span class="line">3.0 4.0</span><br><span class="line">&gt;&gt;&gt; x, y = v1  <span class="comment"># 实例可拆包成变量元组</span></span><br><span class="line">&gt;&gt;&gt; x, y</span><br><span class="line">(3.0, 4.0)</span><br><span class="line">&gt;&gt;&gt; v1  <span class="comment"># 我们希望__repr__返回的结果类似于构造实例的源码</span></span><br><span class="line">Vector2d(3.0, 4.0)</span><br><span class="line">&gt;&gt;&gt; v1_clone = <span class="built_in">eval</span>(repr(v1))  <span class="comment"># 只是为了说明repr()返回的结果能用来生成实例</span></span><br><span class="line">&gt;&gt;&gt; v1 == v1_clone  <span class="comment"># Vector2d需支持 == 运算符</span></span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(v1)  <span class="comment"># 我们希望__str__方法以如下形式返回实例的字符串表示</span></span><br><span class="line">(3.0, 4.0)</span><br><span class="line">&gt;&gt;&gt; octets = bytes(v1)  <span class="comment"># 能够生成字节序列</span></span><br><span class="line">&gt;&gt;&gt; octets</span><br><span class="line">b<span class="string">'d\\x00\\x00\\x00\\x00\\x00\\x00\\x08@\\x00\\x00\\x00\\x00\\x00\\x00\\x10@'</span></span><br><span class="line">&gt;&gt;&gt; abs(v1)  <span class="comment"># 能够求模</span></span><br><span class="line">5.0</span><br><span class="line">&gt;&gt;&gt; bool(v1), bool(Vector2d(0, 0))  <span class="comment"># 能进行布尔运算</span></span><br><span class="line">(True, False)</span><br></pre></td></tr></table></figure>
<p><code>Vector2d</code>的初始版本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码2</span></span><br><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2d</span>:</span></span><br><span class="line">    <span class="comment"># 类属性，在Vector2d实例和字节序列之间转换时使用</span></span><br><span class="line">    typecode = <span class="string">"d"</span>    <span class="comment"># 转换成C语言中的double类型</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x = float(x)  <span class="comment"># 构造是就转换成浮点数，尽早在构造阶段就捕获错误</span></span><br><span class="line">        self.y = float(y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span> <span class="comment"># 将Vector2d实例变为可迭代对象</span></span><br><span class="line">        <span class="keyword">return</span> (i <span class="keyword">for</span> i <span class="keyword">in</span> (self.x, self.y))  <span class="comment"># 这是生成器表达式！</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        class_name = type(self).__name__ <span class="comment"># 获取类名，没有采用硬编码</span></span><br><span class="line">        <span class="comment"># 由于Vector2d实例是可迭代对象，所以*self会把x和y提供给format函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;&#125;(&#123;!r&#125;, &#123;!r&#125;)"</span>.format(class_name, *self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(tuple(self)) <span class="comment"># 由可迭代对象构造元组</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bytes__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># ord()返回字符的Unicode码位；array中的数组的元素是double类型</span></span><br><span class="line">        <span class="keyword">return</span> (bytes([ord(self.typecode)]) + bytes(array(self.typecode, self)))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span> <span class="comment"># 这样实现有缺陷，Vector(3, 4) == [3, 4]也会返回True</span></span><br><span class="line">        <span class="keyword">return</span> tuple(self) == tuple(other)  <span class="comment"># 但这个缺陷会在后面章节修复</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span> <span class="comment"># 计算平方和的非负数根</span></span><br><span class="line">        <span class="keyword">return</span> math.hypot(self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span> <span class="comment"># 用到了上面的__abs__来计算模，如果模为0，则是False，否则为True</span></span><br><span class="line">        <span class="keyword">return</span> bool(abs(self))</span><br></pre></td></tr></table></figure>
<h1 id="备选构造方法">3. 备选构造方法</h1>
<p>初版<code>Vector2d</code>可将它的实例转换成字节序列，但却不能从字节序列构造<code>Vector2d</code>实例，下面添加一个<strong>方法</strong>实现此功能：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2d</span>:</span></span><br><span class="line">    -- snip --</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">frombytes</span><span class="params">(cls, octets)</span>:</span> <span class="comment"># 不用传入self参数，但要通过cls传入类本身</span></span><br><span class="line">        typecode = chr(octets[<span class="number">0</span>]) <span class="comment"># 从第一个字节中读取typecode，chr()将Unicode码位转换成字符</span></span><br><span class="line">        <span class="comment"># 使用传入的octets字节序列构建一个memoryview，然后根据typecode转换成所需要的数据类型</span></span><br><span class="line">        memv = memoryview(octets[<span class="number">1</span>:]).cast(typecode)</span><br><span class="line">        <span class="keyword">return</span> cls(*memv)  <span class="comment"># 拆包转换后的memoryview，然后构造一个Vector2d实例，并返回</span></span><br></pre></td></tr></table></figure>
<h1 id="classmethod与staticmethod">4. classmethod与staticmethod</h1>
<p><code>代码3</code>中用到了<code>@classmethod</code>装饰器，与它相伴的还有<code>@staticmethod</code>装饰器。</p>
<p>从上述代码可以看出，<code>classmethod</code>定义的是传入<strong>类</strong>而不是传入<strong>实例</strong>的方法，即传入的第一个参数必须是<strong>类</strong>，而不是<strong>实例</strong>。<code>classmethod</code>改变了调用方法的方式，但是，在实际调用这个方法时，我们不需要手动传入<code>cls</code>这个参数，Python会自动传入。（按照传统，第一个参数一般命名为<code>cls</code>，当然你也可以另起名）</p>
<p><code>staticmethod</code>也会改变方法的调用方式，但第一个参数不是特殊值，既不是<code>cls</code>，也不是<code>self</code>，就是用户传入的普通参数。以下是它们的用法对比：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码4</span></span><br><span class="line">&gt;&gt;&gt; class Demo:</span><br><span class="line">...     @classmethod</span><br><span class="line">...     def klassmeth(*args):</span><br><span class="line">...         <span class="built_in">return</span> args  <span class="comment"># 返回传入的全部参数</span></span><br><span class="line">...     @staticmethod</span><br><span class="line">...     def statmeth(*args):</span><br><span class="line">...         <span class="built_in">return</span> args  <span class="comment"># 返回传入的全部参数</span></span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; Demo.klassmeth()</span><br><span class="line">(&lt;class <span class="string">'Demo'</span>&gt;,) <span class="comment"># 不管如何调用Demo.klassmeth，它的第一个参数始终是Demo类自己</span></span><br><span class="line">&gt;&gt;&gt; Demo.klassmeth(<span class="string">"spam"</span>)</span><br><span class="line">(&lt;class <span class="string">'Demo'</span>&gt;, <span class="string">'spam'</span>)</span><br><span class="line">&gt;&gt;&gt; Demo.statmeth()</span><br><span class="line">()   <span class="comment"># Demo.statmeth的行为与普通函数类似</span></span><br><span class="line">&gt;&gt;&gt; Demo.statmeth(<span class="string">"spam"</span>)</span><br><span class="line">(<span class="string">'spam'</span>,)</span><br></pre></td></tr></table></figure>
<p><code>classmethod</code>很有用，但<code>staticmethod</code>一般都能找到很方便的替代方案，所以<code>staticmethod</code>并不是必须的。</p>
<h1 id="格式化显示">5. 格式化显示</h1>
<p>内置的<code>format()</code>函数和<code>str.format()</code>方法把各个类型的格式化方式委托给相应的<code>.__format__(format_spec)</code>方法。<code>format_spec</code>是格式说明符，它是：</p>
<ul>
<li><p><code>format(my_obj, format_spec)</code>的第二个参数；</p></li>
<li><p>也是<code>str.format()</code>方法的格式字符串，<code>{}</code>里替换字段中冒号后面的部分，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码5</span></span><br><span class="line">&gt;&gt;&gt; brl = 1 / 2.43</span><br><span class="line">&gt;&gt;&gt; <span class="string">"1 BRL = &#123;rate:0.2f&#125; USD"</span>.format(rate=brl)  <span class="comment"># 此时 format_spec为'0.2f'</span></span><br></pre></td></tr></table></figure>
<p>其中，冒号后面的<code>0.2f</code>是格式说明符，冒号前面的<code>rate</code>是字段名称，与格式说明符无关。格式说明符使用的表示法叫<strong>格式规范微语言</strong>（Format Specification Mini-Language）。格式规范微语言为一些内置类型提供了专门的表示代码，比如<code>b</code>表示二进制的<code>int</code>类型；同时它还是可扩展的，各个类可以自行决定如何解释<code>format_spec</code>参数，比如时间的转换格式<code>%H:%M:%S</code>，就可用于<code>datetime</code>类型，但用于<code>int</code>类型则可能报错。</p></li>
</ul>
<p>如果类没有定义<code>__format__</code>方法，则会返回<code>__str__</code>的结果，比如我们定义的<code>Vector2d</code>类型就没有定义<code>__format__</code>方法，但依然可以调用<code>format()</code>函数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码6</span></span><br><span class="line">&gt;&gt;&gt; v1 = Vector2d(3, 4)</span><br><span class="line">&gt;&gt;&gt; format(v1)</span><br><span class="line"><span class="string">'(3.0, 4.0)'</span></span><br></pre></td></tr></table></figure>
<p>但现在的<code>Vector2d</code>在格式化显示上还有缺陷，不能向<code>format()</code>传入格式说明符：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; format(v1, <span class="string">".3f"</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">   -- snip --</span><br><span class="line">TypeError: non-empty format string passed to object.__format__</span><br></pre></td></tr></table></figure>
<p>现在我们来为它定义<code>__format__</code>方法。添加自定义的格式代码，如果格式说明符以<code>'p'</code>结尾，则以极坐标的形式输出向量，即<code>&lt;r, θ&gt;</code>，<code>'p'</code>之前的部分做正常处理；如果没有<code>'p'</code>，则按笛卡尔坐标形式输出。为此，我们还需要一个计算弧度的方法<code>angle</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码7</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2d</span>:</span></span><br><span class="line">    -- snip --</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">angle</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> math.atan2(self.y, self.x)  <span class="comment"># 弧度</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__format__</span><span class="params">(self, format_spec=<span class="string">""</span>)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> format_spec.endswith(<span class="string">"p"</span>):</span><br><span class="line">            format_spec = format_spec[:<span class="number">-1</span>]</span><br><span class="line">            coords = (abs(self), self.angle())</span><br><span class="line">            outer_fmt = <span class="string">"&lt;&#123;&#125;, &#123;&#125;&gt;"</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            coords = self</span><br><span class="line">            outer_fmt = <span class="string">"(&#123;&#125;, &#123;&#125;)"</span></span><br><span class="line">        components = (format(c, format_spec) <span class="keyword">for</span> c <span class="keyword">in</span> coords)</span><br><span class="line">        <span class="keyword">return</span> outer_fmt.format(*components)</span><br></pre></td></tr></table></figure>
<p>以下是实际示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码8</span></span><br><span class="line">&gt;&gt;&gt; format(Vector2d(1, 1), <span class="string">"0.5fp"</span>)</span><br><span class="line"><span class="string">'&lt;1.41421, 0.78540&gt;'</span></span><br><span class="line">&gt;&gt;&gt; format(Vector2d(1, 1), <span class="string">"0.5f"</span>)</span><br><span class="line"><span class="string">'(1.00000, 1.00000)'</span></span><br></pre></td></tr></table></figure>
<h1 id="可散列的vector2d">6. 可散列的Vector2d</h1>
<p>关于可散列的概念可以参考之前的文章<a href="http://www.vpointer.net/articles/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF22-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/" target="_blank" rel="noopener">《Python学习之路22》</a>。</p>
<p>目前的<code>Vector2d</code>是不可散列的，为此我们需要实现<code>__hash__</code>特殊方法，而在此之前，我们还要让向量不可变，即<code>self.x</code>和<code>self.y</code>的值不能被修改。之所以要让向量不可变，是因为我们在计算向量的哈希值时需要用到<code>self.x</code>和<code>self.y</code>的哈希值，如果这两个值可变，那向量的哈希值就能随时变化，这将不是一个可散列的对象。</p>
<p><strong><em>补充</em></strong>：</p>
<ul>
<li>在文章<a href="http://www.vpointer.net/articles/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF22-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/" target="_blank" rel="noopener">《Python学习之路22》</a>中说道，用户自定义的对象默认是可散列的，它的散列值等于<code>id()</code>的返回值。但是此处的<code>Vector2d</code>却是不可散列的，这是为什么？其实，如果我们要让自定义类变为可散列的，正确的做法是同时实现<code>__hash__</code>和<code>__eq__</code>这两个特殊方法。当这两个方法都没有重写时，自定义类的哈希值就是<code>id()</code>的返回值，此时自定义类可散列；当我们只重写了<code>__hash__</code>方法时，自定义类也是可散列的，哈希值就是<code>__hash__</code>的返回值；<strong>但是</strong>，如果只重写了<code>__eq__</code>方法，而没有重写<code>__hash__</code>方法，此时自定义类便不可散列。</li>
<li>这里再次给出可散列对象必须满足的三个条件：
<ul>
<li>支持<code>hash()</code>函数，并且通过<code>__hash__</code>方法所得到的哈希值是不变的；</li>
<li>支持通过<code>__eq__</code>方法来检测相等性；</li>
<li>若<code>a == b</code>为真，则<code>hash(a) == hash(b)</code>也必须为真。</li>
</ul></li>
</ul>
<p>根据官方文档，最好使用异或运算<code>^</code>混合各分量的哈希值，下面是<code>Vector2d</code>的改进：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码9</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2d</span>:</span></span><br><span class="line">    -- snip --</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.__x = float(x)</span><br><span class="line">        self.__y = float(y)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property  # 把方法变为属性调用，相当于getter方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">x</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__x</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">y</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> hash(self.x) ^ hash(self.y)</span><br><span class="line">    </span><br><span class="line">    -- snip --</span><br></pre></td></tr></table></figure>
<p>文章至此说的都是一些特殊方法，如果想到得到功能完善的对象，这些方法可能是必备的，但如果你的应用用不到这些东西，则完全没有必要去实现这些方法，客户并不关心你的对象是否符合Python风格。</p>
<p><code>Vector2d</code>暂时告一段落，现在来说一说其它比较杂的内容。</p>
<h1 id="python的私有属性和受保护的属性">7. Python的私有属性和"受保护的"属性</h1>
<p>Python不像C++、Java那样可以用<code>private</code>关键字来创建私有属性，但在Python中，可以以<strong>双下划线</strong>开头来命名属性以实现"私有"属性，但是这种属性会发生<strong>名称改写</strong>(name mangling)：Python会在这样的属性前面加上<strong>一个下划线和类名</strong>，然后再存入实例的<code>__dict__</code>属性中，以最新的<code>Vector2d</code>为例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码10</span></span><br><span class="line">&gt;&gt;&gt; v1 = Vector2d(1, 2)</span><br><span class="line">&gt;&gt;&gt; v1.__dict__</span><br><span class="line">&#123;<span class="string">'_Vector2d__x'</span>: 1.0, <span class="string">'_Vector2d__y'</span>: 2.0&#125;</span><br></pre></td></tr></table></figure>
<p>当属性以双下划线开头时，其实是告诉别的程序员，<strong>不要直接访问这个属性</strong>，它是私有的。名称改写的目的是避免意外访问，而不能防止故意访问。只要你知道规则，这些属性一样可以访问。</p>
<p>还有以<strong>单下划线开头</strong>的属性，这种属性在Python的官方文档的某个角落里被称为了"受保护的"属性，但Python不会对这种属性做特殊处理，这只是一种约定俗成的规矩，告诉别的程序员<strong>不要试图从外部访问这些属性</strong>。这种命名方式很常见，但其实很少有人把这种属性叫做"受保护的"属性。</p>
<p>还是那句话，<strong>Python中所有的属性都是公有的，Python没有不能访问的属性</strong>！这些规则并不能阻止你有意访问这些属性，一切都看你遵不遵守上面这些"不成文"的规则了。</p>
<h1 id="覆盖类属性">8. 覆盖类属性</h1>
<p>这里首先需要区分两个概念，<strong>类属性</strong>与<strong>实例属性</strong>：</p>
<ul>
<li>类属性属于整个类，该类的所有实例都能访问这个属性，可以动态绑定类属性，动态绑定的类属性所有实例也都可以访问，即类属性的作用域是整个类。可以按<code>Vector2d</code>中定义<code>typecode</code>的方式来定义类属性，即直接在<code>class</code>中定义属性，而不是在<code>__init__</code>中；</li>
<li>实例属性只属于某个实例对象，实例也能动态绑定属性。实例属性只能这个实例自己访问，即实例属性的作用域是类对象作用域。实例属性需要和<code>self</code>绑定，<code>self</code>指向的是实例，而不是类。</li>
</ul>
<p>Python有个很独特的特性：<strong>类属性可用于为实例属性提供默认值</strong>。</p>
<p><code>Vector2d</code>中有个<code>typecode</code>类属性，注意到，我们在<code>__bytes__</code>方法中通过<code>self.typecode</code>两次用到了它，这里明明是通过<code>self</code>调用实例属性，可<code>Vector2d</code>的实例并没有这个属性。<code>self.typecode</code>其实获取的是<code>Vector2d.typecode</code>类属性的值，而至于怎么从实例属性跳到类属性的，以后有机会单独用一篇文章来讲。</p>
<p><strong><em>补充</em></strong>：证明实例没有<code>typecode</code>属性</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码11</span></span><br><span class="line">&gt;&gt;&gt; v = Vector2d(1, 2)</span><br><span class="line">&gt;&gt;&gt; v.__dict__</span><br><span class="line">&#123;<span class="string">'_Vector2d__x'</span>: 1.0, <span class="string">'_Vector2d__y'</span>: 2.0&#125; <span class="comment"># 实例中并没有typecode属性</span></span><br></pre></td></tr></table></figure>
<p>如果为不存在的实例属性赋值，则会新建该实例属性。假如我们为<code>typecode</code>实例属性赋值，同名类属性不会受到影响，但会被实例属性给覆盖掉（类似于之前在函数闭包中讲的局部变量和全局变量的区别）。借助这一特性，可以为各个实例的<code>typecode</code>属性定制不同的值，比如在生成字节序列时，将实例转换成4字节的单精度浮点数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码12</span></span><br><span class="line">&gt;&gt;&gt; v1 = Vector2d(1.1, 2.2) </span><br><span class="line">&gt;&gt;&gt; dumpd = bytes(v1) <span class="comment"># 按双精度转换</span></span><br><span class="line">&gt;&gt;&gt; dumpd</span><br><span class="line">b<span class="string">'d\x9a\x99\x99\x99\x99\x99\xf1?\x9a\x99\x99\x99\x99\x99\x01@'</span></span><br><span class="line">&gt;&gt;&gt; len(dumpd)</span><br><span class="line">17</span><br><span class="line">&gt;&gt;&gt; v1.typecode = <span class="string">"f"</span></span><br><span class="line">&gt;&gt;&gt; dumpf = bytes(v1) <span class="comment"># 按单精度转换</span></span><br><span class="line">&gt;&gt;&gt; dumpf</span><br><span class="line">b<span class="string">'f\xcd\xcc\x8c?\xcd\xcc\x0c@'</span>  <span class="comment"># 明白为什么要在字节序列前加上typecode的值了吗？为了支持不同格式。</span></span><br><span class="line">&gt;&gt;&gt; len(dumpf)</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; Vector2d.typecode</span><br><span class="line"><span class="string">'d'</span></span><br></pre></td></tr></table></figure>
<p>如果想要修改类属性的值，必须直接在类上修改，不能通过实例修改。如果想修改所有实例的<code>typecode</code>属性的默认值，可以这么做：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码13</span></span><br><span class="line">Vector2d.typecode = <span class="string">"f"</span></span><br></pre></td></tr></table></figure>
<p>然而有种方式更符合Python风格，而且效果持久，也更有针对性。<strong>通过继承的方式修改类属性</strong>，生成专门的子类。Django基于类的视图就大量使用了这个技术：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码14</span></span><br><span class="line">&gt;&gt;&gt; class ShortVector2d(Vector2d):</span><br><span class="line">...     typecode = <span class="string">"f"</span>   <span class="comment"># 只修改这一处</span></span><br><span class="line">...    </span><br><span class="line">&gt;&gt;&gt; sv = ShortVector2d(1/11, 1/27)</span><br><span class="line">&gt;&gt;&gt; sv</span><br><span class="line">ShortVector2d(0.09090909090909091, 0.037037037037037035) <span class="comment"># 没有硬编码class_name的原因</span></span><br><span class="line">&gt;&gt;&gt; len(bytes(sv))</span><br><span class="line">9</span><br></pre></td></tr></table></figure>
<h1 id="slots__类属性">9. __slots__类属性</h1>
<p>默认情况下，Python在各个实例的<code>__dict__</code>属性中以映射类型存储实例属性。正如<a href="http://www.vpointer.net/articles/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF22-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/" target="_blank" rel="noopener">《Python学习之路22》</a>中所述，为了使用底层的散列表提升访问速度，字典会消耗大量内存。如果要处理数百万个属性不多的实例，其实可以通过<code>__slots__</code>类属性来节省大量内存。做法是让解释器用类似元组的结构存储实例属性，而不是字典。</p>
<p>具体用法是，在类中创建这个<code>__slots__</code>类属性，并把它的值设为一个可迭代对象，其中的元素是<strong>其余实例属性的字符串表示</strong>。比如我们将之前定义的<code>Vector2d</code>改为<code>__slots__</code>版本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码15</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2d</span>:</span></span><br><span class="line">    __slots__ = (<span class="string">"__x"</span>, <span class="string">"__y"</span>)</span><br><span class="line">    </span><br><span class="line">    typecode = <span class="string">"d"</span>  <span class="comment"># 其余保持不变</span></span><br><span class="line">    -- snip --</span><br></pre></td></tr></table></figure>
<p>试验表明，创建一千万个之前版本的<code>Vector2d</code>实例，内存用量高达1.5GB，而<code>__slots__</code>版本的<code>Vector2d</code>的内存用量不到700MB，并且速度也比之前的版本快。</p>
<p>但<code>__slots__</code>也有一些需要注意的点：</p>
<ul>
<li>使用<code>__slots__</code>之后，实例不能再有<code>__slots__</code>中所列名称之外的属性，即，不能动态添加属性；如果要使其能动态添加属性，必须在其中加入<code>'__dict__'</code>，但这么做又违背了初衷；</li>
<li>每个子类都要定义<code>__slots__</code>属性，解释器会忽略掉父类的<code>__slots__</code>属性；</li>
<li>自定义类中默认有<code>__weakref__</code>属性，但如果定义了<code>__slots__</code>属性，而且还要自定义类支持弱引用，则需要把<code>'__weakref__'</code>加入到<code>__slots__</code>中。</li>
</ul>
<p>总之，不要滥用<code>__slots__</code>属性，也不要用它来限制用户动态添加属性（除非有意为之）。<code>__slots__</code>在处理列表数据时最有用，例如模式固定的数据库记录，以及特大型数据集。然而，当遇到这类数据时，更推荐使用Numpy和Pandas等第三方库。</p>
<h1 id="总结">10. 总结</h1>
<p>本篇首先按照一定的要求，定义了一个<code>Vector2d</code>类，重点是如果实现这个类的不同输出形式；随后，能从字节序列"反编译"成我们需要的类，我们实现了一个备选构造方法，顺带介绍了<code>@classmethod</code>和<code>@staticmethod</code>装饰器；接着，我们通过重写<code>__format_</code>方法，实现了自定义格式化输出数据；然后，通过使用<code>@property</code>装饰器，定义"私有"属性以及重写<code>__hash__</code>方法等操作实现了这个类的可散列化。至此，关于<code>Vector2d</code>的内容基本结束。最后，我们介绍了两种常见类型的属性（“私有”，“保护”），覆盖类属性以及如何通过<code>__slots__</code>节省内存等问题。</p>
<p>本文实现了这么多特殊方法只是为展示如何编写标准Python对象的API，如果你的应用用不到这些内容，大可不必为了满足Python风格而给自己增加负担。毕竟，<strong><em>简洁胜于复杂</em></strong>。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python进阶</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python进阶</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路27-对象引用、可变性和垃圾回收</title>
    <url>/2018/06/02/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF27-%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E3%80%81%E5%8F%AF%E5%8F%98%E6%80%A7%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<blockquote>
<p>《流畅的Python》笔记。</p>
<p>本篇是“面向对象惯用方法”的第一篇，一共六篇。本篇主要是一些概念性的讨论，内容有：Python中的变量，对象标识，值，别名，元组的某些特性，深浅复制，引用，函数参数，垃圾回收，del命令，弱引用等，比较枯燥，但却能解决程序中不易察觉的bug。</p>
</blockquote>
<a id="more"></a>
<h1 id="变量标识相等性和别名">1. 变量、标识、相等性和别名</h1>
<p>先用一个形象的比喻来说明Python中的变量：<strong>变量是标注而不是盒子</strong>。也就是说，Python中的变量更像C++中的引用，最能说明这一点的就是多个变量指向同一个列表，但也有例外，在遇到某些内置类型，比如字符串<code>str</code>时，变量则变成了“盒子”：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>]  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a  <span class="comment"># 标注，引用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = <span class="string">"c"</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = c  <span class="comment"># “盒子”</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = <span class="string">"cc"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line"><span class="string">'c'</span></span><br></pre></td></tr></table></figure>
<p><em>补充：说到了赋值方式，Python和C++一样，也是等号右边先执行。</em></p>
<h2 id="相等性-与标识-is">1.1 相等性( == )与标识( is )</h2>
<p>用一个更学术的词来替换“标注”，那就是“<strong>别名</strong>”。在C++中，引用就是变量的别名，Python中也是，比如<code>代码1</code>中的变量<code>b</code>就是变量<code>a</code>的别名，但如果是以下形式，变量<code>b</code>则不是<code>a</code>的别名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a == b   <span class="comment"># a和b的值相等</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b   <span class="comment"># a和b分别绑定了不同的对象，虽然对象的值相等 </span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p><code>==</code>检测对象的值是否相等，<code>is</code>运算符检测对象的<strong>标识</strong>（ID）是否相等，<code>id()</code>返回对象标识的整数表示。一般判断两对象的标识是否相等并不直接使用<code>id()</code>，更多的是使用<code>is</code>运算符。</p>
<p>对象ID在不同的实现中有所不同：在CPython中，<code>id()</code>返回对象的内存地址，但在其他Python解释器中可能是别的值。但不管怎么，对象的ID一定唯一，且在生命周期中保持不变。</p>
<p>通常我们关心的是值，而不是标识，所以<code>==</code>出现的频率比<code>is</code>高。但在变量和单例值之间比较时，应该使用<code>is</code>。目前，最常使用<code>is</code>检测变量绑定的值是不是<code>None</code>，推荐的写法是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码3</span></span><br><span class="line">x <span class="keyword">is</span> <span class="literal">None</span>  <span class="comment"># 并非 x == None</span></span><br><span class="line">x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>  <span class="comment"># 并非 x != None</span></span><br></pre></td></tr></table></figure>
<p><code>is</code>运算符比<code>==</code>速度快，因为它不能重载，所以Python不用寻找并调用特殊方法，而是直接比较两个对象的ID。<code>a == b</code>其实是语法糖，实际调用<code>a.__eq__(b)</code>。虽然继承自<code>object</code>的<code>__eq__</code>方法也是比较对象的ID，结果和<code>is</code>一样，但大多数内置类型覆盖了该方法，处理过程更复杂，这就是为什么<code>is</code>比<code>==</code>快。</p>
<h2 id="元组的相对不可变性">1.2 元组的相对不可变性</h2>
<p>元组和大多数Python集合一样，保存的是对象的引用。元组的不可变性其实是指<code>tuple</code>数据结构的物理内容（即保存的引用）不可变，与引用的对象无关。<strong>如果引用的对象可变，即便元组本身不可变，元素依然可变，不变的是元素的标识</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t2 = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 == t2</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(t1[<span class="number">-1</span>])</span><br><span class="line"><span class="number">2019589413704</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1[<span class="number">-1</span>].append(<span class="number">99</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>, <span class="number">99</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(t1[<span class="number">-1</span>])  <span class="comment"># 内容变了，标识没有变</span></span><br><span class="line"><span class="number">2019589413704</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 == t2</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>这同时也说明，<strong>并不是每个元组都是可散列的</strong>！</p>
<h1 id="深浅复制">2.深浅复制</h1>
<p>复制对象时，相等性和标识之间的区别有更深入的影响。副本与源对象相等，但ID不同。而如果对象内部还有其他对象，这就涉及到了深浅复制的问题：到底是复制内部对象呢还是共享内部对象？</p>
<h2 id="默认做浅复制">2.1 默认做浅复制</h2>
<p>对列表和其他可变序列来说，我们可以使用构造方法或<code>[:]</code>来创建副本。然而，这两种方法做的都是<strong>浅复制</strong>，它们只复制了最外层的容器，副本中的元素是源容器中元素的引用。如果所有元素都是不可变的，那这样做没问题，还能节省内存；但如果其中有可变元素，这么做就可能出问题：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码5</span></span><br><span class="line">l1 = [<span class="number">3</span>, [<span class="number">11</span>, <span class="number">22</span>], (<span class="number">7</span>, <span class="number">8</span>)]</span><br><span class="line">l2 = list(l1)      <span class="comment"># &lt;1&gt;</span></span><br><span class="line">l1.append(<span class="number">100</span>)</span><br><span class="line">l1[<span class="number">1</span>].remove(<span class="number">22</span>)</span><br><span class="line">print(<span class="string">"l1:"</span>, l1, <span class="string">"\nl2:"</span>, l2)</span><br><span class="line">l2[<span class="number">1</span>] += [<span class="number">33</span>, <span class="number">44</span>]  <span class="comment"># &lt;2&gt;</span></span><br><span class="line">l2[<span class="number">2</span>] += (<span class="number">10</span>, <span class="number">11</span>)  <span class="comment"># &lt;3&gt;</span></span><br><span class="line">print(<span class="string">"l1:"</span>, l1, <span class="string">"\nl2:"</span>, l2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">l1: [<span class="number">3</span>, [<span class="number">11</span>], (<span class="number">7</span>, <span class="number">8</span>), <span class="number">100</span>]  <span class="comment"># 追加元素只影响了l1</span></span><br><span class="line">l2: [<span class="number">3</span>, [<span class="number">11</span>], (<span class="number">7</span>, <span class="number">8</span>)]       <span class="comment"># 但删除l1[1]中的元素影响了两个列表</span></span><br><span class="line">l1: [<span class="number">3</span>, [<span class="number">11</span>, <span class="number">33</span>, <span class="number">44</span>], (<span class="number">7</span>, <span class="number">8</span>), <span class="number">100</span>]     <span class="comment"># +=对可变对象是就地操作，影响了两个列表</span></span><br><span class="line">l2: [<span class="number">3</span>, [<span class="number">11</span>, <span class="number">33</span>, <span class="number">44</span>], (<span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">11</span>)]  <span class="comment"># +=对不可变对象会创建新对象，只影响了l2</span></span><br></pre></td></tr></table></figure>
<p>以上代码有3点需要解释：</p>
<ul>
<li>&lt;1&gt;：<code>l1[1]</code>和<code>l2[1]</code>指向同一列表，<code>l1[2]</code>和<code>l2[2]</code>指向同一元组。因为是浅复制，只是复制引用；</li>
<li>&lt;2&gt;：<code>+=</code>运算对可变对象来说是<strong>就地运算</strong>，不会创建新对象，所以对两个列表都有影响；</li>
<li>&lt;3&gt;：<code>+=</code>运算对元组这样的不可变对象来说，等同于<code>l2[2] = l2[2] + (10, 11)</code>，此操作隐式地创建了新对象，<code>l2[2]</code>重新绑定到了新对象，所以只有列表<code>l2[2]</code>发生了改变，而<code>l1[2]</code>没有改变。</li>
</ul>
<h2 id="为任意对象做深复制和浅复制">2.2 为任意对象做深复制和浅复制</h2>
<p>浅复制并非是一种错误，只是一种选择。而有时我们需要的是<strong>深复制</strong>，即副本不共享内部对象的引用。copy模块提供的<code>deepcopy</code>和<code>copy</code>函数能为任意对象做深复制和浅复制。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码6</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">l1 = [<span class="number">3</span>, [<span class="number">11</span>, <span class="number">22</span>]]</span><br><span class="line">l2 = copy.copy(l1)      <span class="comment"># 浅复制</span></span><br><span class="line">l3 = copy.deepcopy(l1)  <span class="comment"># 深复制</span></span><br><span class="line">l1[<span class="number">1</span>].append(<span class="number">33</span>)    <span class="comment"># 影响了l2，但没有影响l3</span></span><br><span class="line">print(<span class="string">"l1:"</span>, l1, <span class="string">"\nl2:"</span>, l2, <span class="string">"\nl3:"</span>, l3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">l1: [<span class="number">3</span>, [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]] </span><br><span class="line">l2: [<span class="number">3</span>, [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]] </span><br><span class="line">l3: [<span class="number">3</span>, [<span class="number">11</span>, <span class="number">22</span>]]</span><br></pre></td></tr></table></figure>
<p>在做深复制时，如果对象之间有循环引用，朴素的深复制算法（换句话说就是你自己写的深复制算法:laughing:）很可能会陷入无限循环，然后报错。<code>deepcopy</code>会记住已经复制的对象，而不会进入无限循环：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [a, <span class="number">30</span>]  <span class="comment"># 包含a的引用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[[<span class="number">10</span>, <span class="number">20</span>], <span class="number">30</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(b)  <span class="comment"># 相互引用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">10</span>, <span class="number">20</span>, [[...], <span class="number">30</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>][<span class="number">0</span>]</span><br><span class="line">[<span class="number">10</span>, <span class="number">20</span>, [[...], <span class="number">30</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>][<span class="number">0</span>][<span class="number">2</span>][<span class="number">0</span>]</span><br><span class="line">[<span class="number">10</span>, <span class="number">20</span>, [[...], <span class="number">30</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = deepcopy(a) <span class="comment"># 不会报错，能正确处理相互引用的问题</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">[<span class="number">10</span>, <span class="number">20</span>, [[...], <span class="number">30</span>]]</span><br></pre></td></tr></table></figure>
<p>此外，深复制有时可能太深了。例如，对象可能会引用不该复制的外部资源或单例值，这时，深复制就不应该复制这些值。如果要控制<code>copy</code>和<code>deepcopy</code>的行为，我们可以在对象中重写特殊方法<code>__copy__</code>和<code>__deepcopy__</code>，具体内容这里就不展开了，大家可以参考<a href="https://docs.python.org/3/library/copy.html" target="_blank" rel="noopener">copy模块的官方文档</a>。</p>
<h1 id="函数参数">3. 函数参数</h1>
<p>通过别名共享对象还能解释Python中传递参数的方式，以及使用可变类型作为参数默认值引起的问题。</p>
<h2 id="函数的参数作为引用时">3.1 函数的参数作为引用时</h2>
<p>Python唯一支持的参数传递模式是<strong>共享传参</strong>（call by sharing），它指函数的形参获得实参中各个引用的<strong>副本</strong>，即<strong>形参是实参的别名</strong>。这种方案的结果就是，函数可能会修改作为参数传入的<strong>可变对象</strong>，但无法修改这些对象的标识（不能把一个对象替换成另一个对象）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码8</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    a += b</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">x, y = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">print(f(x, y), x, y)</span><br><span class="line">a, b = [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">print(f(a, b), a, b)</span><br><span class="line">t, u = (<span class="number">10</span>, <span class="number">20</span>), (<span class="number">30</span>, <span class="number">40</span>)</span><br><span class="line">print(f(t, u), t, u)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="comment"># x, y是不可变对象，没有影响到x, y</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] [<span class="number">3</span>, <span class="number">4</span>]   <span class="comment"># x是可变对象，影响到了x</span></span><br><span class="line">(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>) (<span class="number">10</span>, <span class="number">20</span>) (<span class="number">30</span>, <span class="number">40</span>) <span class="comment"># x没有指向新的元组，但形参a指向了新的元组</span></span><br></pre></td></tr></table></figure>
<h2 id="参数默认值">3.2 参数默认值</h2>
<p><strong>不要使用可变类型作为参数的默认值</strong>！其实这个问题在之前的文章“Python学习之路7-函数”的2.3小节中有所提及。现在我们来看下面这个例子：</p>
<p>首先定义一个类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码9</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, passengers=[])</span>:</span>  <span class="comment"># 默认值是个可变对象</span></span><br><span class="line">        self.passengers = passengers</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.passengers.append(name)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drop</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.passengers.remove(name)</span><br></pre></td></tr></table></figure>
<p>下面是这个类的行为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus1 = Bus([<span class="string">"Alice"</span>, <span class="string">"Bill"</span>]) <span class="comment"># 直到第8行Bus的表现都是正常的</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus1.passengers</span><br><span class="line">[<span class="string">'Alice'</span>, <span class="string">'Bill'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus1.pick(<span class="string">"Charlie"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus1.drop(<span class="string">"Alice"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus1.passengers</span><br><span class="line">[<span class="string">'Bill'</span>, <span class="string">'Charlie'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2 = Bus()  <span class="comment"># 使用默认值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2.pick(<span class="string">"Carrie"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2.passengers</span><br><span class="line">[<span class="string">'Carrie'</span>]   <span class="comment"># 到目前为止也是正常的</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus3 = Bus()  <span class="comment"># 也是用默认值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus3.passengers</span><br><span class="line">[<span class="string">'Carrie'</span>]   <span class="comment"># 不正常了！</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus3.pick(<span class="string">"Dave"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2.passengers</span><br><span class="line">[<span class="string">'Carrie'</span>, <span class="string">'Dave'</span>]  <span class="comment"># bus2的值也被改变了</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2.passengers <span class="keyword">is</span> bus3.passengers  <span class="comment"># 这俩是同一对象的别名</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus1.passengers <span class="comment"># bus1依然正常</span></span><br><span class="line">[<span class="string">'Bill'</span>, <span class="string">'Charlie'</span>]</span><br></pre></td></tr></table></figure>
<p>上述行为的原因在于，参数的默认值在<strong>导入模块时</strong>计算，方法或函数的形参指向这个默认值。而在上面这个例子中，类的属性<code>self.passengers</code>实际上是形参<code>passengers</code>所指向的对象（<strong>所指对象</strong>，referent）的别名。而<code>bus1</code>行为正常是因为从一开始它的<code>passengers</code>就没有指向默认值。</p>
<p>这里有点像单例模式：<strong>参数的默认值是唯一的</strong>，<strong>只要采用默认值</strong>，不管创建多少个<code>Bus</code>的实例，它们的<code>self.passengers</code>都是同一个空列表<code>[]</code>对象的别名，不会为每一个实例单独创建一个专属的<code>[]</code>。</p>
<p>运行上述代码之后，可以查看<code>Bus.__init__</code>对象的<code>__defaults__</code>属性，它存储了参数的默认值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码11</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Bus.__init__.__defaults__</span><br><span class="line">([<span class="string">'Carrie'</span>, <span class="string">'Dave'</span>],)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Bus.__init__.__defaults__[<span class="number">0</span>] <span class="keyword">is</span> bus2.passengers  <span class="comment"># self.passengers就是一个别名！</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>这也说明了为什么要用<code>None</code>作为接收可变值的参数的默认值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码12</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bus</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, passengers=None)</span>:</span>  <span class="comment"># 默认值是个可变对象</span></span><br><span class="line">        <span class="keyword">if</span> passengers <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 并不推荐 if passengers == None 这种写法</span></span><br><span class="line">            self.passengers = []</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.passengers = list(passengers)  <span class="comment"># 注意这里！</span></span><br><span class="line">    -- snip --</span><br></pre></td></tr></table></figure>
<p><code>代码12</code>中的第7行并不是直接把形参<code>passengers</code>赋值给<code>self.passengers</code>，而是形参的副本（这里是浅复制）。如果直接赋值，即<code>self.passengers = passengers</code>（<code>self.passengers</code>变成了用户传入的参数的别名），则用户传入的参数在运行过程中可能会被修改，而这并不一定是用户想要的，这便违反了<strong>"最少惊讶原则"</strong>（居然还真有这么个原则:joy_cat:）</p>
<h1 id="del和垃圾回收">4. del和垃圾回收</h1>
<blockquote>
<p>对象绝不会自行销毁；然而，无法得到对象时，可能会被当做垃圾回收。——Python语言参考手册</p>
</blockquote>
<p><code>del</code>语句删除变量（即"引用"），而不是对象。<code>del</code>命令可能导致对象被当做垃圾回收，但这仅发生在当删除的变量保存的是对象的最后一个引用，或者无法得到对象时（如果两个对象相互引用，如<code>代码7</code>，当它们的引用只存在二者之间时，垃圾回收程序会判定它们都无法获取，进而把它们都销毁）。重新绑定也可能会导致对象的引用数量归零，进而对象被销毁。</p>
<p>在CPython中，垃圾回收使用的主要算法是引用计数。实际上，每个对象都会统计有多少个引用指向自己。当引用计数归零时，对象立即被销毁。但在其他Python解释器中则不一定是引用计数算法。</p>
<p><strong><em>补充</em></strong>：有个<code>__del__</code>特殊方法，它不是用来销毁实例的，而是在实例被销毁前用来执行一些最后的操作，比如释放外部资源等。我们不应该在代码中调用它，Python解释器会在销毁实例时先调用它（如果定义了），然后再释放内存。它相当于C++中的析构函数。</p>
<p>我们可以使用<code>weakref.finalize</code>来演示对象被销毁时的情况：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码13</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> weakref</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = s1</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">bye</span><span class="params">()</span>:</span> <span class="comment"># 它充当一个回调函数</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"Gone with the wind..."</span>)</span><br><span class="line"><span class="comment"># 一定不要传入待销毁对象的绑定方法，否则会有一个指向对象的引用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ender = weakref.finalize(s1, bye) <span class="comment"># 在s1引用的对象上注册bye回调</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ender.alive</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> s1</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ender.alive</span><br><span class="line"><span class="literal">True</span>  <span class="comment"># 说明 del s1并没有删除对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = <span class="string">"spam"</span> </span><br><span class="line">Gone <span class="keyword">with</span> the wind...  <span class="comment"># 引用计数为零，对象被删除</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ender.alive</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h1 id="弱引用">5. 弱引用</h1>
<p>不知道大家看到上述代码第15行时会不会产生如下疑惑：第8行代码明明把<code>s1</code>引用传给了<code>finalize</code>函数（为了监控对象和调用回调，必须要有引用），那么对象<code>{1, 2, 3}</code>则应该至少有三个引用，可为什么最后它还是被销毁了呢？这就牵扯到了<strong>弱引用</strong>这个概念。</p>
<h2 id="weakref.ref">5.1 weakref.ref</h2>
<p>弱引用不会妨碍所指对象被当做垃圾回收，即弱引用不会增加对象的引用计数。（弱引用常被用于缓存，但具体用在缓存的哪些地方目前笔者还不清楚.....）</p>
<p>弱引用还是可调用对象，下面的代码展示了如何使用<code>weakref.ref</code>实例获取所指对象。</p>
<p><strong><em>补充在代码之前</em></strong>：Python控制台会自动把结果不为<code>None</code>的表达式的结果绑定到变量<code>_</code>（下划线）上。这也说明了一个问题：微观管理内存时，隐式赋值会为对象创建新引用，而这有可能会导致一些意外结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码14</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> weakref</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_set = &#123;<span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment"># 对象&#123;1, 2&#125;的引用数+1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref = weakref.ref(a_set) <span class="comment"># 并没有增加所指对象的引用数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref</span><br><span class="line">&lt;weakref at <span class="number">0x0000013D739E2D18</span>; to <span class="string">'set'</span> at <span class="number">0x0000013D739BE588</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref() <span class="comment"># 弱引用是个可调用对象</span></span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment"># 发生了隐式赋值，变量 _ 指向了对象&#123;1, 2&#125;，引用数+1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_set = &#123;<span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment"># 引用数 -1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref() <span class="comment"># 所指对象依然存在，还没有被销毁</span></span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref() <span class="keyword">is</span> <span class="literal">None</span>  <span class="comment"># 此时所指对象依然存在</span></span><br><span class="line"><span class="literal">False</span> <span class="comment"># 变量 _ 指向了对象False，对象&#123;1, 2&#125;引用数归零，销毁</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref() <span class="keyword">is</span> <span class="literal">None</span>  <span class="comment"># 验证所指对象已被销毁</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h2 id="weakref集合">5.2 weakref集合</h2>
<p><code>weakref.ref</code>类其实是底层接口，供高级用途使用，一般程序最好使用<code>werakref</code>集合和f<code>inalize</code>函数，即最好使用<code>WeakKeyDictionary</code>、<code>WeakValueDictionary</code>、<code>WeakSet</code>和<code>finalize</code>（它们在内部使用弱引用），不推荐自己动手创建并处理<code>weakref.ref</code>实例，除非你的工作就是专门和这些东西打交道的。</p>
<p><code>WeakValueDictionary</code>类实现的是一种可变映射，里面的<strong>值</strong>（"键值对"中的"值"，而不是字典中的"值"）是对象的弱引用。被引用的对象在程序中的其他地方被当做垃圾回收后，对应的键会自动从<code>WeakValueDictionary</code>中删除。因此，它经常用于缓存。（查看缓存中变量是否依然存在？给框架用？）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码15</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> weakref</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Cheese</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, kind)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.kind = kind</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stock = weakref.WeakValueDictionary()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>catalog = [Cheese(<span class="string">"Red Leicester"</span>), Cheese(<span class="string">"Parmesan"</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> cheese <span class="keyword">in</span> catalog:</span><br><span class="line"><span class="meta">... </span>    stock[cheese.kind] = cheese</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(stock.keys())  </span><br><span class="line">[<span class="string">'Red Leicester'</span>, <span class="string">'Parmesan'</span>]   <span class="comment"># 表现正常</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> catalog</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(stock.keys())</span><br><span class="line">[<span class="string">'Parmesan'</span>]  <span class="comment"># 这是怎么回事？</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> cheese  <span class="comment"># 这是问题所在</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(stock.keys())</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<p>临时变量引用了对象，这可能会导致该变量的存在时间比预期长。通常，这对局部变量来说不是问题，因为它们在函数返回时会被销毁。但上述代码中，<code>for</code>循环中的变量<code>cheese</code>是全局变量，除非显示删除，否则不会消失。</p>
<p>与<code>WeakValueDictionary</code>对应的是<code>WeakKeyDictionary</code>，后者的<strong>键</strong>是弱引用，它的一些可能用途如下：</p>
<p><em>它的实例可以为应用中其他部分拥有的对象附加数据，这样就无需为对象添加属性。这对属性访问受限的对象尤其有用。</em></p>
<p><code>WeakSet</code>类的用途则很简单：<em>"保存元素弱引用的集合。当某元素没有强引用时，集合会把它删除。"</em>如果一个类需要知道它的所有实例，一种好的方案是创建一个<code>WeakSet</code>类型的类属性，保存实例的弱引用。</p>
<h2 id="弱引用的局限">5.3 弱引用的局限</h2>
<p><code>weakref</code>集合以及一般的弱引用，能处理的对象类型有限：</p>
<ul>
<li><p>基本的<code>list</code>和<code>dict</code>实例不能作为弱引用的所指对象，但它们的子类则可以；</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span><span class="params">(list)</span>:</span></span><br><span class="line">    <span class="string">"""MyList的实例可作为弱引用的所指对象"""</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>set</code>的实例可作为所指对象；</p></li>
<li><p>自定义类的实例可以；</p></li>
<li><p><code>int</code>和<code>tuple</code>的实例不能作为弱引用的所指对象，它们的子类也不行。</p></li>
</ul>
<p>但这些局限基本上是CPython的实现细节，其他Python解释器的情况可能不同。</p>
<h1 id="cpython对不可变类型走的捷径">6. CPython对不可变类型走的捷径</h1>
<p>本节内容是Python实现的细节，<strong>可以跳过</strong>。</p>
<p>这些细节是CPython核心开发者走的捷径和优化措施，利用这些细节写的代码在其他Python解释器中可能没用，在CPython未来的版本中也可能没用。下面是具体内容：</p>
<ul>
<li><p>对元组<code>t</code>来说，<code>t[:]</code>和<code>tuple(t)</code>不创建副本，而是返回同一个对象的引用；</p></li>
<li><p><code>str</code>、<code>bytes</code>和<code>frozenset</code>实例也是如此，并且<code>frozenset</code>的<code>copy</code>方法返回的也<strong>不是副本</strong>（注意，<code>frozenset</code>的实例<code>fs</code>不能用<code>fs[:]</code>，因为<code>fs</code>不是序列）；</p></li>
<li><p><code>str</code>的实例还有<strong>共享字符串字面量</strong>的行为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = <span class="string">"ABC"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = <span class="string">"ABC"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 <span class="keyword">is</span> s2</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>这叫做"<strong>驻留</strong>"（interning），这是一种优化措施。CPython还会在小的整数上使用这种优化，防止重复创建常用数字，如0，-1。但CPython不会驻留所有字符串和数字，驻留的条件是实现细节，而且没有文档说明。所以<strong>千万不要依赖这个特性</strong>！（比较字符串或数字请用<code>==</code>，而不是<code>is</code>！）</p></li>
</ul>
<h1 id="总结">7. 总结</h1>
<p>每个Python对象都有标识、类型和值，只有对象的值可能变化。</p>
<p>变量保存的是引用，这对Python编程有很多实际的影响：</p>
<ul>
<li>简单的赋值不会创建副本；</li>
<li>对<code>+=</code>或<code>*=</code>等运算符来说，如果左边的变量绑定了不可变对象，则会创建新对象，然后重新绑定；如果是可变对象，则就地修改；</li>
<li>对现有的变量赋予新值不会修改之前绑定的对象。这叫重新绑定：现有变量绑定了其它对象。如果变量是之前那个对象的最后一个引用，该对象会被回收；</li>
<li>函数的参数以别名的形式传递，这意味着，函数可能会修改通过参数传入的可变对象。这一行为无法避免，除非在函数内部创建副本，或者使用不可变对象；</li>
<li>不要使用可变类型作为函数的默认值！</li>
<li><code>==</code>用于比较值，<code>is</code>用于比较引用。</li>
</ul>
<p>某些情况下，可能需要保存对象的引用，但不留存对象本身，比如记录某个类的所有实例，这可以用弱引用解决。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python进阶</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python进阶</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路26-函数装饰器和闭包</title>
    <url>/2018/05/31/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF26-%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8%E5%92%8C%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<blockquote>
<p>《流畅的Python》笔记。</p>
<p>本篇将从最简单的装饰器开始，逐渐深入到闭包的概念，然后实现参数化装饰器，最后介绍标准库中常用的装饰器。</p>
</blockquote>
<a id="more"></a>
<h1 id="初步认识装饰器">1. 初步认识装饰器</h1>
<p>函数装饰器用于在源代码中“标记”函数，以某种方式增强函数的行为。装饰器就是函数，或者说是可调用对象，它以另一个函数为参数，最后返回一个函数，但这个返回的函数并不一定是原函数。</p>
<h2 id="装饰器基础用法">1.1 装饰器基础用法</h2>
<p>以下是装饰器最基本的用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码1</span></span><br><span class="line"><span class="comment">#装饰器用法</span></span><br><span class="line"><span class="meta">@decorate</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">()</span>:</span> <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上述代码等价于以下代码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">()</span>:</span> <span class="keyword">pass</span></span><br><span class="line">target = decorate(target)</span><br></pre></td></tr></table></figure>
<p>即，最终的<code>target</code>函数是由<code>decorate(target)</code>返回的函数。下面这个例子说明了这一点：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"running inner()"</span>)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@deco</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"running target()"</span>)</span><br><span class="line"></span><br><span class="line">target()</span><br><span class="line">print(target)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">running inner() <span class="comment"># 输出的是装饰器内部定义的函数的调用结果</span></span><br><span class="line">&lt;function deco.&lt;locals&gt;.inner at <span class="number">0x000001AF32547D90</span>&gt;</span><br></pre></td></tr></table></figure>
<p>从上面可看出，装饰器的一大特性是能<strong>把被装饰的函数替换成其他函数</strong>。但严格说来，装饰器只是语法糖（<em>语法糖：在编程语言中添加某种语法，但这种语法对语言的功能没有影响，只是更方便程序员使用</em>）。</p>
<p><strong>装饰器还可以叠加</strong>。下面是一个说明，具体例子见后面章节：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码3</span></span><br><span class="line"><span class="meta">@d1</span></span><br><span class="line"><span class="meta">@d2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span> <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#上述代码等价于以下代码：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span> <span class="keyword">pass</span></span><br><span class="line">f = d1(d2(f))</span><br></pre></td></tr></table></figure>
<h2 id="python何时执行装饰器">1.2 Python何时执行装饰器</h2>
<p>装饰器的另一个关键特性是，<strong>它在被装饰的函数定义后立即运行</strong>，这通常是在<strong>导入时</strong>，即Python加载模块时：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码4</span></span><br><span class="line">registry = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">"running register(%s)"</span> % func)</span><br><span class="line">    registry.append(func)</span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"running f1()"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"running f2()"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(<span class="string">"running in main"</span>)</span><br><span class="line">    print(<span class="string">"registry -&gt;"</span>, registry)</span><br><span class="line">    f1()</span><br><span class="line">    f2()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">running register(&lt;function f1 at <span class="number">0x0000027745397840</span>&gt;)</span><br><span class="line">running <span class="keyword">in</span> main <span class="comment"># 进入到主程序</span></span><br><span class="line">registry -&gt; [&lt;function f1 at 0x0000027745397840&gt;]</span><br><span class="line">running f1()</span><br><span class="line">running f2()</span><br></pre></td></tr></table></figure>
<p>装饰器<code>register</code>在加载模块时就对<code>f1()</code>进行了注册，所以当运行主程序时，列表<code>registry</code>并不为空。</p>
<p><strong>函数装饰器在导入模块时立即执行，而被装饰的函数只在明确调用时运行。</strong>这突出了Python程序员常说的<strong>导入时</strong>和<strong>运行时</strong>之间的区别。</p>
<p>装饰器在真实代码中的使用方式与<code>代码4</code>中有所不同：</p>
<ul>
<li>装饰器和被装饰函数一般不在一个模块中，通常装饰器定义在一个模块中，然后应用到其他模块中的函数上；</li>
<li>大多数装饰器会在内部定义一个函数，然后将其返回。</li>
</ul>
<p><code>代码4</code>中的装饰器原封不动地返回了传入的函数。这种装饰器并不是没有用，正如<code>代码4</code>中的装饰器的名字一样，这类装饰器常充当了注册器，很多Web框架就使用了这种方法。下一小节也是该类装饰器的一个例子。</p>
<h2 id="使用装饰器改进策略模式">1.3 使用装饰器改进策略模式</h2>
<p>上一篇中我们用Python函数改进了传统的策略模式，其中，我们定义了一个<code>promos</code>列表来记录有哪些具体策略，当时的做法是用<code>globals()</code>函数来获取具体的策略函数，现在我们用装饰器来改进这一做法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码5，对之前的代码进行了简略</span></span><br><span class="line">promos = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">promotion</span><span class="params">(promo_func)</span>:</span> <span class="comment"># 只充当了注册器</span></span><br><span class="line">    promos.append(promo_func)</span><br><span class="line">    <span class="keyword">return</span> promo_func</span><br><span class="line"></span><br><span class="line"><span class="meta">@promotion</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fidelity</span><span class="params">(order)</span>:</span> <span class="keyword">pass</span>  </span><br><span class="line"></span><br><span class="line"><span class="meta">@promotion</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bulk_item</span><span class="params">(order)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@promotion</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">large_order</span><span class="params">(order)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">best_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> max(promo(order) <span class="keyword">for</span> promo <span class="keyword">in</span> promos)</span><br></pre></td></tr></table></figure>
<p>该方案相比之前的方案，有以下三个优点：</p>
<ul>
<li>促销策略函数无需使用特殊名字，即不用再以<code>_promo</code>结尾</li>
<li><code>@promotion</code>装饰器突出了被装饰函数的作用，还便于临时禁用某个促销策略（只需将装饰器注释掉）</li>
<li>促销策略函数在任何地方定义都行，只要加上装饰器即可。</li>
</ul>
<h1 id="闭包">2. 闭包</h1>
<p>正如前文所说，多数装饰器会在内部定义函数，并将其返回，已替换掉传入的函数。这个机制的实现就要靠<strong>闭包</strong>，但在理解闭包之前，先来看看Python中的变量作用域。</p>
<h2 id="变量作用域规则">2.1 变量作用域规则</h2>
<p>通过下述例子来解释局部变量和全局变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码6</span></span><br><span class="line">&gt;&gt;&gt; def f1(a):</span><br><span class="line">...     <span class="built_in">print</span>(a)</span><br><span class="line">...     <span class="built_in">print</span>(b)</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; f1(3)</span><br><span class="line">3</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  -- snip --</span><br><span class="line">NameError: name <span class="string">'b'</span> is not defined</span><br></pre></td></tr></table></figure>
<p>当代码运行到<code>print(a)</code>时，Python查找变量<code>a</code>，发现变量<code>a</code>存在于局部作用域中，于是顺利执行；当运行到<code>print(b)</code>时，python查找变量<code>b</code>，发现局部作用域中并没有变量<code>b</code>，便接着查找全局作用域，发现也没有变量<code>b</code>，最终报错。正确的调用方式相信大家也知道，就是在调用<code>f1(3)</code>之前给变量<code>b</code>赋值。</p>
<p>我们再看如下代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码7</span></span><br><span class="line">&gt;&gt;&gt; b = 6</span><br><span class="line">&gt;&gt;&gt; def f2(a):</span><br><span class="line">...     <span class="built_in">print</span>(a)</span><br><span class="line">...     <span class="built_in">print</span>(b)</span><br><span class="line">...     b = 9</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; f2(3)</span><br><span class="line">3</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  -- snip --</span><br><span class="line">UnboundLocalError: <span class="built_in">local</span> variable <span class="string">'b'</span> referenced before assignment</span><br></pre></td></tr></table></figure>
<p>按理说不应该报错，并且<code>b</code>的值应该打印为6，但结果却不是这样。</p>
<p>事实是：变量<code>b</code>本来是全局变量，但由于在<code>f2()</code>中我们为变量<code>b</code>赋了值，于是Python在局部作用域中也注册了一个名为<code>b</code>的变量（全局变量<code>b</code>依然存在，有编程基础的同学应该知道，这叫做“覆盖”）。当Python执行到<code>print(b)</code>语句时，Python先搜索局部作用域，发现其中有变量<code>b</code>，但是<code>b</code>此时还没有被赋值（全局变量<code>b</code>被覆盖，而局部变量<code>b</code>的赋值语句在该句后面），于是Python报错。</p>
<p>如果不想<code>代码7</code>报错，则需要使用<code>global</code>语句，将变量<code>b</code>声明为全局变量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(a)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">global</span> b</span><br><span class="line"><span class="meta">... </span>    -- snip --</span><br></pre></td></tr></table></figure>
<h2 id="闭包的概念">2.2 闭包的概念</h2>
<p>现在开始真正接触闭包。闭包指延伸了作用域的函数，它包含函数定义体中引用，但不在定义体中定义的<strong>非全局变量</strong>，即这类函数能访问定义体之外的非全局变量。只有涉及嵌套函数时才有闭包问题。</p>
<p>下面用一个例子来说明闭包以及非全局变量。定义一个计算某商品一段时间内均价的函数<code>avg</code>，它的表现如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码9</span></span><br><span class="line">&gt;&gt;&gt; avg(10)</span><br><span class="line">10.0</span><br><span class="line">&gt;&gt;&gt; avg(11)</span><br><span class="line">10.5</span><br><span class="line">&gt;&gt;&gt; avg(12)</span><br><span class="line">11.0</span><br></pre></td></tr></table></figure>
<p>假定商品价格每天都在变化，因此需要一个变量来保存这些值。如果用类的思想，我们可以定义一个可调用对象，把这些值存到内部属性中，然后实现<code>__call__</code>方法，让其表现得像函数；但如果按装饰器的思想，可以定义一个如下的嵌套函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码10</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line">    series = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">        series.append(new_value)</span><br><span class="line">        total = sum(series)</span><br><span class="line">        <span class="keyword">return</span> total / len(series)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> averager</span><br></pre></td></tr></table></figure>
<p>然后以如下方式使用这个函数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码11</span></span><br><span class="line">&gt;&gt;&gt; avg = make_averager()</span><br><span class="line">&gt;&gt;&gt; avg(10)</span><br><span class="line">10.0</span><br><span class="line">-- snip --</span><br></pre></td></tr></table></figure>
<p>不知道大家刚接触这个内部的<code>averager()</code>函数时有没有疑惑：<code>代码11</code>中，当执行<code>avg(10)</code>时，它是到哪里去找的变量<code>series</code>？<code>series</code>是函数<code>make_averager()</code>的局部变量，当<code>make_averager()</code>返回了<code>averager()</code>后，它的局部作用域就消失了，所以按理说<code>series</code>也应该跟着消失，并且上述代码应该报错才对。</p>
<p>事实上，在<code>averager</code>函数中，<code>series</code>是<strong>自由变量</strong>（free variable），即未在局部作用域中绑定的变量。这里，自由变量<code>series</code>和内部函数<code>averager</code>共同组成了闭包，参考下图：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828546/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF26-%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8%E5%92%8C%E9%97%AD%E5%8C%85/1527397649944.png" /></p>
<p>实际上，Python在<code>averager</code>的<code>__code__</code>属性中保存了局部变量和自由变量的名称，在<code>__closure__</code>属性中保存了自由变量的值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码12，注意这些变量的单词含义，一目了然</span></span><br><span class="line">&gt;&gt;&gt; avg.__code__.co_varnames  <span class="comment"># co_varnames保存局部变量的名称</span></span><br><span class="line">(<span class="string">'new_value'</span>, <span class="string">'total'</span>)</span><br><span class="line">&gt;&gt;&gt; avg.__code__.co_freevars <span class="comment"># co_freevars保存自由变量的名称</span></span><br><span class="line">(<span class="string">'series'</span>,)</span><br><span class="line">&gt;&gt;&gt; avg.__closure__ <span class="comment"># 单词closure就是闭包的意思</span></span><br><span class="line"><span class="comment"># __closure__是一个cell对象列表，其中的元素和co_freevars元组一一对应</span></span><br><span class="line">(&lt;cell at 0x0000024EE023D7F8: list object at 0x0000024EDFE76288&gt;,)</span><br><span class="line">&gt;&gt;&gt; avg.__closure__[0].cell_contents </span><br><span class="line">[10, 11, 12] <span class="comment"># cell对象的cell_contents属性才是真正保存自由变量的值的地方</span></span><br></pre></td></tr></table></figure>
<p>综上：<strong>闭包是一种函数，它会保存定义函数时存在的自由变量的绑定，这样调用函数时，虽然外层函数的局部作用域不可用了，但仍能使用那些绑定。</strong></p>
<p>注意：只有嵌套在其他函数中的函数才可能需要处理不在全局作用域中的外部变量。</p>
<h2 id="nonlocal声明">2.3 nonlocal声明</h2>
<p><code>代码10</code>中的<code>make_averager</code>函数并不高效，因为如果只计算均值的话，其实不用保存每次的价格，我们可按如下方式改写<code>代码10</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码13</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        total += new_value</span><br><span class="line">        <span class="keyword">return</span> total / count</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> averager</span><br></pre></td></tr></table></figure>
<p>但此时直接运行<code>代码11</code>的话，则会报<code>代码7</code>中的错误：<code>UnboundLocalError</code>。</p>
<p>问题在于：由于<code>count</code>是不可变类型，在执行<code>count += 1</code>时，该语句等价于<code>count = count + 1</code>，而这就成了赋值语句，<code>count</code>不再是自由变量，而变成了<code>averager</code>的局部变量。<code>total</code>也是一样的情况。而在之前的<code>代码10</code>中没有这个问题，因为<code>series</code>是个可变类型，我们只是调用<code>series.append</code>，以及把它传给了<code>sum</code>和<code>len</code>，它并没有变为局部变量。</p>
<p><strong>对于不可变类型来说，只能读取，不能更新，否则会隐式创建局部变量。</strong>为了解决这个问题，Python3引入了<code>nonlocal</code>声明。它的作用是把变量显式标记为自由变量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码14</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> count, total</span><br><span class="line">        -- snip --</span><br></pre></td></tr></table></figure>
<h1 id="装饰器">3. 装饰器</h1>
<p>了解了闭包后，现在开始正式使用嵌套函数来实现装饰器。首先来认识标准库中三个重要的装饰器。</p>
<h2 id="标准库中的装饰器">3.1 标准库中的装饰器</h2>
<h3 id="functools.wraps装饰器">3.1.1 functools.wraps装饰器</h3>
<p>来看一个简单的装饰器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码15</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">        func()</span><br><span class="line">    <span class="keyword">return</span> test</span><br><span class="line"></span><br><span class="line"><span class="meta">@deco</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""This is a test"""</span></span><br><span class="line">    print(<span class="string">"This is a test"</span>)</span><br><span class="line"></span><br><span class="line">print(Test.__name__)</span><br><span class="line">print(Test.__doc__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">test</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>我们想让装饰器来自动帮我们做一些额外的操作，但像改变函数属性这样的操作并不一定是我们想要的：从上面可以看出，<code>Test</code>现在指向了内部函数<code>test</code>，<code>Test</code>自身的属性被遮盖。如果想保留函数原本的属性，可以使用标准库中的<code>functools.wraps</code>装饰器。下面以一个更复杂的装饰器为例，它会在每次调用被装饰函数时计时，并将经过的时间，传入的参数和调用的结果打印出来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码16</span></span><br><span class="line"><span class="comment"># clockdeco.py</span></span><br><span class="line"><span class="keyword">import</span> time, functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span><span class="params">(func)</span>:</span> <span class="comment"># 两层嵌套</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)  # 绑定属性</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clocked</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        t0 = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        elapsed = time.time() - t0</span><br><span class="line">        name = func.__name__</span><br><span class="line">        arg_lst = [] <span class="comment"># 参数列表</span></span><br><span class="line">        <span class="keyword">if</span> args:</span><br><span class="line">            arg_lst.append(<span class="string">", "</span>.join(repr(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> args))</span><br><span class="line">        <span class="keyword">if</span> kwargs:</span><br><span class="line">            pairs = [<span class="string">"%s=%r"</span> % (k, w) <span class="keyword">for</span> k, w <span class="keyword">in</span> sorted(kwargs.items())]</span><br><span class="line">            arg_lst.append(<span class="string">", "</span>.join(pairs))</span><br><span class="line">        arg_str = <span class="string">", "</span>.join(arg_lst)</span><br><span class="line">        print(<span class="string">"[%0.8fs] %s(%s) -&gt; %r"</span> % (elapsed, name, arg_str, result))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> clocked</span><br></pre></td></tr></table></figure>
<p>它的使用将和下一个装饰器一起展示。</p>
<h3 id="functools.lru_cache装饰器">3.1.2 functools.lru_cache装饰器</h3>
<p><code>functools.lru_cache</code>实现了备忘（memoization）功能，这是一项优化技术，他把耗时的函数的结果保存起来，避免传入相同参数时重复计算。以斐波那契函数为例，我们知道以递归形式实现的斐波那契函数会出现很多重复计算，此时，就可以使用这个装饰器。以下代码是没使用该装饰器时的运行情况：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码17</span></span><br><span class="line"><span class="keyword">from</span> clockdeco <span class="keyword">import</span> clock</span><br><span class="line"></span><br><span class="line"><span class="meta">@clock</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n - <span class="number">2</span>) + fibonacci(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(fibonacci.__name__)</span><br><span class="line">    print(fibonacci.__doc__)</span><br><span class="line">    print(fibonacci(<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">fibonacci  <span class="comment"># fibonacci原本的属性得到了保留</span></span><br><span class="line"><span class="literal">None</span></span><br><span class="line">[0.00000000s] fibonacci(0) -&gt; 0</span><br><span class="line">[0.00000000s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00000000s] fibonacci(2) -&gt; 1</span><br><span class="line">[0.00000000s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00000000s] fibonacci(0) -&gt; 0</span><br><span class="line">[0.00000000s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00000000s] fibonacci(2) -&gt; 1</span><br><span class="line">[0.00000000s] fibonacci(3) -&gt; 2</span><br><span class="line">[0.00000000s] fibonacci(4) -&gt; 3</span><br><span class="line">[0.00000000s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00000000s] fibonacci(0) -&gt; 0</span><br><span class="line">[0.00000000s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00000000s] fibonacci(2) -&gt; 1</span><br><span class="line">[0.00000000s] fibonacci(3) -&gt; 2</span><br><span class="line">[0.00000000s] fibonacci(0) -&gt; 0</span><br><span class="line">[0.00000000s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00000000s] fibonacci(2) -&gt; 1</span><br><span class="line">[0.00000000s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00000000s] fibonacci(0) -&gt; 0</span><br><span class="line">[0.00000000s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00049996s] fibonacci(2) -&gt; 1</span><br><span class="line">[0.00049996s] fibonacci(3) -&gt; 2</span><br><span class="line">[0.00049996s] fibonacci(4) -&gt; 3</span><br><span class="line">[0.00049996s] fibonacci(5) -&gt; 5</span><br><span class="line">[0.00049996s] fibonacci(6) -&gt; 8</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>可以看出，<code>fibonacci(1)</code>调用了8次，下面我们用<code>functools.lru_cache</code>来改进上述代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码18</span></span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">from</span> clockdeco <span class="keyword">import</span> clock</span><br><span class="line"></span><br><span class="line"><span class="meta">@functools.lru_cache()  # 注意此处有个括号！该装饰器就收参数！不能省！</span></span><br><span class="line"><span class="meta">@clock</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n - <span class="number">2</span>) + fibonacci(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(fibonacci(<span class="number">6</span>))</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">[0.00000000s] fibonacci(0) -&gt; 0</span><br><span class="line">[0.00000000s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00000000s] fibonacci(2) -&gt; 1</span><br><span class="line">[0.00000000s] fibonacci(3) -&gt; 2</span><br><span class="line">[0.00000000s] fibonacci(4) -&gt; 3</span><br><span class="line">[0.00000000s] fibonacci(5) -&gt; 5</span><br><span class="line">[0.00000000s] fibonacci(6) -&gt; 8</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>
<p><code>functools.lru_cache</code>装饰器可以接受参数，并且此代码还叠放了装饰器。</p>
<p><code>lru_cache</code>有两个参数：<code>functools.lru_cache(maxsize=128, typed=False)</code></p>
<ul>
<li><code>maxsize</code>指定存储多少个调用的结果，该参数最好是2的幂。当缓存满后，根据LRU算法替换缓存中的内容，这也是为什么这个函数叫<code>lru_cache</code>。</li>
<li><code>type</code>如果设置为<code>True</code>，它将把不同参数类型下得到的结果分开保存，即把通常认为相等的浮点数和整数参数分开（比如区分1和1.0）。</li>
<li><code>lru_cache</code>使用字典存储结果，字典的键是传入的参数，所以被<code>lru_cache</code>装饰的函数的所有参数都必须是<strong>可散列</strong>的！</li>
</ul>
<h3 id="functools.singledispatch装饰器">3.1.3 functools.singledispatch装饰器</h3>
<p>我们知道，C++支持函数重载，同名函数可以根据参数类型的不同而调用相应的函数。以Python代码为例，我们希望下面这个函数表现出如下行为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码19</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myprint</span><span class="params">(obj)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello~~~"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下是我们希望它拥有的行为：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myprint(<span class="number">1</span>)</span><br><span class="line">Hello~~~</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myprint([])</span><br><span class="line">Hello~~~</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myprint(<span class="string">"hello"</span>) <span class="comment"># 即，当我们传入特定类型的参数时，函数返回特定的结果</span></span><br><span class="line">This <span class="keyword">is</span> a str</span><br></pre></td></tr></table></figure>
<p>单凭这一个<code>myprint</code>还无法实现上述要求，因为Python不支持方法或函数的重载。为了实现类似的功能，一种常见的做法是将函数变为一个分派函数，使用一串<code>if/elif/elif</code>来判断参数类型，再调用专门的函数（如<code>myprint_str</code>），但这种方式不利于代码的扩展和维护，还显得没有B格。。。</p>
<p>为解决这个问题，从Python3.4开始，可以使用<code>functools.singledispath</code>装饰器，把整体方案拆分成多个模块，甚至可以为无法修改的类提供专门的函数。被<code>@singledispatch</code>装饰的函数会变成<strong>泛函数(generic function)</strong>，它会根据第一个参数的不同而调用响应的专门函数，具体用法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码20</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> singledispatch</span><br><span class="line"><span class="keyword">import</span> numbers</span><br><span class="line"></span><br><span class="line"><span class="meta">@singledispatch</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myprint</span><span class="params">(obj)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello~~~"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以叠放多个register，让同一函数支持不同类型</span></span><br><span class="line"><span class="meta">@myprint.register(str)</span></span><br><span class="line"><span class="comment"># 注册的专门函数最好处理抽象基类，而不是具体实现，这样代码支持的兼容类型更广泛</span></span><br><span class="line"><span class="meta">@myprint.register(numbers.Integral) </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(text)</span>:</span> <span class="comment"># 专门函数的名称无所谓，使用 _ 可以避免起名字的麻烦</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Special types"</span></span><br></pre></td></tr></table></figure>
<p><em>对泛函数的补充：根据参数类型的不同，以不同方式执行相同操作的一组函数。如果依据是第一个参数，则是单分派；如果依据是多个参数，则是多分派。</em></p>
<h2 id="参数化装饰器">3.2 参数化装饰器</h2>
<h3 id="简单版参数化装饰器">3.2.1 简单版参数化装饰器</h3>
<p>从上面诸多例子我们可以看到两大类装饰器：不带参数的装饰器（调用时最后没有括号）和带参数的装饰器（带括号）。Python将被装饰的函数作为第一个参数传给了装饰器函数，那装饰器函数如何接受其他参数呢？做法是：<strong>创建一个装饰器工厂函数，在这个工厂函数内部再定义其它函数作为真正的装饰器。工厂函数代为接受参数，这些参数作为自由变量供装饰器使用。然后工厂函数返回装饰器，装饰器再应用到被装饰函数上。</strong></p>
<p>我们把1.2中<code>代码4</code>的<code>@register</code>装饰器改为带参数的版本，以<code>active</code>参数来指示装饰器是否注册某函数（虽然这么做有点多余）。这里只给出<code>@register</code>装饰器的实现，其余代码参考<code>代码4</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码21</span></span><br><span class="line">registry = set()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(active=True)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span> <span class="comment"># 变量active对于decorate函数来说是自由变量</span></span><br><span class="line">        print(<span class="string">"running register(active=%s)-&gt;decorate(%s)"</span> % (active, func))</span><br><span class="line">        <span class="keyword">if</span> active: </span><br><span class="line">            registry.add(func)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            registry.discard(func)</span><br><span class="line">        <span class="keyword">return</span> func</span><br><span class="line">    <span class="keyword">return</span> decorate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用法</span></span><br><span class="line"><span class="meta">@register(active=False) # 即使不传参数也要作为函数调用@register()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上述用法相当于如下代码：</span></span><br><span class="line"><span class="comment"># register(active=False)(f)</span></span><br></pre></td></tr></table></figure>
<h3 id="多层嵌套版参数化装饰器">3.2.2 多层嵌套版参数化装饰器</h3>
<p>参数化装饰器通常会把被装饰函数替换掉，而且结构上需要多一层嵌套。下面以3.1.1中<code>代码16</code>里的<code>@clock</code>装饰器为例，让它按用户要求的格式输出数据。为了简便，不调用<code>functools.wraps</code>装饰器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码22</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">DEFAULT_FMT = <span class="string">"[&#123;elapsed:0.8f&#125;s] &#123;name&#125;(&#123;args&#125;) -&gt; &#123;result&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span><span class="params">(fmt=DEFAULT_FMT)</span>:</span>   <span class="comment"># 装饰器工厂，fmt是装饰器的参数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span>       <span class="comment"># 装饰器</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">clocked</span><span class="params">(*_args)</span>:</span>  <span class="comment"># 最终的函数</span></span><br><span class="line">            t0 = time.time()</span><br><span class="line">            _result = func(*_args)</span><br><span class="line">            elapsed = time.time() - t0</span><br><span class="line">            name = func.__name__</span><br><span class="line">            args = <span class="string">", "</span>.join(repr(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> _args)</span><br><span class="line">            result = repr(_result)</span><br><span class="line">            print(fmt.format(**locals())) <span class="comment">#locals()函数以字典形式返回clocked的局部变量</span></span><br><span class="line">            <span class="keyword">return</span> _result</span><br><span class="line">        <span class="keyword">return</span> clocked</span><br><span class="line">    <span class="keyword">return</span> decorate</span><br></pre></td></tr></table></figure>
<p>可以得到如下结论：装饰器函数有且只有一个参数，即被装饰器的函数；如果装饰器要接受其他参数，请在原本的装饰器外再套一层函数（工厂函数），由它来接受其余参数；而你最终使用的函数应该定义在装饰器函数中，且它的参数列表应该和被装饰的函数一致。</p>
<h1 id="总结">4. 总结</h1>
<p>本篇首先介绍了最简单装饰器如何定义和使用，介绍了装饰器在什么时候被执行，以及用最简单的装饰器改造了上一篇的策略模式；随后更进一步，介绍了与闭包相关的概念，包括变量作用域，闭包和nonlocal声明；最后介绍了更复杂的装饰器，包括标准库中的装饰器的用法，以及如何定义带参数的装饰器。</p>
<p>但上述对装饰器的描述都是基本的， 更复杂、工业级的装饰器还需要更深入的学习。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python进阶</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python进阶</tag>
        <tag>装饰器</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路25-使用一等函数实现设计模式</title>
    <url>/2018/05/25/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF25-%E4%BD%BF%E7%94%A8%E4%B8%80%E7%AD%89%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>《流畅的Python》笔记。</p>
<p>本篇主要讲述Python中使用函数来实现策略模式和命令模式，最后总结出这种做法背后的思想。</p>
</blockquote>
<a id="more"></a>
<h1 id="重构策略模式">1. 重构策略模式</h1>
<p>策略模式如果用面向对象的思想来简单解释的话，其实就是“多态”。父类指向子类，根据子类对同一方法的不同重写，得到不同结果。</p>
<h2 id="经典的策略模式">1.1 经典的策略模式</h2>
<p>下图是经典的策略模式的UML类图：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828528/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF25-%E4%BD%BF%E7%94%A8%E4%B8%80%E7%AD%89%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1527233608635.png" /></p>
<p>《设计模式：可复用面向对象软件的基础》一书这样描述策略模式：</p>
<p><strong><em>定义一系列算法，把它们封装起来，且使它们能相互替换。本模式使得算法可独立于使用它的客户而变化。</em></strong></p>
<p>下面以一个电商打折的例子来说明策略模式，打折方案如下：</p>
<ul>
<li>有1000及以上积分的顾客，每个订单享5%优惠；</li>
<li>同一订单中，每类商品的数量达到20个及以上时，该类商品享10%优惠；</li>
<li>订单中的不同商品达10个及以上时，整个订单享7%优惠。</li>
</ul>
<p>为此我们需要创建5个类：</p>
<ul>
<li><code>Order</code>类：订单类，相当于上述UML图中的<code>Context</code>上下文；</li>
<li><code>Promotion</code>类：折扣类的父类，相当于UML图中的<code>Strategy</code>策略类，实现不同策略的共同接口；</li>
<li>具体策略类：<code>FidelityPromo</code>，<code>BulkPromo</code>和<code>LargeOrderPromo</code>依次对应于上述三个打折方案。</li>
</ul>
<p>以下是经典的策略模式在Python中的实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Customer = namedtuple(<span class="string">"Customer"</span>, <span class="string">"name fidelity"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span>  <span class="comment"># 单个商品</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, product, quantity, price)</span>:</span></span><br><span class="line">        self.produce = product</span><br><span class="line">        self.quantity = quantity</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.price * self.quantity</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span>:</span>  <span class="comment"># 订单类，上下文</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, customer, cart, promotion=None)</span>:</span></span><br><span class="line">        self.customer = customer</span><br><span class="line">        self.cart = list(cart)  <span class="comment"># 形参cart中的元素是LineItem</span></span><br><span class="line">        self.promotion = promotion</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total</span><span class="params">(self)</span>:</span>  <span class="comment"># 未打折时的总价</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, <span class="string">"__total"</span>):</span><br><span class="line">            self.__total = sum(item.total() <span class="keyword">for</span> item <span class="keyword">in</span> self.cart)</span><br><span class="line">        <span class="keyword">return</span> self.__total</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">due</span><span class="params">(self)</span>:</span>  <span class="comment"># 折扣</span></span><br><span class="line">        <span class="keyword">if</span> self.promotion <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            discount = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            discount = self.promotion.discount(self)</span><br><span class="line">        <span class="keyword">return</span> self.total() - discount</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promotion</span><span class="params">(ABC)</span>:</span> <span class="comment"># 策略：抽象基类</span></span><br><span class="line"><span class="meta">    @abstractmethod  # 抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">discount</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="string">"""返回折扣金额（正值）"""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FidelityPromo</span><span class="params">(Promotion)</span>:</span> <span class="comment"># 第一个具体策略</span></span><br><span class="line">    <span class="string">"""积分1000及以上的顾客享5%"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">discount</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> order.total() * <span class="number">0.05</span> <span class="keyword">if</span> order.customer.fidelity &gt;= <span class="number">1000</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BulkItemPromo</span><span class="params">(Promotion)</span>:</span> <span class="comment"># 第二个具体策略</span></span><br><span class="line">    <span class="string">"""某类商品为20个及以上时，该类商品享10%优惠"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">discount</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        discount = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> order.cart:</span><br><span class="line">            <span class="keyword">if</span> item.quantity &gt;= <span class="number">20</span>:</span><br><span class="line">                discount += item.total() * <span class="number">0.1</span></span><br><span class="line">        <span class="keyword">return</span> discount</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LargeOrderPromo</span><span class="params">(Promotion)</span>:</span> <span class="comment"># 第三个具体策略</span></span><br><span class="line">    <span class="string">"""订单中的不同商品达到10个及以上时享7%优惠"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">discount</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        distinct_items = &#123;item.product <span class="keyword">for</span> item <span class="keyword">in</span> order.cart&#125;</span><br><span class="line">        <span class="keyword">if</span> len(distinct_items) &gt;= <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> order.total() * <span class="number">0.07</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>该类的使用示例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; ann = Customer(<span class="string">"Ann Smith"</span>, 1100)</span><br><span class="line">&gt;&gt;&gt; joe = Customer(<span class="string">"John Joe"</span>, 0)</span><br><span class="line">&gt;&gt;&gt; cart = [LineItem(<span class="string">"banana"</span>, 4, 0.5), LineItem(<span class="string">"apple"</span>, 10, 1.5), </span><br><span class="line">...         LineItem(<span class="string">"watermellon"</span>, 5, 5.0)]</span><br><span class="line">&gt;&gt;&gt; Order(ann, cart, FidelityPromo())  <span class="comment"># 每次新建一个具体策略类</span></span><br><span class="line">&gt;&gt;&gt; Order(joe, cart, FidelityPromo())</span><br></pre></td></tr></table></figure>
<h2 id="python函数重构策略模式">1.2 Python函数重构策略模式</h2>
<p>现在用Python函数以更少的代码来重构上述的策略模式，去掉了抽象类<code>Promotion</code>，用函数代替具体的策略类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不用导入abc模块，去掉了Promotion抽象类;</span></span><br><span class="line"><span class="comment"># Customer, LineItem不变，Order类只修改due()函数；三个具体策略类改为函数</span></span><br><span class="line">-- snip -- </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span>:</span></span><br><span class="line">    -- snip --</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">due</span><span class="params">(self)</span>:</span>  <span class="comment"># 折扣</span></span><br><span class="line">        <span class="keyword">if</span> self.promotion <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            discount = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            discount = self.promotion(self)  <span class="comment"># 修改为函数</span></span><br><span class="line">        <span class="keyword">return</span> self.total() - discount</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fidelity_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""积分1000及以上的顾客享5%"""</span></span><br><span class="line">    <span class="keyword">return</span> order.total() * <span class="number">0.05</span> <span class="keyword">if</span> order.customer.fidelity &gt;= <span class="number">1000</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bulk_item_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""某类商品为20个及以上时，该类商品享10%优惠"""</span></span><br><span class="line">    discount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> order.cart:</span><br><span class="line">        <span class="keyword">if</span> item.quantity &gt;= <span class="number">20</span>:</span><br><span class="line">            discount += item.total() * <span class="number">0.1</span></span><br><span class="line">    <span class="keyword">return</span> discount</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">large_order_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""订单中的不同商品达到10个及以上时享7%优惠"""</span></span><br><span class="line">    distinct_items = &#123;item.product <span class="keyword">for</span> item <span class="keyword">in</span> order.cart&#125;</span><br><span class="line">    <span class="keyword">if</span> len(distinct_items) &gt;= <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">return</span> order.total() * <span class="number">0.07</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>该类现在的使用示例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; Order(ann, cart, fidelity_promo)  <span class="comment"># 没有实例化新的促销对象，函数拿来即用</span></span><br></pre></td></tr></table></figure>
<p>脱离Python语言环境，从面相对象编程来说：</p>
<p>1.1中的使用示例可以看出，每次创建<code>Order</code>类时，都创建了一个具体策略类，即使不同的订单都用的同一个策略。按理说它们应该共享同一个具体策略的实例，但实际并没有。这就是策略模式的一个弊端。为了弥补这个弊端，如果具体的策略没有维护内部状态，你可以为每个具体策略创建一个实例，然后每次都传入这个实例，这就是单例模式；但如果要维护内状态，就需要将策略模式和享元模式结合使用，这又提高了代码行数和维护成本。</p>
<p>在Python中则可以用函数来避开策略模式的这些弊端：</p>
<ul>
<li>不用维护内部状态时，我们可以直接用一般的函数；如果需要维护内部状态，可以编写装饰器（装饰器也是函数）；</li>
<li>相对于编写一个抽象类，再实现这个抽象类的接口来说，直接编写函数更方便；</li>
<li>函数比用户定义的类的实例更轻量；</li>
<li>无需去实现享元模式，每个函数在Python编译模块时只会创建一次，函数本身就是可共享的对象。</li>
</ul>
<h2 id="自动选择最佳策略">1.3 自动选择最佳策略</h2>
<p>上述代码中，我们需要自行传入打折策略，但我们更希望的是程序自动选择最佳打折策略。以下是我们最能想到的一种方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在生成Order实例时，传入一个best_promo函数，让其自动选择最佳策略</span></span><br><span class="line">promos = [fidelity_promo, bulk_item_promo, large_order_promo] <span class="comment"># 三个打折函数的列表</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">best_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""选择可用的最佳策略"""</span></span><br><span class="line">    <span class="keyword">return</span> max(promo(order) <span class="keyword">for</span> promo <span class="keyword">in</span> promos)</span><br></pre></td></tr></table></figure>
<p>但这样做有一个弊端：如果要新增打折策略，不光要编写打折函数，还得把函数手动加入到<code>promos</code>列表中。我们希望程序自动识别这些具体策略。改变代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">promos = [globals()[name] <span class="keyword">for</span> name <span class="keyword">in</span> globals() </span><br><span class="line">          <span class="keyword">if</span> name.endswith(<span class="string">"_promo"</span>) <span class="keyword">and</span> </span><br><span class="line">          name != <span class="string">"best_promo"</span>] <span class="comment"># 自动获取当前模块中的打折函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">best_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    -- snip --</span><br></pre></td></tr></table></figure>
<p>在Python中，<strong>模块也是一等对象</strong>，<code>globals()</code>函数是标准库提供的处理模块的函数，它返回一个字典，表示当前全局符号表。这个符号表始终针对当前模块（对函数或方法来说，是指定义它们的模块，而不是调用它们的模块）</p>
<p>如果我们把各种具体策略单独放到一个模块中，比如放到<code>promotions</code>模块中，上述代码还可改为如下形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 各具体策略单独放到一个模块中</span></span><br><span class="line"><span class="keyword">import</span> promotions, inspect</span><br><span class="line"><span class="comment"># inspect.getmembers函数用于获取对象的属性，第二个参数是可选的判断条件</span></span><br><span class="line">promos = [func <span class="keyword">for</span> name, func <span class="keyword">in</span> inspect.getmembers(promotions, inspect.isfunction)]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">best_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    -- snip --</span><br></pre></td></tr></table></figure>
<p>其实，动态收集具体策略函数更为显式的一种方案是使用简单的装饰器，这将在下一篇中介绍。</p>
<h1 id="命令模式">2. 命令模式</h1>
<p>命令模式的UML类图如下：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828528/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF25-%E4%BD%BF%E7%94%A8%E4%B8%80%E7%AD%89%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1527233497131.png" /></p>
<p>命令模式的目的是解耦发起调用的对象（调用者，<code>Caller</code>）和提供实现的对象（接受者，<code>Receiver</code>）。实际做法就是在它们之间增加一个命令类（<code>Command</code>），它只有一个抽象接口<code>execute()</code>，具体命令类实现这个接口即可。这样调用者就无需了解接受者的接口，不同的接受者还可以适应不同的<code>Command</code>子类。</p>
<p>有人说“命令模式是回调机制的面向对象替代品”，但问题是，Python中我们不一定需要这个替代品。具体说来，我们可以不为调用者提供一个<code>Command</code>实例，而是给它一个函数。此时，调用者不用调用<code>command.execute()</code>，而是直接<code>command()</code>。</p>
<p>以下是一般的命令模式代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Caller</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, command=None)</span>:</span></span><br><span class="line">        self.command = command</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">action</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""把对接受者的调用交给中介Command"""</span></span><br><span class="line">        self.command.execute()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receiver</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_something</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""具体的执行命令"""</span></span><br><span class="line">        print(<span class="string">"I'm a receiver"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Command</span><span class="params">(ABC)</span>:</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""调用具体的接受者方法"""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand</span><span class="params">(Command)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, receiver)</span>:</span></span><br><span class="line">        self.receiver = receiver</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.receiver.do_something()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    receiver = Receiver()</span><br><span class="line">    command = ConcreteCommand(receiver)</span><br><span class="line">    caller = Caller(command)</span><br><span class="line">    caller.action()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">I<span class="string">'m a receiver</span></span><br></pre></td></tr></table></figure>
<p>直接将上述代码改成函数的形式，其实并不容易改写，因为具体的命令类还保存了接收者。但是换个思路，将其改成可调用对象，那么代码就可以变成如下形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Caller</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, command=None)</span>:</span></span><br><span class="line">        self.command = command</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">action</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 之前是self.command.execute()</span></span><br><span class="line">        self.command()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receiver</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_something</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""具体的执行命令"""</span></span><br><span class="line">        print(<span class="string">"I'm a receiver"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, receiver)</span>:</span></span><br><span class="line">        self.receiver = receiver</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.receiver.do_something()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    receiver = Receiver()</span><br><span class="line">    command = ConcreteCommand(receiver)</span><br><span class="line">    caller = Caller(command)</span><br><span class="line">    caller.action()</span><br></pre></td></tr></table></figure>
<h1 id="总结">3. 总结</h1>
<p>看完这两个例子，不知道大家发现了什么相似之处了没有：</p>
<p><strong>它们都把实现单方法接口的类的实例替换成了可调用对象。毕竟，每个Python可调用对象都实现了单方法接口，即<code>__call__</code>方法。</strong></p>
<p>直白一点说就是，如果你定义了一个抽象类，这个类只有一个抽象方法<code>a()</code>，然后还要为这个抽象类派生出一大堆具体类来重写这个方法<code>a()</code>，那么此时大可不必定义这个抽象类，直接将这些具体类改写成可调用对象即可，在<code>__call__</code>方法中实现<code>a()</code>要实现的功能。</p>
<p>这相当于<strong>用Python中可调用对象的基类充当了我们定义的基类</strong>，我们便不用再定义基类；<strong>对抽象方法<code>a()</code>的重写变成了对特殊方法<code>__call__</code>的重写</strong>，毕竟我们只是想要这些方法有一个相同的名字，至于叫什么其实无所谓。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python进阶</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python进阶</tag>
        <tag>函数</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路24-一等函数</title>
    <url>/2018/05/24/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF24-%E4%B8%80%E7%AD%89%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<blockquote>
<p>《流畅的Python》笔记。</p>
<p>本篇主要讲述Python中函数的进阶内容。包括函数和对象的关系，函数内省，Python中的函数式编程。</p>
</blockquote>
<a id="more"></a>
<h1 id="前言">1. 前言</h1>
<p>本片首先介绍函数和对象的关系；随后介绍函数和可调用对象的关系，以及函数内省。函数内省这部分会涉及很多与IDE和框架相关的东西，如果平时并不写框架，可以略过此部分。最后介绍函数式编程的相关概念，以及与之相关的两个重要模块：operator模块和functools模块。</p>
<p>首先补充“一等对象”的概念。“一等对象”一般定义如下：</p>
<ul>
<li>在运行时创建；</li>
<li>能赋值给变量或数据结构中的元素；</li>
<li>能作为参数传给函数；</li>
<li>能作为函数的返回结果。</li>
</ul>
<p>从上述定义可以看出，Python中的函数符合上述四点，所以在Python中函数也被视作一等对象。</p>
<p>“把函数视作一等对象”简称为“一等函数”，但这并不是指有一类函数是“一等函数”，在<strong>Python中所有函数都是一等函数</strong>！</p>
<h1 id="函数">2. 函数</h1>
<h2 id="函数是对象">2.1 函数是对象</h2>
<p>为了表明Python中函数就是对象，我们可以使用<code>type()</code>函数来判断函数的类型，并且访问函数的<code>__doc__</code>属性，同时我们还将函数赋值给一个变量，并且将函数作为参数传入另一个函数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">def factorial(n):</span><br><span class="line">    <span class="string">""</span><span class="string">"return n!"</span><span class="string">""</span></span><br><span class="line">    <span class="built_in">return</span> 1 <span class="keyword">if</span> n &lt; 2 <span class="keyword">else</span> n * factorial(n - 1)</span><br><span class="line"><span class="comment"># 在Python控制台中，help(factorial)也会访问函数的__doc__属性。</span></span><br><span class="line"><span class="built_in">print</span>(factorial.__doc__)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(factorial))</span><br><span class="line"><span class="comment"># 把函数赋值给一个变量</span></span><br><span class="line">fact = factorial</span><br><span class="line"><span class="built_in">print</span>(fact)</span><br><span class="line">fact(5)</span><br><span class="line"><span class="comment"># 把函数传递给另一个函数</span></span><br><span class="line"><span class="built_in">print</span>(list(map(fact, range(11))))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line"><span class="built_in">return</span> n!</span><br><span class="line">&lt;class <span class="string">'function'</span>&gt;</span><br><span class="line">&lt;<span class="keyword">function</span> factorial at 0x000002421033C2F0&gt;</span><br><span class="line">[1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800]</span><br></pre></td></tr></table></figure>
<p>从上述结果可以看出，<code>__doc__</code>属性保存了函数的文档字符串，而<code>type()</code>的结果说明函数其实是<code>function</code>类的一个实例。将函数赋值给一个变量和将函数作为参数传递给另一个函数则体现了“一等对象”的特性。</p>
<h2 id="高阶函数">2.2 高阶函数</h2>
<p>接收函数作为参数，或者把函数作为结果返回的函数叫做<strong>高阶函数</strong>(higher-order function)，上述的<code>map</code>函数就是高阶函数，还有我们常用的<code>sorted</code>函数也是。</p>
<p>大家或多或少见过<code>map</code>，<code>filter</code>和<code>reduce</code>三个函数，这三个就是高阶函数，在过去很常用，但现在它们都有了替代品：</p>
<ul>
<li>Python3中，<code>map</code>和<code>filter</code>依然是内置函数，但由于有了列表推导和生成器表达式，这两个函数已不常用；</li>
<li>Python3中，<code>reduce</code>已不是内置函数，它被放到了functools模块中。它常被用于求和，但现在求和最好用内置的<code>sum</code>函数。</li>
</ul>
<p><code>sum</code>和<code>reduce</code>这样的函数叫做归约函数，它们的思想是将某个操作连续应用到一系列数据上，累计之前的结果，最后得到一个值，即将一系列元素归约成一个值。</p>
<p>内置的归约函数还有<code>all</code>和<code>any</code>：</p>
<ul>
<li><code>all(iterable)</code>：如果<code>iterable</code>中每个值都为真，则返回<code>True</code>；<code>all([])</code>返回<code>True</code>；</li>
<li><code>any(iterable)</code>：如果<code>iterable</code>中有至少一个元素为真，则返回<code>True</code>；<code>any([])</code>返回<code>False</code>。</li>
</ul>
<h2 id="匿名函数">2.3 匿名函数</h2>
<p><code>lambda</code>关键字在Python表达式内创建匿名函数，但在Python中，匿名函数内不能赋值，也不能使用<code>while</code>，<code>try</code>等语句。但它和<code>def</code>语句一样，实际创建了函数对象。</p>
<p>如果使用<code>lambda</code>表达式导致一段代码难以理解，最好还是将其转换成用<code>def</code>语句定义的函数。</p>
<h1 id="可调用对象">3. 可调用对象</h1>
<p>函数其实一个可调用对象，它实现了<code>__call__</code>方法。Python数据模型文档列出了7种可调用对象：</p>
<ul>
<li>用于定义的函数：使用<code>def</code>语句或<code>lambda</code>表达式创建；</li>
<li>内置函数：使用C语言（CPython）实现的函数，如<code>len</code>或<code>time.strftime</code>；</li>
<li>内置方法：使用C语言实现的方法，如<code>dict.get</code>；</li>
<li>方法：在类的定义体中定义的函数；</li>
<li>类：调用类时（也就是实例化一个类时）会运行类的<code>__new__</code>方法创建一个实例，然后运行<code>__init__</code>方法初始化实例，最后把实例返回给调用方。因为Python没有<code>new</code>运算符，所以调用类相当于调用函数；</li>
<li>类的实例：如果类实现了<code>__call__</code>方法，那么它的实例可以作为函数调用；</li>
<li>生成器函数：使用<code>yield</code>关键字的函数或方法。调用生成器函数返回的是生成器对象。</li>
</ul>
<h2 id="用户定义的可调用类型">3.1 用户定义的可调用类型</h2>
<p>任何Python对象都可以表现得像函数，只要实现<code>__call__</code>方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SayHello</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sayhello</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Hello!"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.sayhello()</span><br><span class="line"></span><br><span class="line">say = SayHello()</span><br><span class="line">say.sayhello()</span><br><span class="line">say()</span><br><span class="line">print(callable(say))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">Hello!</span><br><span class="line">Hello!</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>实现<code>__call__</code>方法的类是创建<strong>函数类对象</strong>的简便方式。有时这些类必须在内部维护一些状态，让它在调用之间可用，比如装饰器。装饰器必须是函数，而且有时还要在多次调用之间保存一些数据。</p>
<h2 id="函数内省">3.2 函数内省</h2>
<p>以下内容在<strong>编写框架和IDE</strong>时用的比较多。</p>
<p>笔者之前偶有见到”内省“，但一直不明白”内省“这个词究竟是什么意思。“自我反省”？其实在编程中，这个词的意思就是：让代码自动确定某一段代码能干什么。如果以函数举例，就是函数A自动确定函数B是什么，包含哪些信息，能干什么。不过在讲Python函数的内省之前，先来看看函数都有哪些属性和方法。</p>
<h3 id="函数的属性和方法">3.2.1 函数的属性和方法</h3>
<p><code>dir</code>函数可以检测一个参数所含有的属性和方法。我们可以用该函数查看一个函数所包含的属性和方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; dir(factorial)</span><br><span class="line">[<span class="string">'__annotations__'</span>, <span class="string">'__call__'</span>, <span class="string">'__class__'</span>, <span class="string">'__closure__'</span>, <span class="string">'__code__'</span>, <span class="string">'__defaults__'</span>, </span><br><span class="line"><span class="string">'__delattr__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__get__'</span>, </span><br><span class="line"><span class="string">'__getattribute__'</span>, <span class="string">'__globals__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__init_subclass__'</span>, </span><br><span class="line"><span class="string">'__kwdefaults__'</span>, <span class="string">'__le__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__module__'</span>, <span class="string">'__name__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, </span><br><span class="line"><span class="string">'__qualname__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, </span><br><span class="line"><span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>]</span><br></pre></td></tr></table></figure>
<p>其中大多数属性是Python对象共有的。函数独有的属性如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; class C:pass</span><br><span class="line">&gt;&gt;&gt; obj = C()</span><br><span class="line">&gt;&gt;&gt; def func():pass</span><br><span class="line">&gt;&gt;&gt; sorted(<span class="built_in">set</span>(dir(func)) - <span class="built_in">set</span>(dir(obj)))</span><br><span class="line">[<span class="string">'__annotations__'</span>, <span class="string">'__call__'</span>, <span class="string">'__closure__'</span>, <span class="string">'__code__'</span>, <span class="string">'__defaults__'</span>, <span class="string">'__get__'</span>, </span><br><span class="line"><span class="string">'__globals__'</span>, <span class="string">'__kwdefaults__'</span>, <span class="string">'__name__'</span>, <span class="string">'__qualname__'</span>]</span><br></pre></td></tr></table></figure>
<h3 id="dict__属性">3.2.2 __dict__属性</h3>
<p>与用户定义的常规类一样，函数使用<code>__dict__</code>属性存储用户赋予它的属性。这相当于一种基本形式的注解。</p>
<p>这里可能有人觉得别扭：之前都是给变量或者对象赋予属性，现在是给函数或者方法赋予属性。不过正如前面说的，Python中函数就是对象。</p>
<p>一般来说，为函数赋予属性不是个常见的做法，但Django框架就有这样的行为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upper_case_name</span><span class="params">(obj)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="string">"%s %s"</span> % (obj.first_name, obj.last_name)).upper()</span><br><span class="line">upper_case_name.short_description = <span class="string">"Customer name"</span>   <span class="comment"># 给方法赋予了一个属性</span></span><br></pre></td></tr></table></figure>
<h3 id="获取关于参数的信息">3.2.3 获取关于参数的信息</h3>
<p>从这里开始就是函数内省的内容。在HTTP为框架Bobo中有个使用函数内省的例子，它以装饰器的形式展示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bobo</span><br><span class="line"></span><br><span class="line"><span class="meta">@bobo.query("/")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(person)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello %s!"</span> % person</span><br></pre></td></tr></table></figure>
<p>通过装饰器<code>bobo.query</code>，Bobo会<strong>内省</strong><code>hello</code>函数：Bobo会发现这个<code>hello</code>函数需要一个名为<code>person</code>的参数，然后它就会从请求中获取这个参数，并将这个参数传给<code>hello</code>函数。</p>
<p>有了这个装饰器，我们就不用自己处理请求对象来获取<code>person</code>参数，Bobo框架帮我们自动完成了。</p>
<p>那这究竟是怎么实现的呢？Bobo怎么知道我们写的函数需要哪些参数？它又是怎么知道参数有没有默认值呢？</p>
<p>这里用到了函数对象特有的一些属性（如果不了解参数类型，可以阅读笔者的“Python学习之路7”中的相关内容）：</p>
<ul>
<li><code>__defaults__</code>的值是一个元组，存储着<strong>关键字参数的默认值</strong>和<strong>位置参数</strong>；</li>
<li><code>__kwdefaults__</code>存储着命名<strong>关键字参数的默认值</strong>；</li>
<li><code>__code__</code>属性存储<strong>参数的名称</strong>，它的值是一个<code>code</code>对象引用，自身也有很多属性。</li>
</ul>
<p>下面通过一个例子说明这些属性的用途：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a, b=<span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="string">"""This is just a test"""</span></span><br><span class="line">    c = <span class="number">20</span></span><br><span class="line">    <span class="keyword">if</span> a &gt; <span class="number">10</span>:</span><br><span class="line">        d = <span class="number">30</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        e = <span class="number">30</span></span><br><span class="line"></span><br><span class="line">print(func.__defaults__)</span><br><span class="line">print(func.__code__)</span><br><span class="line">print(func.__code__.co_varnames)</span><br><span class="line">print(func.__code__.co_argcount)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">(<span class="number">10</span>,)</span><br><span class="line">&lt;code object func at <span class="number">0x0000021651851DB0</span>, file <span class="string">"mytest.py"</span>, line <span class="number">1</span>&gt;</span><br><span class="line">(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>可以看出，这种信息的组织方式并不方便：</p>
<ul>
<li>参数名在<code>__code__.co_varnames</code>中，它同时还存储了函数定义体中的局部变量，因此，只有前<code>__code__.co_argcount</code>个元素是参数名（不包含前缀为<code>*</code>何<code>**</code>的的变长参数）；</li>
<li>如果想将参数名和默认值对应上，只能从后向前扫描<code>__default__</code>属性，比如上例中关键字参数<code>b</code>的默认值<code>10</code>。</li>
</ul>
<p>不过，我们并不是第一个发现这种方式很不方便。已经有人为我们造好了轮子，我们可以使用inspect模块简化上述操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from mytest import func</span><br><span class="line">&gt;&gt;&gt; from inspect import signature</span><br><span class="line">&gt;&gt;&gt; sig = signature(func) <span class="comment"># 返回一个inspect.Signature对象（签名对象）</span></span><br><span class="line">&gt;&gt;&gt; sig</span><br><span class="line">&lt;Signature (a, b=10)&gt;</span><br><span class="line">&gt;&gt;&gt; str(sig)</span><br><span class="line"><span class="string">'(a, b=10)'</span></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">for</span> name, param <span class="keyword">in</span> sig.parameters.items():</span><br><span class="line">...     <span class="built_in">print</span>(param.kind, <span class="string">":"</span>, name, <span class="string">"="</span>,param.default) </span><br><span class="line">...</span><br><span class="line">POSITIONAL_OR_KEYWORD : a = &lt;class <span class="string">'inspect._empty'</span>&gt; <span class="comment"># 表示没有默认值</span></span><br><span class="line">POSITIONAL_OR_KEYWORD : b = 10</span><br></pre></td></tr></table></figure>
<p><code>inspect.Signature</code>对象有一个属性<code>parameters</code>，该属性是个有序映射，把<strong>参数名</strong>和<code>inspect.Parameter</code>对象对应起来。<code>inspect.Parameter</code>也有自己的属性，如：</p>
<ul>
<li><code>name</code>：参数的名称；</li>
<li><code>default</code>：参数的默认值；</li>
<li><code>kind</code>：参数的类型，有5种，<code>POSITIONAL_OR_KEYWORD</code>，<code>VAR_POSITIONAL</code>（任意数量参数，以一个*号开头的那种参数），<code>VAR_KEYWORD</code>（任意数量的关键字参数，以**开头的那种参数），<code>KEYWORD_ONLY</code>（命名关键字参数）和<code>POSITIONAL_ONLY</code>（Python句法不支持该类型）</li>
<li><code>annotation</code>和<code>return_annotation</code>：参数和返回值的注解，后面会讲到。</li>
</ul>
<p><code>inspect.Signature</code>对象有个<code>bind</code>方法，它可把任意个参数绑定到<code>Singature</code>中的形参上，框架可使用这个方法在真正调用函数前验证参数是否正确。比如你自己写的框架中的某函数A自动获取用户输入的参数，并根据这些参数调用函数B，但在调用B之前，你想检测下这些参数是否符合函数B对形参的要求，此时你就有可能用到这个<code>bind</code>方法，看能不能将这些参数绑定到函数B上，如果能，则可认为能够根据这些参数调用函数B：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from mytest import func</span><br><span class="line">&gt;&gt;&gt; from inspect import signature</span><br><span class="line">&gt;&gt;&gt; sig = signature(func)</span><br><span class="line">&gt;&gt;&gt; my_tag = &#123;<span class="string">"a"</span>:10, <span class="string">"b"</span>:20&#125;</span><br><span class="line">&gt;&gt;&gt; bound_args = sig.bind(**my_tag)</span><br><span class="line">&gt;&gt;&gt; bound_args</span><br><span class="line">&lt;BoundArguments (a=10, b=20)&gt;</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">for</span> name, value <span class="keyword">in</span> bound_args.arguments.items():</span><br><span class="line">...    <span class="built_in">print</span>(name, <span class="string">"="</span>, value)</span><br><span class="line">a = 10</span><br><span class="line">b = 20</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; del my_tag[<span class="string">"a"</span>]</span><br><span class="line">&gt;&gt;&gt; bound_args = sig.bind(**my_tag)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">TypeError: missing a required argument: <span class="string">'a'</span></span><br></pre></td></tr></table></figure>
<h3 id="函数注解">3.2.4 函数注解</h3>
<p>Python3提供了一种句法，用于为函数声明中的参数和返回值附加元数据。如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 未加注解</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a, b=<span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"><span class="comment"># 添加注解</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a: int, b: <span class="string">'int &gt; 0'</span> = <span class="number">10</span>)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure>
<p>各个参数可以在冒号后面增加<strong>注解表达式</strong>，如果有默认值，注解放在冒号和等号之间。上述<code>-&gt; int</code>是对返回值添加注解的形式。</p>
<p>这些注解都存放在函数的<code>__annotations__</code>属性中，它是一个字典：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(func.__annotations__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="comment"># 'return'表示返回值</span></span><br><span class="line">&#123;<span class="string">'a'</span>: &lt;class <span class="string">'int'</span>&gt;, <span class="string">'b'</span>: <span class="string">'int &gt; 0'</span>, <span class="string">'return'</span>: &lt;class <span class="string">'int'</span>&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>Python只是将注解存储在函数的<code>__annotations__</code>属性中，除此之外，再无任何操作。换句话说，这些注解对Python解释器来说没有意义。而这些注解的真正用途是提供给IDE、框架和装饰器等工具使用，比如Mypy静态类型检测工具，它就会根据你写的这些注解来检测传入的参数的类型是否符合要求。</p>
<p><code>inspect</code>模块可以获取这些注解。<code>inspect.Signature</code>有个一个<code>return_annotation</code>属性，它保存返回值的注解；<code>inspect.Parameter</code>对象中的<code>annotation</code>属性保存了参数的注解。</p>
<p>函数内省的内容到此结束。后面将介绍标准库中为函数式编程提供支持的常用包。</p>
<h1 id="函数式编程">4. 函数式编程</h1>
<p>Python并不是一个函数式编程语言，但通过operator和functools等包的支持，也可以写出函数式风格的代码。</p>
<h2 id="operator模块">4.1 operator模块</h2>
<p>在函数式编程中，经常需要把算术运算符当做函数使用，比如非递归求阶乘，实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> a, b: a * b, range(<span class="number">1</span>, n + <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p><strong>operator模块为多个算术运算符提供了对应的函数</strong>。使用<strong>算术运算符函数</strong>可将上述代码改写如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> mul</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> reduce(mul, range(<span class="number">1</span>, n + <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>operator模块中还有一类函数，能替代从序列中取出元素或读取对象属性的<code>lambda</code>表达式：<code>itemgetter</code>和<code>attrgetter</code>。这两个函数其实会自行构建函数。</p>
<h3 id="itemgetter">4.1.1 itemgetter()</h3>
<p>以下代码展示了<code>itemgetter</code>的常见用途：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"></span><br><span class="line">test_data = [</span><br><span class="line">    (<span class="string">"A"</span>, <span class="number">1</span>, <span class="string">"Alpha"</span>),</span><br><span class="line">    (<span class="string">"B"</span>, <span class="number">3</span>, <span class="string">"Beta"</span>),</span><br><span class="line">    (<span class="string">"C"</span>, <span class="number">2</span>, <span class="string">"Coco"</span>),</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 相当于 lambda fields: fields[1]</span></span><br><span class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> sorted(test_data, key=itemgetter(<span class="number">1</span>)):</span><br><span class="line">    print(temp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 传入多个参数时，它构建的函数返回下标对应的值构成的元组</span></span><br><span class="line">part_tuple = itemgetter(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> test_data:</span><br><span class="line">    print(part_tuple(temp))</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">(<span class="string">'A'</span>, <span class="number">1</span>, <span class="string">'Alpha'</span>)</span><br><span class="line">(<span class="string">'C'</span>, <span class="number">2</span>, <span class="string">'Coco'</span>)</span><br><span class="line">(<span class="string">'B'</span>, <span class="number">3</span>, <span class="string">'Beta'</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="string">'A'</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="string">'B'</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="string">'C'</span>)</span><br></pre></td></tr></table></figure>
<p><code>itemgetter</code>内部使用<code>[]</code>运算符，因此它不仅支持序列，还支持映射和任何实现了<code>__getitem__</code>方法的类。</p>
<h3 id="attrgetter">4.1.2 attrgetter()</h3>
<p><code>attrgetter</code>和<code>itemgetter</code>作用类似，它创建的函数根据名称提取对象的属性。如果传入多个属性名，它也会返回属性名对应的值构成的元组。这里要展示的是，如果参数名中包含句点<code>.</code>，<code>attrgetter</code>会深入嵌套对象，获取指定的属性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> attrgetter</span><br><span class="line"></span><br><span class="line">metro_data = [</span><br><span class="line">    (<span class="string">"Tokyo"</span>, <span class="string">"JP"</span>, <span class="number">36.933</span>, (<span class="number">35.689722</span>, <span class="number">139.691667</span>)),</span><br><span class="line">    (<span class="string">"Delhi NCR"</span>, <span class="string">"IN"</span>, <span class="number">21.935</span>, (<span class="number">28.613889</span>, <span class="number">77.208889</span>)),</span><br><span class="line">    (<span class="string">"Mexico City"</span>, <span class="string">"MX"</span>, <span class="number">20.142</span>, (<span class="number">19.433333</span>, <span class="number">-99.133333</span>)),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">LatLong = namedtuple(<span class="string">"LatLong"</span>, <span class="string">"lat long"</span>)</span><br><span class="line">Metropolis = namedtuple(<span class="string">"Metropolis"</span>, <span class="string">"name, cc, pop, coord"</span>)</span><br><span class="line">metro_areas = [Metropolis(name, cc, pop, LatLong(lat, long)) <span class="keyword">for</span></span><br><span class="line">               name, cc, pop, (lat, long) <span class="keyword">in</span> metro_data]</span><br><span class="line"><span class="comment"># 返回新的元组，获取name属性和嵌套的coord.lat属性</span></span><br><span class="line">name_lat = attrgetter(<span class="string">"name"</span>, <span class="string">"coord.lat"</span>)   </span><br><span class="line"><span class="keyword">for</span> city <span class="keyword">in</span> sorted(metro_areas, key=attrgetter(<span class="string">"coord.lat"</span>)): <span class="comment"># 嵌套</span></span><br><span class="line">    print(name_lat(city))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">(<span class="string">'Mexico City'</span>, <span class="number">19.433333</span>)</span><br><span class="line">(<span class="string">'Delhi NCR'</span>, <span class="number">28.613889</span>)</span><br><span class="line">(<span class="string">'Tokyo'</span>, <span class="number">35.689722</span>)</span><br></pre></td></tr></table></figure>
<h3 id="methodcaller">4.1.3 methodcaller()</h3>
<p>从名字也可看出，它创建的函数会在对象上调用参数指定的<strong>方法</strong>（注意是方法，而不是函数）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from operator import methodcaller</span><br><span class="line">&gt;&gt;&gt; s = <span class="string">"The time has come"</span></span><br><span class="line">&gt;&gt;&gt; upcase = methodcaller(<span class="string">"upper"</span>)</span><br><span class="line">&gt;&gt;&gt; upcase(s)  <span class="comment"># 相当于s.upper()</span></span><br><span class="line"><span class="string">'THE TIME HAS COME'</span></span><br><span class="line">&gt;&gt;&gt; hiphenate = methodcaller(<span class="string">"replace"</span>,<span class="string">" "</span>,<span class="string">"-"</span>)</span><br><span class="line">&gt;&gt;&gt; hiphenate(s)  <span class="comment"># 相当于s.replace(" ", "-")</span></span><br><span class="line"><span class="string">'The-time-has-come'</span></span><br></pre></td></tr></table></figure>
<p>从<code>hiphenate</code>这个例子可以看出，<code>methodcaller</code>还可以冻结某些参数，即部分应用（partial application），这与<code>functools.partial</code>函数的作用类似。</p>
<h2 id="使用functools.partial冻结参数">4.2 使用functools.partial冻结参数</h2>
<p>functool模块提供了一系列高阶函数，<code>reduce</code>函数相信大家已经很熟悉了，本节主要介绍其中两个很有用的函数<code>partial</code>和它的变体<code>partialmethod</code>。</p>
<p><code>functools.partial</code>用到了一个“闭包”的概念，这个概念的详细内容下一篇再介绍。使用这个函数可以把接收一个或多个参数的函数改编成需要回调的API，这样参数更少。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from operator import mul</span><br><span class="line">&gt;&gt;&gt; from functools import partial</span><br><span class="line">&gt;&gt;&gt; triple = partial(mul, 3)</span><br><span class="line">&gt;&gt;&gt; triple(7)</span><br><span class="line">21</span><br><span class="line">&gt;&gt;&gt; list(map(triple, range(1,10))) <span class="comment"># 这里无法直接使用mul函数</span></span><br><span class="line">[3, 6, 9, 12, 15, 18, 21, 24, 27]</span><br><span class="line">&gt;&gt;&gt; triple.func  <span class="comment"># 访问原函数</span></span><br><span class="line">&lt;built-in <span class="keyword">function</span> mul&gt;</span><br><span class="line">&gt;&gt;&gt; triple.args <span class="comment"># 访问固定参数</span></span><br><span class="line">(3,)</span><br><span class="line">&gt;&gt;&gt; triple.keywords  <span class="comment"># 访问关键字参数</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p><code>functools.partialmethod</code>函数的作用于<code>partial</code>一样，只不过<code>partialmethod</code>用于方法，<code>partial</code>用于函数。</p>
<p><em>补充</em>：<strong>回调函数</strong>(callback function)可以简单理解为，当一个函数X被传递给函数A时，函数X就被称为回调函数，函数A调用函数X的过程叫做<strong>回调</strong>。</p>
<h1 id="总结">5. 总结</h1>
<p>本篇首先介绍了函数，包括函数与对象的关系，高阶函数和匿名函数，重点是<strong>函数就是对象</strong>；随后介绍了函数和可调用对象的关系，以及函数的内省；最后，我们介绍了关于函数式编程的概念以及与之相关的两个重要模块。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python进阶</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python进阶</tag>
        <tag>Python函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路23-文本和字节序列</title>
    <url>/2018/05/20/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF23-%E6%96%87%E6%9C%AC%E5%92%8C%E5%AD%97%E8%8A%82%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<blockquote>
<p>《流畅的Python》笔记。</p>
<p>本篇主要讲述不同编码之间的转换问题，比较繁杂，如果平时处理文本不多，或者语言比较单一，没有多语言文本处理的需求，则可以略过此篇。</p>
</blockquote>
<a id="more"></a>
<h1 id="前言">1. 前言</h1>
<p>本篇主要讲述Python对文本字符串的处理。主要内容如下：</p>
<ul>
<li>字符集基本概念以及Unicode；</li>
<li>Python中的字节序列；</li>
<li>Python对编码错误的处理以及BOM；</li>
<li>Python对文本文件的编解码，以及对Unicode字符的比较和排序，而这便是<strong>本篇的主要目的</strong>；</li>
<li>双模式API和Unicode数据库</li>
</ul>
<p><strong>如果对字符编码很熟悉，也可直接跳过第2节。</strong></p>
<h1 id="字符集相关概念">2. 字符集相关概念</h1>
<p>笔者在初学字符集相关内容的时候，对这个概念并没有什么疑惑：字符集嘛，就是把我们日常使用的字符（汉子，英文，符号，甚至表情等）转换成为二进制嘛，和摩斯电码本质上没啥区别，用数学的观点就是一个函数变换，这有什么好疑惑的？直到后来越来也多地接触字符编码，终于，笔者被这堆概念搞蒙了：一会儿Unicode编码，一会儿又Unicode字符集，UTF-8编码，UTF-16字符集还有什么字符编码、字节序列。到底啥时候该叫“编码”，啥时候该叫“字符集”？这些概念咋这么相似呢？既然这么相似，干嘛取这么多名字？后来仔细研究后发现，确实很多学术名次都是同义词，比如“字符集”和“字符编码”其实就是同义词；有的译者又在翻译外国的书的时候，无意识地把一个概念给放大或者给缩小了。</p>
<p>说到这不得不吐槽一句，我们国家互联网相关的图书质量真的低。国人自己写的IT方面的书，都不求有多经典，能称为好书的都少之又少；而翻译的书，要么翻译得晦涩难懂，还不如直接看原文；要么故作风骚，非得体现译者的文学修养有多“高”；要么生造名词，同一概念同一单词，这本书里你翻译成这样，另一本书里我就偏要翻译成那样（你们这是在翻译小说吗）。所以劝大家有能力的话还是直接看原文吧，如果要买译本，还请大家认真比较比较，否则读起来真的很痛苦。</p>
<p>回到主题，我们继续讨论字符集相关问题。翻阅网上大量资料，做出如下总结。</p>
<h2 id="基本概念">2.1 基本概念</h2>
<p>始终记住编码的核心思想：就是<strong>给每个字符都对应一个二进制序列</strong>，其他的所有工作都是让这个过程更规范，更易于管理。</p>
<p>现代编码模型将这个过程分了5个层次，所用的术语列举如下（为了避免混淆，这里不再列出它们的同义词）：</p>
<ol type="1">
<li><p><strong>抽象字符表</strong>（Abstract character repertoire）：</p>
<p><strong>系统支持的所有抽象字符的集合。可以简单理解为人们使用的文字、符号等。</strong></p>
<p>这里需要注意一个问题：有些语系里面的字母上方或者下方是带有特殊符号的，比如一点或者一撇；有的字符表里面会将字母和特殊符号组合成一个新的字符，为它单独编码；有的则不会单独编码，而是字母赋予一个编码，特殊符号赋予一个编码，然后当这俩在文中相遇的时候再将这俩的编码组合起来形成一个字符。后面我们会谈到这个问题，这也是以前字符编码转换常出毛病的一个原因。</p>
<p><strong>提醒</strong>：虽然这里扯到了编码，但<strong>抽象字符表</strong>这个概念还和编码没有联系。</p></li>
<li><p><strong>编码字符集</strong>（Coded Character Set，<strong>CCS</strong>）：字符 --&gt; 码位</p>
<p>首先给出总结：<strong>编码字符集就是用数字代替抽象字符集中的每一个字符！</strong></p>
<p>将抽象字符表中的每一个字符映射到一个坐标（整数值对：(x, y)，比如我国的GBK编码）或者表示为一个非负整数N，便生成了编码字符集。与之相应的还有两个<strong>抽象</strong>概念：<strong>编码空间</strong>(encoding space)、<strong>码位</strong>(code point)和<strong>码位值</strong>(code point value)。</p>
<p>简单的理解，编码空间就相当于许多空位的集合，这些空位称之为码位，而这个码位的坐标通常就是码位值。我们将抽象字符集中的字符与码位一一对应，然后用码位值来代表字符。以二维空间为例，相当于我们有一个10万行的表，每一行相当于一个码位，二维的情况下，通常行号就是码位值（当然你也可以设置为其他值），然后我们把每个汉字放到这个表中，最后用行号来表示每一个汉字。<strong>一个编码字符集就是把抽象字符映射为码位值。</strong>这里区分码位和码位值只是让这个映射的过程更形象，两者类似于座位和座位号的区别，但真到用时，并不区分这两者，以下两种说法是等效的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">字符A的码位是123456</span><br><span class="line">字符A的码位值是123456（很少这么说，但有这种说法）</span><br></pre></td></tr></table></figure>
<p>编码空间并不只能是二维的，它也可以是三维的，甚至更高，比如当你以二维坐标(x, y)来编号字符，并且还对抽象字符集进行了分类，那么此时的编码空间就<strong>可能</strong>是三维的，z坐标表示分类，最终使用(x, y, z)在这个编码空间中来定位字符。不过笔者还没真见过（或者见过但不知道......）三维甚至更高维的编码，最多也就见过变相的三维编码空间。但编码都是人定的，你也可以自己定一个编码规则~~</p>
<p>并不是每一个码位都会被使用，比如我们的汉字有8万多个，用10万个数字来编号的话还会剩余1万多个，这些剩余的码位则留作扩展用。</p>
<p><strong>注意</strong>：到这一步我们只是将抽象字符集进行了编号，但这个编号并不一定是二进制的，而且它一般也不是二进制的，而是10进制或16进制。该层依然是个抽象层。</p>
<p>而这里之所以说了这么多，就是为了和下面这个概念区分。</p></li>
<li><p><strong>字符编码表</strong>（Character Encoding Form，<strong>CEF</strong>）：码位 --&gt; 码元</p>
<p>将编码字符集中的码位转换成有限比特长度的整型值的序列。这个整型值的单位叫<strong>码元</strong>(code unit)。即一个码位可由一个或多个码元表示。而这个整型值通常就是码位的二进制表示。</p>
<p>到这里才完成了字符到二进制的转换。程序员的工作通常到这里就完成了。但其实还有后续两步。</p>
<p><strong>注意</strong>：直到这里都还没有将这些序列存到存储器中！所以这里依然是个抽象，只是相比上面两步更具体而已。</p></li>
<li><p><strong>字符编码方案</strong>（Character Encoding Scheme，CES）：码元 --&gt; 序列化</p>
<p>也称为“serialization format”(常说的“序列化”)。将上面的整型值转换成可存储或可传输8位字节序列。简单说就是将上面的码元一个字节一个字节的存储或传输。每个字节里的二进制数就是字节序列。这个过程中还会涉及大小端模式的问题（码元的低位字节里的内容放在内存地址的高位还是低位的问题，感兴趣的请自行查阅，这里不再赘述）。</p>
<p>直到这时，才真正完成了从我们使用的字符转换到机器使用的二进制码的过程。 抽象终于完成了实例化。</p></li>
<li><p><strong>传输编码语法</strong>（transfer encoding syntax）：</p>
<p>这里则主要涉及传输的问题，如果用计算机网络的概念来类比的话，就是如何实现透明传输。相当于将上面的字节序列的值映射到一个更受限的值域内，以满足传输环境的限制。比如Email的Base64或quoted-printable协议，Base64是6bit作为一个单位，quoted-printable是7bit作为一个单位，所以我们得想办法把8bit的字节序列映射到6bit或7bit的单位中。另一个情况则是压缩字节序列的值，如LZW或进程长度编码等无损压缩技术。</p></li>
</ol>
<p>综上，整个编码过程概括如下：</p>
<p><strong>字符 --&gt; 码位 --&gt; 码元 --&gt; 序列化</strong>，如果还要在特定环境传输，还需要再映射。从左到右是编码的过程，从右到左就是解码的过程。</p>
<p>下面我们以Unicode为例，来更具体的说明上述概念。</p>
<h2 id="统一字符编码unicode">2.2 统一字符编码Unicode</h2>
<p>每个国家每个地区都有自己的字符编码标准，如果你开发的程序是面向全球的，则不得不在这些标准之间转换，而许多问题就出在这些转换上。Unicode的初衷就是为了避免这种转换，而对全球各种语言进行统一编码。既然都在同一个标准下进行编码，那就不存在转换的问题了呗。但这只是理想，至今都没编完，所以还是有转换的问题，但已经极大的解决了以前的编码转换的问题了。</p>
<p><strong>Unicode编码就是上面的编码字符集CCS。而与它相伴的则是经常用到的UTF-8，UTF-16等，这些则是上面的字符编码表CEF。</strong></p>
<p>最新版的Unicode库已经收录了超过10万个字符，它的码位一般用16进制表示，并且前面还要加上<code>U+</code>，十进制表示的话则是前面加<code>&amp;#</code>，例如字母“A”的Unicode码位是<code>U+0041</code>，十进制表示为<code>&amp;#065</code>。</p>
<p>Unicode目前一共有17个Plane（面），从<code>U+0000</code>到<code>U+10FFFF</code>，每个Plane包含65536(=2<sup>16</sup>)个码位，比如英文字符集就在0号平面中，它的范围是<code>U+0000</code> ~ <code>U+FFFF</code>。这17个Plane中4号到13号都还未使用，而15、16号Plane保留为私人使用区，而使用的5个Plane也并没有全都用完，所以Unicode还没有很大的未编码空间，相当长的时间内够用了。</p>
<p><strong>注意</strong>：自2003年起，Unicode的编码空间被规范为了21bit，但Unicode编码并没有占多少位之说，而真正涉及到在存储器中占多少位时，便到了字符编码阶段，即UTF-8，UTF-16，UTF-32等，这些字符编码表在编程中也叫做<strong>编解码器</strong>。</p>
<p>UTF-n表示用n位作为码元来编码Unicode的码位。以UTF-8为例，它的码元是1字节，且最多用4个码元为Unicode的码位进行编码，编码规则如下表所示：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828510/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF23-%E6%96%87%E6%9C%AC%E5%92%8C%E5%AD%97%E8%8A%82%E5%BA%8F%E5%88%97/1526229467211.png" /></p>
<p>表中的<code>×</code>用Unicode的16进制码位的2进制序列从右向左依次替换，比如<code>U+07FF</code>的二进制序列为 ：<code>00000,11111,111111</code>(这里的逗号位置只是为了和后面作比较，并不是正确的位置)；</p>
<p>那么<code>U+07FF</code>经UTF-8编码后的比特序列则为<code>110 11111,10 111111</code>，暂时将这个序列命名为<code>a</code>。</p>
<p>至此已经完成了前3步工作，现在开始执行序列化：如果CPU是大端模式，那么序列<code>a</code>就是<code>U+07FF</code>在机器中的字节序列，但如果是小端模式，序列<code>a</code>的这两个字节需要调换位置，变为<code>10 111111,110 11111</code>，这才是实际的字节序列。</p>
<h1 id="python中的字节序列">3. Python中的字节序列</h1>
<p>Python3明确区分了人类可读的字符串和原始的字节序列。Python3中，文本总是Unicode，由<code>str</code>类型表示，二进制数据由<code>bytes</code>类型表示，并且Python3不会以任何隐式的方式混用<code>str</code>和<code>bytes</code>。Python3中的<code>str</code>类型基本相当于Python2中的<code>unicode</code>类型。</p>
<p>Python3内置了两种基本的二进制<strong>序列</strong>类型：不可变<code>bytes</code>类型和可变<code>bytearray</code>类型。这两个对象的每个元素都是介于0-255之间的整数，而且它们的切片始终是同一类型的二进制序列（而不是单个元素）。</p>
<p>以下是关于字节序列的一些基本操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="string">"China"</span>.encode(<span class="string">"utf8"</span>)  <span class="comment"># 也可以 temp = bytes("China", encoding="utf_8")</span></span><br><span class="line">b<span class="string">'China'</span></span><br><span class="line">&gt;&gt;&gt; a = <span class="string">"中国"</span></span><br><span class="line">&gt;&gt;&gt; utf = a.encode(<span class="string">"utf8"</span>)</span><br><span class="line">&gt;&gt;&gt; utf</span><br><span class="line">b<span class="string">'\xe4\xb8\xad\xe5\x9b\xbd'</span></span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line"><span class="string">'中国'</span></span><br><span class="line">&gt;&gt;&gt; len(a)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; len(utf)</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; utf[0]</span><br><span class="line">228</span><br><span class="line">&gt;&gt;&gt; utf[:1]</span><br><span class="line">b<span class="string">'\xe4'</span></span><br><span class="line">&gt;&gt;&gt; b = bytearray(<span class="string">"China"</span>, encoding=<span class="string">"utf8"</span>)   <span class="comment"># 也可以b = bytearray(utf)</span></span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">bytearray(b<span class="string">'China'</span>)</span><br><span class="line">&gt;&gt;&gt; b[-1:]</span><br><span class="line">bytearray(b<span class="string">'a'</span>)</span><br></pre></td></tr></table></figure>
<p>二进制序列实际是整数序列，但在输出时为了方便阅读，将其进行了转换，以<code>b</code>开头，其余部分：</p>
<ul>
<li>可打印的ASCII范围内的字节，使用ASCII字符本身；</li>
<li>制表符、换行符、回车符和<code>\</code>对应的字节，使用转义序列<code>\t</code>，<code>\n</code>，<code>\r</code>和<code>\\</code>；</li>
<li>其他字节的值，使用十六进制转义序列，以<code>\x</code>开头。</li>
</ul>
<p><code>bytes</code>和<code>bytesarray</code>的构造方法如下：</p>
<ul>
<li>一个<code>str</code>对象和一个<code>encoding</code>关键字参数；</li>
<li>一个可迭代对象，值的范围是<code>range(256)</code>；</li>
<li>一个实现了缓冲协议的对象（如<code>bytes</code>，<code>bytearray</code>，<code>memoryview</code>，<code>array.array</code>），此时它将源对象中的字节序列复制到新建的二进制序列中。并且，这是一种底层操作，可能涉及类型转换。</li>
</ul>
<p>除了格式化方法（<code>format</code>和<code>format_map</code>）和几个处理Unicode数据的方法外，<code>bytes</code>和<code>bytearray</code>都支持<code>str</code>的其他方法，例如<code>bytes. endswith</code>，<code>bytes.replace</code>等。同时，re模块中的正则表达式函数也能处理二进制序列（当正则表达式编译自二进制序列时会用到）。</p>
<p>二进制序列有个<code>str</code>没有的方法<code>fromhex</code>，它解析十六进制数字对，构件二进制序列：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; bytes.fromhex(<span class="string">"31 4b ce a9"</span>)</span><br><span class="line">b<span class="string">'1K\xce\xa9'</span></span><br></pre></td></tr></table></figure>
<p><strong><em>补充</em></strong>：struct模块提供了一些函数，这些函数能把打包的字节序列转换成<strong>不同类型字段</strong>组成的元组，或者相反，把元组转换成打包的字节序列。struct模块能处理<code>bytes</code>、<code>bytearray</code>和<code>memoryview</code>对象。这个不是本篇重点，不再赘述。</p>
<h1 id="编解码器问题">4. 编解码器问题</h1>
<p>如第2节所述，我们常说的UTF-8，UTF-16实际上是字符编码表，在编程中一般被称为编解码器。本节主要讲述关于编解码器的错误处理：<code>UnicodeEncodeError</code>，<code>UnicodeDecodeError</code>和<code>SyntaxError</code>。</p>
<p>Python中一般会明确的给出某种错误，而不会笼统地抛出<code>UnicodeError</code>，所以，在我们自行编写处理异常的代码时，也最好明确错误类型。</p>
<h2 id="unicodeencodeerror">4.1 UnicodeEncodeError</h2>
<p>当从<strong>文本转换成字节序列</strong>时，如果编解码器没有定义某个字符，则有可能抛出<code>UnicodeEncodeError</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; country = <span class="string">"中国"</span></span><br><span class="line">&gt;&gt;&gt; country.encode(<span class="string">"utf8"</span>)</span><br><span class="line">b<span class="string">'\xe4\xb8\xad\xe5\x9b\xbd'</span></span><br><span class="line">&gt;&gt;&gt; country.encode(<span class="string">"utf16"</span>)</span><br><span class="line">b<span class="string">'\xff\xfe-N\xfdV'</span></span><br><span class="line">&gt;&gt;&gt; country.encode(<span class="string">"cp437"</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;input&gt;"</span>, line 1, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"E:\Code\Python\Study\venv\lib\encodings\cp437.py"</span>, line 12, <span class="keyword">in</span> encode</span><br><span class="line">    <span class="built_in">return</span> codecs.charmap_encode(input,errors,encoding_map)</span><br><span class="line">UnicodeEncodeError: <span class="string">'charmap'</span> codec can<span class="string">'t encode characters in position 0-1: character </span></span><br><span class="line"><span class="string">maps to &lt;undefined&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以指定错误处理方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; country.encode(<span class="string">"cp437"</span>, errors=<span class="string">"ignore"</span>)  <span class="comment"># 跳过无法编码的字符，不推荐</span></span><br><span class="line">b<span class="string">''</span></span><br><span class="line">&gt;&gt;&gt; country.encode(<span class="string">"cp437"</span>, errors=<span class="string">"replace"</span>) <span class="comment"># 把无法编码的字符替换成“?”</span></span><br><span class="line">b<span class="string">'??'</span></span><br><span class="line">&gt;&gt;&gt; country.encode(<span class="string">"cp437"</span>, errors=<span class="string">"xmlcharrefreplace"</span>) <span class="comment"># 把无法编码的字符替换成XML实体</span></span><br><span class="line">b<span class="string">'&amp;#20013;&amp;#22269;'</span></span><br></pre></td></tr></table></figure>
<h2 id="unicodedecodeerror">4.2 UnicodeDecodeError</h2>
<p>相应的，当从<strong>字节序列转换成文本</strong>时，则有可能发生<code>UnicodeDecodeError</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; octets.decode(<span class="string">"cp1252"</span>)</span><br><span class="line"><span class="string">'Montréal'</span></span><br><span class="line">&gt;&gt;&gt; octets.decode(<span class="string">"iso8859_7"</span>)</span><br><span class="line"><span class="string">'Montrιal'</span></span><br><span class="line">&gt;&gt;&gt; octets.decode(<span class="string">"utf_8"</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;input&gt;"</span>, line 1, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">UnicodeDecodeError: <span class="string">'utf-8'</span> codec can<span class="string">'t decode byte 0xe9 in position 5: </span></span><br><span class="line"><span class="string">invalid continuation byte</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 解码错误的处理与4.1类似</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; octets.decode("utf8", errors="replace")</span></span><br><span class="line"><span class="string"># "�"字符是官方指定的替换字符（REPLACEMENT CHARACTER），表示未知字符，码位U+FFFD</span></span><br><span class="line"><span class="string">'</span>Montr�al<span class="string">'</span></span><br></pre></td></tr></table></figure>
<h2 id="syntaxerror">4.3 SyntaxError</h2>
<p>当加载Python模块时，如果源码的编码与文件解码器不符时，则会出现<code>SyntaxError</code>。比如Python3默认UTF-8编码源码，如果你的Python源码编码时使用的是其他编码，而代码中又没有声明编解码器，那么Python解释器可能就会发出<code>SyntaxError</code>。为了修正这个问题，可在<strong>文件开头</strong>指明编码类型，比如表明编码为UTF-8，则应在源文件<strong>顶部</strong>写下此行代码：<code>#-*- coding: utf8 -*- ”</code>（没有引号！）</p>
<p><strong><em>补充</em></strong>：Python3允许在源码中使用非ASCII标识符，也就是说，你可以用中文来命名变量（笑。。。）。如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>甲=<span class="string">"abc"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>甲</span><br><span class="line"><span class="string">'abc'</span></span><br></pre></td></tr></table></figure>
<p>但是<strong>极不推荐</strong>！还是老老实实用英文吧，哪怕拼音也行。</p>
<h2 id="找出字节序列的编码">4.4 找出字节序列的编码</h2>
<p>有时候一个文件并没有指明编码，此时该如何确定它的编码呢？实际并没有100%确定编码类型的方法，一般都是靠试探和分析找出编码。比如，如果<code>b"\x00"</code>字节经常出现，就很有可能是16位或32位编码，而不是8位编码。Chardet就是这样工作的。它是一个Python库，能识别所支持的30种编码。以下是它的用法，这是在终端命令行中，不是在Python命令行中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ chardetect 04-text-byte.asciidoc</span><br><span class="line">04-text-byte.asciidoc: utf-8 with confidence 0.99</span><br></pre></td></tr></table></figure>
<h2 id="字节序标记bombyte-order-mark">4.5 字节序标记BOM(byte-order mark)</h2>
<p>当使用UTF-16编码时，字节序列前方会有几个额外的字节，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="string">'El Niño'</span>.encode(<span class="string">"utf16"</span>)</span><br><span class="line">b<span class="string">'\xff\xfeE\x00l\x00 \x00N\x00i\x00\xf1\x00o\x00'</span>   <span class="comment"># 注意前两个字节b"\xff\xfe"</span></span><br></pre></td></tr></table></figure>
<p>BOM用于指明编码时使用的是大端模式还是小端模式，上述例子是小端模式。UTF-16在要编码的文本前面加上特殊的不可见字符<code>ZERO WIDTH NO-BREAK SPACE</code>(<code>U+FEFF</code>)。UTF-16有两个变种：UTF-16LE，显示指明使用小端模式；UTF-16BE，显示指明大端模式。如果显示指明了模式，则不会生成BOM：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="string">'El Niño'</span>.encode(<span class="string">"utf_16le"</span>)</span><br><span class="line">b<span class="string">'E\x00l\x00 \x00N\x00i\x00\xf1\x00o\x00'</span></span><br><span class="line">&gt;&gt;&gt; <span class="string">'El Niño'</span>.encode(<span class="string">"utf_16be"</span>)</span><br><span class="line">b<span class="string">'\x00E\x00l\x00 \x00N\x00i\x00\xf1\x00o'</span></span><br></pre></td></tr></table></figure>
<p>根据标准，如果文件使用UTF-16编码，且没有BOM，则应假定它使用的是UTF-16大端模式编码。然而Intel x86架构用的是小端模式，因此很多文件用的是不带BOM的小端模式UTF-16编码。这就容易造成混淆，如果把这些文件直接用在采用大端模式的机器上，则会出问题（比较老的AMD也有大端模式，现在的AMD也是x86架构了）。</p>
<p>由于大小端模式(字节顺序)只对一个字(word)占多个字节的编码有影响，所以对于UTF-8来说，不管设备使用哪种模式，生成的字节序列始终一致，因此不需要BOM。但在Windows下就比较扯淡了，有些应用依然会添加BOM，并且会根据有无BOM来判断是不是UTF-8编码。</p>
<p><strong><em>补充</em></strong>：笔者查资料时发现有“显示指明BOM”一说，刚看到的时候笔者以为是在函数中传递一个<code>bom</code>关键字参数来指明BOM，然而不是，而是传入一个带有BOM标识的编解码器，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认UTF-8不带BOM，如果想让字节序列带上BOM，则应传入utf_8_sig</span></span><br><span class="line">&gt;&gt;&gt; <span class="string">'El Niño'</span>.encode(<span class="string">"utf_8_sig"</span>) </span><br><span class="line">b<span class="string">'\xef\xbb\xbfEl Ni\xc3\xb1o'</span></span><br><span class="line">&gt;&gt;&gt; <span class="string">'El Niño'</span>.encode(<span class="string">"utf_8"</span>)</span><br><span class="line">b<span class="string">'El Ni\xc3\xb1o'</span></span><br></pre></td></tr></table></figure>
<h1 id="处理文本文件">5. 处理文本文件</h1>
<p>处理文本的最佳实践是"Unicode三明治"模型。图示如下：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828510/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF23-%E6%96%87%E6%9C%AC%E5%92%8C%E5%AD%97%E8%8A%82%E5%BA%8F%E5%88%97/1526716350709.png" /></p>
<p>此模型的意思是：</p>
<ol type="1">
<li>对输入的字节序列应<strong>尽早解码</strong>为字符串；</li>
<li>第二层相当于程序的业务逻辑，这里应该<strong>保证只处理字符串</strong>，而不应该有编码或解码的操作存在；</li>
<li>对于输出，<strong>应尽晚地把字符串编码为字节序列</strong>。</li>
</ol>
<p>当我们用Python处理文本时，我们实际对这个模型并没有多少感觉，因为Python在读写文件时会为我们做必要的编解码工作，我们实际处理的是这个三明治的中间层。</p>
<h2 id="python编解码">5.1 Python编解码</h2>
<p>Python中调用<code>open</code>函数打开文件时，默认使用的是编解码器与平台有关，如果你的程序将来要跨平台，推荐的做法是<strong>明确传入<code>encoding</code>关键字参数</strong>。其实不管跨不跨平台，这都是推荐的做法。</p>
<p>对于<code>open</code>函数，当以二进制模式打开文件时，它返回一个<code>BufferedReader</code>对象；当以文本模式打开文件时，它返回的是一个<code>TextIOWrapper</code>对象：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; fp = open(<span class="string">"zen.txt"</span>, <span class="string">"r"</span>, encoding=<span class="string">"utf8"</span>)</span><br><span class="line">&gt;&gt;&gt; fp</span><br><span class="line">&lt;_io.TextIOWrapper name=<span class="string">'zen.txt'</span> mode=<span class="string">'r'</span> encoding=<span class="string">'utf8'</span>&gt;</span><br><span class="line">&gt;&gt;&gt; fp2 = open(<span class="string">"zen.txt"</span>, <span class="string">"rb"</span>)  <span class="comment"># 当以二进制读取文件时，不需要指定编解码器</span></span><br><span class="line">&gt;&gt;&gt; fp2</span><br><span class="line">&lt;_io.BufferedReader name=<span class="string">'zen.txt'</span>&gt;</span><br></pre></td></tr></table></figure>
<p><strong>这里有几个点</strong>：</p>
<ul>
<li>除非想判断编码方式，或者文件本身就是二进制文件，否则不要以二进制模式打开文本文件；就算想判断编码方式，也应该使用Chardet，而不是重复造轮子。</li>
<li>如果打开文件时未传入<code>encoding</code>参数，默认值将由<code>locale.getpreferredencoding()</code>提供，但从这么函数名可以看出，其实它返回的也不一定是系统的默认设置，而是用户的偏好设置。用户的偏好设置在不同系统中不一定相同，而且有的系统还没法设置偏好，所以，正如官方文档所说，该函数返回的是一个猜测的值；</li>
<li>如果设定了<code>PYTHONENCODING</code>环境变量，<code>sys.stdout/stdin/stderr</code>的编码则使用该值，否则继承自所在的控制台；如果输入输出重定向到文件，编码方式则由<code>locale.getpreferredencoding()</code>决定；</li>
<li>Python读取文件时，对文件名（不是文件内容！）的编解码器由<code>sys.getfilesystemencoding()</code>函数提供，当以字符串作为文件名传入<code>open</code>函数时就会调用它。但如果传入的文件名是字节序列，则会直接将此字节序列传给系统相应的API。</li>
</ul>
<p>总之：<strong>别依赖默认值</strong>！</p>
<p>如果遵循Unicode三明治模型，并且始终在程序中指定编码，那将避免很多问题。但Unicode也有不尽人意的地方，比如文本规范化（为了比较文本）和排序。如果你只在ASCII环境中，或者语言环境比较固定单一，那么这两个操作对你来说会很轻松，但如果你的程序面向多语言文本，那么这两个操作会很繁琐。</p>
<h2 id="规范化unicode字符串">5.2 规范化Unicode字符串</h2>
<p>由于Unicode有组合字符，所以字符串比较起来比较复杂。</p>
<p><em>补充：组合字符指变音符号和附加到前一个字符上的记号，打印时作为一个整体。</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; s1 = <span class="string">'café'</span></span><br><span class="line">&gt;&gt;&gt; s2 = <span class="string">'cafe\u0301'</span></span><br><span class="line">&gt;&gt;&gt; s1, s2</span><br><span class="line">(<span class="string">'café'</span>, <span class="string">'café'</span>)</span><br><span class="line">&gt;&gt;&gt; len(s1), len(s2)</span><br><span class="line">(4, 5)</span><br><span class="line">&gt;&gt;&gt; s1 == s2</span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<p>在Unicode标准中，<code>'é'</code>和<code>'e\u0301'</code>叫做<strong>标准等价物</strong>，应用程序应该将它们视为相同的字符，但从上面代码可以看出，Python并没有将它们视为等价物，这就给Python中比较两个字符串添加了麻烦。</p>
<p>解决的方法是使用<code>unicodedata.normalize</code>函数提供的Unicode规范化。它有四个标准：<code>NFC</code>，<code>NFD</code>，<code>NFKC</code>，<code>NFKD</code>。</p>
<h3 id="nfc和nfd">5.2.1 NFC和NFD</h3>
<p><code>NFC</code>使用最少的码位构成等价的字符串，<code>NFD</code>把组合字符分解成基字符和单独的组合字符。这两种规范化方法都能让比较行为符合预期：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from unicodedata import normalize</span><br><span class="line">&gt;&gt;&gt; len(normalize(<span class="string">"NFC"</span>, s1)), len(normalize(<span class="string">"NFC"</span>, s2))</span><br><span class="line">(4, 4)</span><br><span class="line">&gt;&gt;&gt; len(normalize(<span class="string">"NFD"</span>, s1)), len(normalize(<span class="string">"NFD"</span>, s2))</span><br><span class="line">(5, 5)</span><br><span class="line">&gt;&gt;&gt; normalize(<span class="string">"NFD"</span>, s1) == normalize(<span class="string">"NFD"</span>, s2)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; normalize(<span class="string">"NFC"</span>, s1) == normalize(<span class="string">"NFC"</span>, s2)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p><code>NFC</code>是W3C推荐的规范化形式。西方键盘通常能输出组合字符，因此用户输入的文本默认是<code>NFC</code>形式。我们对变音字符用的不多。但还是那句话，如果你的程序面向多语言文本，为了安全起见，最好还是用<code>normalize(”NFC“, user_text)</code><strong>清洗字符串</strong>。</p>
<p>使用<code>NFC</code>时，有些单字符会被规范成另一个单字符，例如电阻的单位欧姆（Ω，<code>U+2126</code>，<code>\u2126</code>）会被规范成希腊字母大写的欧米伽（<code>U+03A9</code>, <code>\u03a9</code>）。这俩看着一样，现实中电阻欧姆的符号也就是从希腊字母来的，两者应该相等，但在Unicode中是不等的，因此需要规范化，防止出现意外。</p>
<h3 id="nfkc和nfkd">5.2.2 NFKC和NFKD</h3>
<p><code>NFKC</code>和<code>NFKD</code>（K表示“compatibility”，兼容性）是比较严格的规范化形式，对“兼容字符”有影响。为了兼容现有的标准，Unicode中有些字符会出现多次。比如希腊字母<code>'μ'</code>（<code>U+03BC</code>），Unicode除了有它，还加入了微符号<code>'µ'</code>(<code>U+00B5</code>)，以便和latin1标准相互转换，所以微符号是个“兼容字符”（上述的欧姆符号不是兼容字符！）。这两个规范会将兼容字符分解为一个或多个字符，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from unicodedata import normalize, name</span><br><span class="line">&gt;&gt;&gt; half = <span class="string">'½'</span></span><br><span class="line">&gt;&gt;&gt; normalize(<span class="string">"NFKC"</span>, half)</span><br><span class="line"><span class="string">'1/2'</span></span><br><span class="line">&gt;&gt;&gt; four_squared = <span class="string">'4²'</span></span><br><span class="line">&gt;&gt;&gt; normalize(<span class="string">"NFKC"</span>, four_squared)</span><br><span class="line"><span class="string">'42'</span></span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看出，这两个标准可能会造成格式损失，甚至曲解信息，但可以为搜索和索引提供便利的中间表述。比如用户在搜索<code>1/2 inch</code>时，可能还会搜到包含<code>½ inch</code>的文章，这便增加了匹配选项。</p>
<h3 id="大小写折叠">5.2.3 大小写折叠</h3>
<p>对于搜索或索引，大小写是个很有用的操作。同时，对于Unicode来说，大小写折叠还是个复杂的问题。对于此问题，如果是初学者，首先想到的一定是<code>str.lower()</code>和<code>str.upper()</code>。但在处理多语言文本时，<code>str.casefold()</code>更常用，它将字符转换成小写。自Python3.4起，<code>str.casefold()</code>和<code>str.lower()</code>得到不同结果的有116个码位。对于只包含latin1字符的字符串<code>s</code>，<code>s.casefold()</code>得到的结果和<code>s.lower()</code>一样，但有两个例外：微符号<code>'µ'</code>会变为希腊字母<code>'μ'</code>；德语<code>Eszett</code>（“sharp s”，<code>ß</code>）为变成<code>'ss'</code>。</p>
<h3 id="规范化文本匹配使用函数">5.2.4 规范化文本匹配使用函数</h3>
<p>下面给出用以上内容编写的几个规范化匹配函数。<strong>对大多数应用来说，NFC是最好的规范形式</strong>。不区分大小写的比较应该使用<code>str.casefold()</code>。对于处理多语言文本，以下两个函数应该是必不可少的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 两个多语言文本中的比较函数</span></span><br><span class="line"><span class="keyword">from</span> unicodedata <span class="keyword">import</span> normalize</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nfc_equal</span><span class="params">(str1, str2)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> normalize(<span class="string">"NFC"</span>, str1) == normalize(<span class="string">"NFC"</span>, str2)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fold_equal</span><span class="params">(str1, str2)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> normalize(<span class="string">"NFC"</span>, str1).casefold() == normalize(<span class="string">"NFC"</span>, str2).casefold()</span><br></pre></td></tr></table></figure>
<p>有时我们还想把变音符号去掉（例如<code>“café”</code>变<code>“cafe”</code>），比如谷歌在搜索时就有可能去掉变音符号；或者想让URL更易读时，也需要去掉变音符号。如果想去掉文本中的全部变音符号，则可用如下函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 去掉多语言文本中的变音符号</span></span><br><span class="line"><span class="keyword">import</span> unicodedata</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shave_marks</span><span class="params">(txt)</span>:</span></span><br><span class="line">    <span class="string">"""去掉全部变音符号"""</span></span><br><span class="line">    <span class="comment"># 把所有字符分解成基字符和组合字符</span></span><br><span class="line">    norm_txt = unicodedata.normalize(<span class="string">"NFD"</span>, txt)</span><br><span class="line">    <span class="comment"># 过滤掉所有组合记号</span></span><br><span class="line">    shaved = <span class="string">""</span>.join(c <span class="keyword">for</span> c <span class="keyword">in</span> norm_txt <span class="keyword">if</span> <span class="keyword">not</span> unicodedata.combining(c))</span><br><span class="line">    <span class="comment"># 重组所有字符</span></span><br><span class="line">    <span class="keyword">return</span> unicodedata.normalize(<span class="string">"NFC"</span>, shaved)</span><br><span class="line"></span><br><span class="line">order = <span class="string">'“Herr Voß: • ½ cup of Œtker™ caffè latte • bowl of açaí.”'</span></span><br><span class="line">print(shave_marks(order))</span><br><span class="line">greek = <span class="string">'Ζέφυρος, Zéfiro'</span></span><br><span class="line">print(shave_marks(greek))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">“Herr Voß: • ½ cup of Œtker™ caffe latte • bowl of acai.”</span><br><span class="line">Ζεφυρος, Zefiro</span><br></pre></td></tr></table></figure>
<p>上述代码去掉了所有的变音字符，包括非拉丁字符，但有时我们想只去掉拉丁字符中的变音字符，为此，我们还需要对基字符进行判断，以下这个版本只去掉拉丁字符中的变音字符：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 仅去掉拉丁文中的变音符号</span></span><br><span class="line"><span class="keyword">import</span> unicodedata</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shave_marks_latin</span><span class="params">(txt)</span>:</span></span><br><span class="line">    <span class="string">"""去掉拉丁基字符中的所有变音符号"""</span></span><br><span class="line">    norm_txt = unicodedata.normalize(<span class="string">"NFD"</span>, txt)</span><br><span class="line">    latin_base = unicodedata.combining(norm_txt[<span class="number">0</span>])  <span class="comment"># &lt;1&gt;</span></span><br><span class="line">    keepers = []</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> norm_txt:</span><br><span class="line">        <span class="keyword">if</span> unicodedata.combining(c) <span class="keyword">and</span> latin_base:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        keepers.append(c)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> unicodedata.combining(c):</span><br><span class="line">            latin_base = c <span class="keyword">in</span> string.ascii_letters</span><br><span class="line">    shaved = <span class="string">""</span>.join(keepers)</span><br><span class="line">    <span class="keyword">return</span> unicodedata.normalize(<span class="string">"NFC"</span>, shaved)</span><br><span class="line"></span><br><span class="line"><span class="comment"># '́'   这是提取出来的变音符号</span></span><br><span class="line">t = <span class="string">'́cafe'</span></span><br><span class="line">print(shave_marks_latin(t))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">cafe</span><br></pre></td></tr></table></figure>
<p>注意&lt;1&gt;处，如果一开始直接<code>latin_base = False</code>，那么遇到刁钻的人，该程序的结果将是错误的：大家可以试一试，把&lt;1&gt;处改成<code>latin_base = False</code>，然后运行该程序，看c上面的变音符号去掉了没有。之所以第7行写成上述形式，就是考虑到可能有的人闲着没事，将变音符号放在字符串的开头。</p>
<p>更彻底的规范化步骤是把西文中的常见符号替换成ASCII中的对等字符，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将拉丁文中的变音符号去掉，并把西文中常见符号替换成ASCII中的对等字符</span></span><br><span class="line">single_map = str.maketrans(<span class="string">"""‚ƒ„†ˆ‹‘’“”•–—˜›"""</span>,</span><br><span class="line">                           <span class="string">"""'f"*^&lt;''""---~&gt;"""</span>)</span><br><span class="line"></span><br><span class="line">multi_map = str.maketrans(&#123;</span><br><span class="line">    <span class="string">'€'</span>: <span class="string">'&lt;euro&gt;'</span>,</span><br><span class="line">    <span class="string">'…'</span>: <span class="string">'...'</span>,</span><br><span class="line">    <span class="string">'Œ'</span>: <span class="string">'OE'</span>,</span><br><span class="line">    <span class="string">'™'</span>: <span class="string">'(TM)'</span>,</span><br><span class="line">    <span class="string">'œ'</span>: <span class="string">'oe'</span>,</span><br><span class="line">    <span class="string">'‰'</span>: <span class="string">'&lt;per mille&gt;'</span>,</span><br><span class="line">    <span class="string">'‡'</span>: <span class="string">'**'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">multi_map.update(single_map)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 该函数不影响ASCII和latin1文本，只替换微软在cp1252中为latin1额外添加的字符</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dewinize</span><span class="params">(txt)</span>:</span></span><br><span class="line">    <span class="string">"""把win1252符号替换成ASCII字符或序列"""</span></span><br><span class="line">    <span class="keyword">return</span> txt.translate(multi_map)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">asciize</span><span class="params">(txt)</span>:</span></span><br><span class="line">    no_mark = shave_marks_latin(dewinize(txt))</span><br><span class="line">    no_mark = no_mark.replace(<span class="string">'ß'</span>, <span class="string">'ss'</span>)</span><br><span class="line">    <span class="keyword">return</span> unicodedata.normalize(<span class="string">"NFKC"</span>, no_mark)</span><br><span class="line"></span><br><span class="line">order = <span class="string">'“Herr Voß: • ½ cup of Œtker™ caffè latte • bowl of açaí.”'</span></span><br><span class="line">print(asciize(order))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line"><span class="string">"Herr Voss: - 1⁄2 cup of OEtker(TM) caffe latte - bowl of acai."</span></span><br></pre></td></tr></table></figure>
<h2 id="unicode文本排序">5.3 Unicode文本排序</h2>
<p>Python中，非ASCII文本的标准排序方式是使用<code>locale.strxfrm</code>函数，该函数“把字符串转换成适合所在地区进行比较的形式”，即和系统设置的地区相关。在使用<code>locale.strxfrm</code>之前，必须先为应用设置合适的区域，而这还得指望着操作系统支持用户自定义区域设置。比如以下排序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; fruits = [<span class="string">"香蕉"</span>, <span class="string">"苹果"</span>, <span class="string">"桃子"</span>, <span class="string">"西瓜"</span>, <span class="string">"猕猴桃"</span>]</span><br><span class="line">&gt;&gt;&gt; sorted(fruits)</span><br><span class="line">[<span class="string">'桃子'</span>, <span class="string">'猕猴桃'</span>, <span class="string">'苹果'</span>, <span class="string">'西瓜'</span>, <span class="string">'香蕉'</span>]</span><br><span class="line">&gt;&gt;&gt; import locale</span><br><span class="line">&gt;&gt;&gt; locale.setlocale(locale.LC_COLLATE, <span class="string">"zh_CN.UTF-8"</span>) <span class="comment"># 设置后能按拼音排序</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;input&gt;"</span>, line 1, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"locale.py"</span>, line 598, <span class="keyword">in</span> setlocale</span><br><span class="line">    <span class="built_in">return</span> _setlocale(category, locale)</span><br><span class="line">locale.Error: unsupported locale setting</span><br><span class="line">&gt;&gt;&gt; locale.getlocale()</span><br><span class="line">(None, None)</span><br></pre></td></tr></table></figure>
<p>笔者是Windows系统，不支持区域设置，不知道Linux下支不支持，大家可以试试。</p>
<h3 id="pyuca">5.3.1 PyUCA</h3>
<p>想要正确实现Unicode排序，可以使用PyPI中的PyUCA库，这是Unicode排序算法的纯Python实现。它没有考虑区域设置，而是根据Unicode官方数据库中的排序表排序，只支持Python3。以下是它的简单用法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import pyuca</span><br><span class="line">&gt;&gt;&gt; coll = pyuca.Collator()</span><br><span class="line">&gt;&gt;&gt; sorted([<span class="string">"cafe"</span>, <span class="string">"caff"</span>, <span class="string">"café"</span>])</span><br><span class="line">[<span class="string">"cafe"</span>, <span class="string">"caff"</span>, <span class="string">"café"</span>]</span><br><span class="line">&gt;&gt;&gt; sorted([<span class="string">"cafe"</span>, <span class="string">"caff"</span>, <span class="string">"café"</span>], key=coll.sort_key)</span><br><span class="line">[<span class="string">"cafe"</span>, <span class="string">"café"</span>, <span class="string">"caff"</span>]</span><br></pre></td></tr></table></figure>
<p>如果想定制排序方式，可把自定义的排序表路径传给<code>Collator()</code>构造方法。</p>
<h1 id="补充">6. 补充</h1>
<h2 id="unicode数据库">6.1 Unicode数据库</h2>
<p>Unicode标准提供了一个完整的数据库（许多格式化的文本文件），它记录了字符是否可打印、是不是字母、是不是数字、或者是不是其它数值符号等，这些数据叫做字符的元数据。字符串中的<code>isidentifier</code>、<code>isprintable</code>、<code>isdecimal</code>和<code>isnumeric</code>等方法都用到了该数据库。unicodedata模块中有几个函数可用于获取字符的元数据，比如<code>unicodedata.name()</code>用于获取字符的官方名称（全大写），<code>unicodedata.numeric()</code>得到数值字符（如<code>①</code>，<code>“1”</code>）的浮点数值。</p>
<h2 id="支持字符串和字节序列的双模式api">6.2 支持字符串和字节序列的双模式API</h2>
<p>目前为止，我们一般都将字符串作为参数传递给函数，但Python标准库中有些函数既支持字符串也支持字节序列作为参数，比如re和os模块中就有这样的函数。</p>
<h3 id="正则表达式中的字符串和字节序列">6.2.1 正则表达式中的字符串和字节序列</h3>
<p>如果使用字节序列构建正则表达式，<code>\d</code>和<code>\w</code>等模式只能匹配ASCII字符；如果是字符串模式，就能匹配ASCII之外的Unicode数字和字母，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">re_numbers_str = re.compile(<span class="string">r'\d+'</span>)  <span class="comment"># 字符串模式</span></span><br><span class="line">re_words_str = re.compile(<span class="string">r'\w+'</span>)</span><br><span class="line">re_numbers_bytes = re.compile(r<span class="string">b'\d+'</span>)  <span class="comment"># 字节序列模式</span></span><br><span class="line">re_words_bytes = re.compile(r<span class="string">b'\w+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要搜索的Unicode文本，包括“1729”的泰米尔数字</span></span><br><span class="line">text_str = (<span class="string">"Ramanujan saw \u0be7\u0bed\u0be8\u0bef"</span>   </span><br><span class="line">            <span class="string">" as 1729 = 1³ + 12³ = 9³ + 10³."</span>)</span><br><span class="line"></span><br><span class="line">text_bytes = text_str.encode(<span class="string">'utf_8'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Text'</span>, repr(text_str), sep=<span class="string">'\n  '</span>)</span><br><span class="line">print(<span class="string">'Numbers'</span>)</span><br><span class="line">print(<span class="string">'  str  :'</span>, re_numbers_str.findall(text_str))   <span class="comment"># 字符串模式r'\d+'能匹配多种数字</span></span><br><span class="line">print(<span class="string">'  bytes:'</span>, re_numbers_bytes.findall(text_bytes))  <span class="comment"># 只能匹配ASCII中的数字</span></span><br><span class="line">print(<span class="string">'Words'</span>)</span><br><span class="line">print(<span class="string">'  str  :'</span>, re_words_str.findall(text_str))  <span class="comment"># 能匹配字母、上标、泰米尔数字和ASCII数字</span></span><br><span class="line">print(<span class="string">'  bytes:'</span>, re_words_bytes.findall(text_bytes))  <span class="comment"># 只能匹配ASCII字母和数字</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">Text</span><br><span class="line">  <span class="string">'Ramanujan saw ௧௭௨௯ as 1729 = 1³ + 12³ = 9³ + 10³.'</span></span><br><span class="line">Numbers</span><br><span class="line">  str  : [<span class="string">'௧௭௨௯'</span>, <span class="string">'1729'</span>, <span class="string">'1'</span>, <span class="string">'12'</span>, <span class="string">'9'</span>, <span class="string">'10'</span>]</span><br><span class="line">  bytes: [<span class="string">b'1729'</span>, <span class="string">b'1'</span>, <span class="string">b'12'</span>, <span class="string">b'9'</span>, <span class="string">b'10'</span>]</span><br><span class="line">Words</span><br><span class="line">  str  : [<span class="string">'Ramanujan'</span>, <span class="string">'saw'</span>, <span class="string">'௧௭௨௯'</span>, <span class="string">'as'</span>, <span class="string">'1729'</span>, <span class="string">'1³'</span>, <span class="string">'12³'</span>, <span class="string">'9³'</span>, <span class="string">'10³'</span>]</span><br><span class="line">  bytes: [<span class="string">b'Ramanujan'</span>, <span class="string">b'saw'</span>, <span class="string">b'as'</span>, <span class="string">b'1729'</span>, <span class="string">b'1'</span>, <span class="string">b'12'</span>, <span class="string">b'9'</span>, <span class="string">b'10'</span>]</span><br></pre></td></tr></table></figure>
<h3 id="os模块中的字符串和字节序列">6.2.2 os模块中的字符串和字节序列</h3>
<p>Python的os模块中的所有函数、文件名或操作路径参数既能是字符串，也能是字节序列。如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; os.listdir(<span class="string">"."</span>)</span><br><span class="line">[<span class="string">'π.txt'</span>]</span><br><span class="line">&gt;&gt;&gt; os.listdir(b<span class="string">"."</span>)</span><br><span class="line">[b<span class="string">'\xcf\x80.txt'</span>]</span><br><span class="line">&gt;&gt;&gt; os.fsencode(<span class="string">"π.txt"</span>)</span><br><span class="line">b<span class="string">'\xcf\x80.txt'</span></span><br><span class="line">&gt;&gt;&gt; os.fsdecode(b<span class="string">'\xcf\x80.txt'</span>)</span><br><span class="line"><span class="string">'π.txt'</span></span><br></pre></td></tr></table></figure>
<p>在Unix衍生平台中，这些函数编解码时使用<code>surrogateescape</code>错误处理方式以避免遇到意外字节序列时卡住。<code>surrogateescape</code>把每个无法解码的字节替换成Unicode中<code>U+DC00</code>到<code>U+DCFF</code>之间的码位，这些码位是保留位，未分配字符，共应用程序内部使用。Windows使用的错误处理方式是<code>strict</code>。</p>
<h1 id="总结">7. 总结</h1>
<p>本节内容较多。本篇首先介绍了编码的基本概念，并以Unicode为例说明了编码的具体过程；然后介绍了Python中的字节序列；随后开始接触实际的编码处理，如Python编解码过程中会引发的错误，以及Python中Unicode字符的比较和排序。最后，本篇简要介绍了Unicode数据库和双模式API。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python进阶</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python进阶</tag>
        <tag>文本</tag>
        <tag>字节序列</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路22-字典和集合</title>
    <url>/2018/05/13/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF22-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<blockquote>
<p>《流畅的Python》笔记。</p>
<p>本篇主要介绍dict和set的高级用法以及它们背后的哈希表。</p>
</blockquote>
<a id="more"></a>
<h1 id="前言">1. 前言</h1>
<p><code>dict</code>类型不但在各种程序中广泛使用，它也是Python的基石。模块的命名空间、实例的属性和函数的关键字参数等都用到了<code>dict</code>。与<code>dict</code>先关的内置函数都在<code>__builtins__.__dict__</code>模块中。</p>
<p>由于字典至关重要，Python对其实现做了高度优化，而散列表（哈希函数，Hash）则是字典性能突出的根本原因。而且集合(<code>set</code>)的实现也依赖于散列表。</p>
<p>本片的大纲如下：</p>
<ul>
<li>常见的字典方法；</li>
<li>如何处理找不到的键；</li>
<li>标准库中<code>dict</code>类型的变种；</li>
<li><code>set</code>和<code>frozenset</code>类型；</li>
<li>散列表工作原理；</li>
<li>散列表带来的潜在影响（什么样的数据可以作为键、不可预知的顺序等）。</li>
</ul>
<h1 id="字典">2. 字典</h1>
<p>和上一篇一样，先来看看<code>collections.abc</code>模块中的两个<strong>抽象基类</strong>：<strong><code>Mapping</code></strong>和<strong><code>MutableMapping</code></strong>。它们的作用是<strong>为<code>dict</code>和其他类似的类型定义形式接口</strong>:</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828492/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF22-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/1526116874334.png" /></p>
<p>然而，非抽象映射类型一般不会直接继承这些抽象基类，它们会直接对<code>dict</code>或者<code>collections.UserDict</code>进行扩展。</p>
<h2 id="创建字典">2.1 创建字典</h2>
<p>首先总结下常用的创建字典的方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = dict(one=<span class="number">1</span>, two=<span class="number">2</span>, three=<span class="number">3</span>)</span><br><span class="line">b = &#123;<span class="string">"one"</span>: <span class="number">1</span>, <span class="string">"two"</span>: <span class="number">2</span>, <span class="string">"three"</span>: <span class="number">3</span>&#125;</span><br><span class="line">c = dict(zip([<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line">d = dict([(<span class="string">"two"</span>, <span class="number">2</span>), (<span class="string">"one"</span>, <span class="number">1</span>), (<span class="string">"three"</span>, <span class="number">3</span>)])</span><br><span class="line">e = dict(&#123;<span class="string">"three"</span>: <span class="number">3</span>, <span class="string">"one"</span>: <span class="number">1</span>, <span class="string">"two"</span>: <span class="number">2</span>&#125;)</span><br><span class="line">print(a == b == c == d == e)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h2 id="字典推导">2.2 字典推导</h2>
<p>列表推导和生成器表达式可以用在字典上。字典推导（<code>dictcomp</code>）可从任何以键值对作为元素的可迭代对象中构建出字典。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DIAL_CODES = [</span><br><span class="line">    (<span class="number">86</span>, <span class="string">'China'</span>),</span><br><span class="line">    (<span class="number">91</span>, <span class="string">'India'</span>),</span><br><span class="line">    (<span class="number">1</span>, <span class="string">'United States'</span>),</span><br><span class="line">    (<span class="number">62</span>, <span class="string">'Indonesia'</span>),</span><br><span class="line">    (<span class="number">55</span>, <span class="string">'Brazil'</span>),</span><br><span class="line">    (<span class="number">92</span>, <span class="string">'Pakistan'</span>),</span><br><span class="line">    (<span class="number">880</span>, <span class="string">'Bangladesh'</span>),</span><br><span class="line">    (<span class="number">234</span>, <span class="string">'Nigeria'</span>),</span><br><span class="line">    (<span class="number">7</span>, <span class="string">'Russia'</span>),</span><br><span class="line">    (<span class="number">81</span>, <span class="string">'Japan'</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">country_code = &#123;country: code <span class="keyword">for</span> code, country <span class="keyword">in</span> DIAL_CODES&#125;</span><br><span class="line">print(country_code)</span><br><span class="line">code_country = &#123;code: country.upper() <span class="keyword">for</span> country, code <span class="keyword">in</span> country_code.items() <span class="keyword">if</span> code &lt; <span class="number">66</span>&#125;</span><br><span class="line">print(code_country)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">&#123;<span class="string">'China'</span>: <span class="number">86</span>, <span class="string">'India'</span>: <span class="number">91</span>, <span class="string">'United States'</span>: <span class="number">1</span>, <span class="string">'Indonesia'</span>: <span class="number">62</span>, <span class="string">'Brazil'</span>: <span class="number">55</span>, </span><br><span class="line"> <span class="string">'Pakistan'</span>: <span class="number">92</span>, <span class="string">'Bangladesh'</span>: <span class="number">880</span>, <span class="string">'Nigeria'</span>: <span class="number">234</span>, <span class="string">'Russia'</span>: <span class="number">7</span>, <span class="string">'Japan'</span>: <span class="number">81</span>&#125;</span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">'UNITED STATES'</span>, <span class="number">62</span>: <span class="string">'INDONESIA'</span>, <span class="number">55</span>: <span class="string">'BRAZIL'</span>, <span class="number">7</span>: <span class="string">'RUSSIA'</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="两个重要的映射方法update和setdefault">2.3 两个重要的映射方法update和setdefault</h2>
<h3 id="update方法">2.3.1 update方法</h3>
<p>它的参数列表如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict.update(m, [**kargs])</span><br></pre></td></tr></table></figure>
<p><code>update</code>方法处理参数<code>m</code>的方法是典型的<strong>“鸭子类型”</strong>。该方法首先检测<code>m</code>是否有<code>keys</code>方法，如果有，那么<code>update</code>方法就把<code>m</code>当做映射对象来处理（即使它并不是映射对象）；否则退一步，把<code>m</code>当做包含了键值对<code>(key, value)</code>元素的迭代器。</p>
<p>Python中大多数映射类的构造方法都采用了类似的逻辑，因此既可用一个映射对象来新建一个映射对象，也可以用包含<code>(key, value)</code>元素的可迭代对象来初始化一个映射对象。</p>
<h3 id="setdefault处理不存在的键">2.3.2 setdefault处理不存在的键</h3>
<p>当更新字典时，如果遇到原字典中不存在的键时，我们一般最开始会想到如下两种方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法1</span></span><br><span class="line"><span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> my_dict:</span><br><span class="line">    my_dict[key] = []  <span class="comment"># 如果字典中不存在该键，则为该键创建一个空list</span></span><br><span class="line">my_dict[key].append(new_value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2</span></span><br><span class="line">temp = my_dict.get(key, []) <span class="comment"># 去的key对应的值，如果key不存在，则创建空list</span></span><br><span class="line">temp.append(new_value)</span><br><span class="line">my_dict[key] = temp  <span class="comment"># 把新列表放回字典</span></span><br></pre></td></tr></table></figure>
<p>以上两种方法至少进行2次键查询，如果键不存在，第一种方法要查询3次，非常低效。但如果使用<code>setdefault</code>方法，则只需一次就可以完成上述操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_dict.setdefault(key, []).append(new_value)</span><br></pre></td></tr></table></figure>
<h2 id="映射的弹性键查询">2.4 映射的弹性键查询</h2>
<p>上述的<code>setdefault</code>方法在每次调用时都要我们手动指定默认值，那有没有什么办法能方便一些，在键不存在时，直接返回我们指定的默认值？两个常用的方法是：①使用<code>defaultdict</code>类；②自定义一个<code>dict</code>子类，在子类中实现<code>__missing__</code>方法，而这个方法又有至少两种方法。</p>
<h3 id="defaultdict类">2.4.1 defaultdict类</h3>
<p><code>collections.defaultdict</code>能优雅的解决3.3.2中的问题：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line">my_dict = collections.defaultdict(list)</span><br><span class="line">my_dict[key].append(new_value)  <span class="comment"># 我们不需要判断键key是否存在于my_dict中</span></span><br></pre></td></tr></table></figure>
<p>在实例化<code>defaultdict</code>时，需要给构造方法提供一个可调用对象（实现了<code>__call__</code>方法的对象），这个可调用对象存储在<code>defaultdict</code>类的属性<code>default_factory</code>中，当<code>__getitem__</code>找不到所需的键时就会通过<code>default_factory</code>来调用这个可调用对象来创建默认值。</p>
<p>上述代码中<code>my_dict[key]</code>的内部过程如下(假设<code>key</code>是新键)：</p>
<ol type="1">
<li>调用<code>list()</code>来创建一个新列表；</li>
<li>把这个新列表作为值，<code>key</code>作为它的键，放到<code>my_dict</code>中；</li>
<li>返回这个列表的<strong>引用</strong>。</li>
</ol>
<p><strong>注意</strong>：</p>
<ul>
<li>如果在实例化<code>defaultdict</code>时未指定<code>default_factory</code>，那么在查询不存在的键时则会触发<code>KeyError</code>；</li>
<li><code>defaultdict</code>中的<code>default_factory</code>只会在<code>__getitem__</code>里被调用，在其它的方法里完全不会发挥作用！比如，<code>dd</code>是个<code>defaultdict</code>，k是个不存在的键，<code>dd[k]</code>这个表达式则会调用<code>default_factory</code>，并返回默认值，而<code>dd.get(k)</code>则会返回<code>None</code>。</li>
</ul>
<p><strong>特殊方法<code>__missing__</code></strong></p>
<p>其实上述的功能都得益于特殊方法<code>__missing__</code>，实际调用<code>default_factory</code>的就是该特殊方法，且该方法只会被<code>__getitem__</code>调用。即：<strong><code>__getitem__</code>调用<code>__missing__</code>，<code>__missing__</code>调用<code>default_factory</code></strong>。</p>
<p>所有的映射类型在处理找不到键的情况是，都会牵扯到该特殊方法。基类<code>dict</code>没有定义这个方法，但<code>dict</code>有该方法的声明。</p>
<p>下面通过编写一个继承自<code>dict</code>的类来说明如何使用<code>__missing__</code>实现字典查询，不过这里并没有在找不到键时调用一个可调用对象，而是抛出异常。</p>
<h3 id="自定义映射类继承自dict">2.4.2 自定义映射类：继承自dict</h3>
<p>某些情况下可能希望在查询字典时，映射里的键通通转换成<code>str</code>类，但为了方便，也允许使用非字符串作为建，比如我们希望实现如下效果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; d = StrKeyDict0([(<span class="string">"2"</span>, <span class="string">"two"</span>), (<span class="string">"3"</span>, <span class="string">"three"</span>)])</span><br><span class="line">&gt;&gt;&gt; d[<span class="string">"2"</span>]</span><br><span class="line"><span class="string">'two'</span></span><br><span class="line">&gt;&gt;&gt; d[3]</span><br><span class="line"><span class="string">'three'</span></span><br><span class="line">&gt;&gt;&gt; d[1]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">	...</span><br><span class="line">KeyError: <span class="string">"1"</span></span><br></pre></td></tr></table></figure>
<p>以下便是这个类的实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrKeyDict0</span><span class="params">(dict)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(key, str):   <span class="comment"># 必须要由此判断，否则无限递归</span></span><br><span class="line">            <span class="keyword">raise</span> KeyError(key)</span><br><span class="line">        <span class="keyword">return</span> self[str(key)]</span><br><span class="line">	</span><br><span class="line">    <span class="comment"># 为了和__getitem__行为一致，所以必须实现该方法，例子在3.4.3中</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key, default=None)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self[key]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">return</span> default</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> key <span class="keyword">in</span> self.keys() <span class="keyword">or</span> str(key) <span class="keyword">in</span> self.keys()</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>第3行：这里的<code>isinstance(key, str)</code>测试是必需的。如果没有这个测试，那么当<code>str(key)</code>是个不存在的键时便会发生<strong>无限递归</strong>，因为第4行<code>self[str(key)]</code>会调用<code>__getitem__</code>，进而又调用<code>__missing__</code>，然后一直重复下去。</li>
<li>第13行：为了保持一致性，<code>__contains__</code>方法在这里也是必需的，因为<code>k in d</code>这个操作会调用该方法。但是从<code>dict</code>继承到的<code>__contains__</code>方法在找不到键的时候不会调用<code>__missing__</code>（间接调用，不会直接调用）。</li>
<li>第14行：这里并没有使用更具Python风格的写法：<code>key in my_dict</code>，因为这样写会使<code>__contains__</code>也发生递归调用，所以这里采用了更显式的方法<code>key in self.keys</code>。同时需要注意的是，这里有两个判断，因为我们本没有强行限制所有的键都必须是<code>str</code>，所以字典中可能存在非字符串的键（<code>key in self.keys()</code>）。</li>
<li>像<code>k in my_dict.keys()</code>这种操作在Python3中很快，即使映射类型对象很庞大也很快，因为<code>dict.keys()</code>返回的是一个”视图“，在视图中查找一个元素的速度很快。</li>
</ul>
<h3 id="子类化userdict">2.4.3 子类化UserDict</h3>
<p><strong>如果要自定义一个映射类型，更好的策略是继承<code>collections.UserDict</code>类</strong>。它是把标准<code>dict</code>用纯Python又实现了一遍。之所以更倾向于从<code>UserDict</code>而不是从<code>dict</code>继承，是因为后者有时会在某些方法的实现上走一些捷径，导致我们不得不在它的子类中重写这些方法，而<code>UserDict</code>则没有这些问题。也正是由于这个原因，如果上个例子要实现将所有的键都转换成字符串，还需要做很多工作，而从<code>UserDict</code>继承则能很容易实现。</p>
<p><strong>注意</strong>：如果我们想在上个例子中实现<code>__setitem__</code>，使其将所有的键都转换成<code>str</code>，则会发生<strong>无限递归</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">-- snip -- </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        self[str(key)] = value</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    d = StrKeyDict0()</span><br><span class="line">    d[<span class="number">1</span>] = <span class="string">"one"</span></span><br><span class="line">    print(d[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">  File <span class="string">"test.py"</span>, line <span class="number">17</span>, <span class="keyword">in</span> __setitem__</span><br><span class="line">    self[str(key)] = value</span><br><span class="line">  [Previous line repeated <span class="number">329</span> more times]</span><br><span class="line">RecursionError: maximum recursion depth exceeded <span class="keyword">while</span> calling a Python object</span><br></pre></td></tr></table></figure>
<p>下面使用<code>UserDict</code>来实现一遍<code>StrKeyDict</code>，它实现了<code>__setitem__</code>方法，将所有的键都转换成<code>str</code>。注意这里并没有自行实现<code>get</code>方法，原因在后面。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrKeyDict</span><span class="params">(collections.UserDict)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(key, str):</span><br><span class="line">            <span class="keyword">raise</span> KeyError(key)</span><br><span class="line">        <span class="keyword">return</span> self[str(key)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="comment"># 相比于StrKeyDict0，这里只有一个判断，因为键都被转换成字符串了</span></span><br><span class="line">        <span class="comment"># 而且查询是在self.data属性上查询，而不是在self.keys()上查询。</span></span><br><span class="line">        <span class="keyword">return</span> str(key) <span class="keyword">in</span> self.data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        <span class="comment"># 把具体实现委托给了self.data属性</span></span><br><span class="line">        self.data[str(key)] = value</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    d = StrKeyDict()</span><br><span class="line">    d[<span class="number">1</span>] = <span class="string">"one"</span></span><br><span class="line">    print(d[<span class="number">1</span>])</span><br><span class="line">    print(d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">one</span><br><span class="line">&#123;<span class="string">'1'</span>: <span class="string">'one'</span>&#125;</span><br></pre></td></tr></table></figure>
<p>因为<code>UserDict</code>继承自<code>MutableMapping</code>，所以<code>StrKeyDict</code>里剩下的映射类型的方法都是从<code>UserDict</code>、<code>MutableMapping</code>和<code>Mapping</code>继承而来，这些方法中有两个值得关注：</p>
<p><strong><code>MutableMapping.update</code></strong>：</p>
<p>这个方法不但可以直接用，它还用在<code>__init__</code>里，使其能支持各种格式的参数。而这个<code>update</code>方法内部则使用<code>self[key] = value</code>来添加新值，所以它其实是在使用我们定义的<code>__setitem__</code>方法。</p>
<p><strong><code>Mapping.get</code></strong>：</p>
<p>对比<code>StrKeyDict0</code>和<code>StrKeyDict</code>的代码可以发现，我们并没有为后者定义<code>get</code>方法。前者如果不定义<code>get</code>方法，则会出现如下情况：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = StrKeyDict0()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">"1"</span>] = one</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">1</span>]</span><br><span class="line"><span class="string">'one'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.get(<span class="number">1</span>)</span><br><span class="line"><span class="literal">None</span>   <span class="comment"># 和__getitem__的行为不符合，应该返回'one'</span></span><br></pre></td></tr></table></figure>
<p>而在<code>StrKeyDict</code>中则没有必要，因为<code>UserDict</code>继承了<code>Mapping</code>的<code>get</code>方法，而查看源代码可知，这个方法的实现和<code>StrKeyDict0.get</code>一模一样。</p>
<h2 id="其他字典">2.5 其他字典</h2>
<h3 id="collections.ordereddict">2.5.1 collections.OrderedDict</h3>
<p>这个类型在添加键的时候会保持原序，即对键的迭代次序就是添加时的顺序。它的<code>popitem</code>方法默认删除并返回字典中的最后一个元素。值得注意的是，从Python3.6开始，<code>dict</code>中键的顺序也保持了原序。但出于兼容性考虑，如果要保持有序，还是推荐使用<code>OrderedDict</code>。</p>
<h3 id="collections.chainmap">2.5.2 collections.ChainMap</h3>
<p>该类型可容纳多个不同的映射对象，然后在查找元素时，这些映射对象会被当成一个整体被逐个查找。这个功能在给有嵌套作用域的语言做解释器的时候很有用，可以用一个映射对象来代表一个作用域的上下文。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line">pylookup = ChainMap(locals(), globals(), vars(builtins))</span><br></pre></td></tr></table></figure>
<h3 id="collections.counter">2.5.3 collections.Counter</h3>
<p>这个类会给键准备一个整数计数器，每次更新一个键时就会自动增加这个计数器。所以这个类型可以用来给可散列对象计数，或者当成多重集来使用（相同元素可以出现不止一次的集合）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import collections</span><br><span class="line">&gt;&gt;&gt; ct = collections.Counter(<span class="string">"abracadabra"</span>)</span><br><span class="line">&gt;&gt;&gt; ct</span><br><span class="line">Counter(&#123;<span class="string">'a'</span>: 5, <span class="string">'b'</span>: 2, <span class="string">'r'</span>: 2, <span class="string">'c'</span>: 1, <span class="string">'d'</span>: 1&#125;)</span><br><span class="line">&gt;&gt;&gt; ct.update(<span class="string">"aaaaazzz"</span>)</span><br><span class="line">&gt;&gt;&gt; ct</span><br><span class="line">Counter(&#123;<span class="string">'a'</span>: 10, <span class="string">'z'</span>: 3, <span class="string">'b'</span>: 2, <span class="string">'r'</span>: 2, <span class="string">'c'</span>: 1, <span class="string">'d'</span>: 1&#125;)</span><br><span class="line">&gt;&gt;&gt; ct.most_common(2)</span><br><span class="line">[(<span class="string">'a'</span>, 10), (<span class="string">'z'</span>, 3)]</span><br></pre></td></tr></table></figure>
<h3 id="不可变映射类型">2.5.4 不可变映射类型</h3>
<p>标准库中所有的映射类型都是可变的，但有时候会有这样的需要，比如不能让用户错误地修改某个映射。从Python3.3开始，<code>types</code>模块中引入了一个封装类<code>MappingProxyType</code>。如果给这个类一个映射，它返回一个只读的映射视图。虽然是个只读视图，但它是动态的，如果原映射被修改，我们也能通过这个视图观察到变化。以下是它的一个例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from types import MappingProxyType</span><br><span class="line">&gt;&gt;&gt; d = &#123;1: <span class="string">"A"</span>&#125;</span><br><span class="line">&gt;&gt;&gt; d_proxy = MappingProxyType(d)</span><br><span class="line">&gt;&gt;&gt; d_proxy</span><br><span class="line">mappingproxy(&#123;1: <span class="string">'A'</span>&#125;)</span><br><span class="line">&gt;&gt;&gt; d_proxy[1]</span><br><span class="line"><span class="string">'A'</span></span><br><span class="line">&gt;&gt;&gt; d_proxy[2] = <span class="string">"x"</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;input&gt;"</span>, line 1, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'mappingproxy'</span> object does not support item assignment</span><br><span class="line">&gt;&gt;&gt; d[2] = <span class="string">"B"</span></span><br><span class="line">&gt;&gt;&gt; d_proxy</span><br><span class="line">mappingproxy(&#123;1: <span class="string">'A'</span>, 2: <span class="string">'B'</span>&#125;)</span><br><span class="line">&gt;&gt;&gt; d_proxy[2]</span><br><span class="line"><span class="string">'B'</span></span><br></pre></td></tr></table></figure>
<h1 id="集合">3. 集合</h1>
<p>和前面的字典一样，先来看看集合的超类的继承关系：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828491/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF22-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/1526136202861.png" /></p>
<p>集合的本质是许多唯一对象的聚集。即，集合可以用于去重。集合中的元素必须是可散列的，<code>set</code>类型本身是不可散列的，但是<code>frozenset</code>可以。也就是说可以创建一个包含不同<code>frozenset</code>的<code>set</code>。</p>
<p><strong>集合的操作</strong></p>
<p>注意两个概念：字面量句法，构造方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;  <span class="comment"># 这叫字面量句法</span></span><br><span class="line">s = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment"># 这叫构造方法</span></span><br><span class="line">s = set() <span class="comment"># 空集， 不是s = &#123;&#125;，这是空字典！</span></span><br></pre></td></tr></table></figure>
<p>字面量句法相对于构造方法更快更易读。后者速度之所以慢是因为Python必须先从<code>set</code>这个名字来查询构造方法，然后新建一个列表，最后再把这个列表传入到构造方法里。而对于字面量句法，Python会利用一个专门的叫做<code>BUILD_SET</code>的字节码来创建集合。</p>
<p>集合的字面量——<code>{1}</code>，<code>{1, 2}</code>等——看起来和它的数学形式一模一样。但要注意空集，如果要创建一个空集，只能是<code>temp = set()</code>，而不是<code>temp = {}</code>，后者创建的是一个空字典。</p>
<p><code>frozenset</code>的标准字符串表示形式看起来就像构造方法调用一样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>frozenset(range(<span class="number">10</span>))</span><br><span class="line">frozenset(&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>对于<code>frozenset</code>，一旦创建便不可更改，常用作字典的键的集合。</p>
<p>除此之外，集合还实现了很多基础的中缀运算符，如交集<code>a &amp; b</code>，合集<code>a | b</code>，差集<code>a - b</code>等，还有子集，真子集等操作，由于这类操作太多，这里不再一一列出。下面代码得到两个可迭代对象中共有的元素个数，这是一个常用操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">found = len(set(needles) &amp; set(haystack))</span><br><span class="line"><span class="comment"># 另一种写法</span></span><br><span class="line">found = len(set(needles).intersection(haystack))</span><br></pre></td></tr></table></figure>
<p><strong>集合推导</strong></p>
<p>和列表推导，字典推导一样，集合也有推导（<code>setcomps</code>）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from unicodedata import name</span><br><span class="line">&gt;&gt;&gt; &#123;chr(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(32, 256) <span class="keyword">if</span> <span class="string">"SIGN"</span> <span class="keyword">in</span> name(chr(i), <span class="string">""</span>)&#125;</span><br><span class="line">&#123;<span class="string">'+'</span>, <span class="string">'÷'</span>, <span class="string">'µ'</span>, <span class="string">'¤'</span>, <span class="string">'¥'</span>, <span class="string">'¶'</span>, <span class="string">'&lt;'</span>, <span class="string">'©'</span>, <span class="string">'%'</span>, <span class="string">'§'</span>, <span class="string">'='</span>, <span class="string">'¢'</span>, <span class="string">'®'</span>, <span class="string">'#'</span>, <span class="string">'$'</span>, <span class="string">'±'</span>, <span class="string">'×'</span>, </span><br><span class="line"><span class="string">'£'</span>, <span class="string">'&gt;'</span>, <span class="string">'¬'</span>, <span class="string">'°'</span>&#125;</span><br></pre></td></tr></table></figure>
<h1 id="dict和set的背后">4. dict和set的背后</h1>
<p>有人做过实验（就在普通笔记本上），在1,000,000个元素中找1,000个元素，<code>dict</code>与<code>set</code>两者的耗时比较接近，大约为0.000337s，而使用列表<code>list</code>，耗时是97.948056s，<code>list</code>的耗时是<code>dict</code>和<code>set</code>的约29万倍。而造成这种差距的最根本的原因是，<code>list</code>中找元素是按位置一个一个找（虽然有像折半查找这类的算法，但本质依然是一个位置接一个位置的比较），而<code>dict</code>是根据某个信息直接计算元素的位置，显然后者速度要比挨个找快很多。而这个计算方法统称为哈希函数（<code>hash</code>），即<code>hash(key)--&gt;position</code>。</p>
<p>碍于篇幅，关于哈希算法的原理（哈希函数的选择，冲突的解决等）这里便不再赘述，相信经常和算法打交道或者考过研的老铁们一定不陌生。</p>
<p>哈希表（也叫散列表）其实是个稀疏数组（有很多空元素的数组），每个单元叫做表元（bucket），Python中每个表元由对键的引用和对值的引用两部分组成。因为所有表元的大小一致，所以当计算出位置后，可以通过偏移量来读取某个元素（变址寻址）。</p>
<p>Python会设法保证大概还有三分之一的表元是空的，当快要达到这个阈值的时候，原有的哈希表会被复制到一个更大的空间中。</p>
<h2 id="哈希值和相等性">4.1 哈希值和相等性</h2>
<p>如果要把一个对象放入哈希表中，首先要计算这个元素的哈希值。Python中可以通过函数<code>hash()</code>来计算。内置的<code>hash()</code>可用于所有的内置对象。如果是自定义对象调用<code>hash()</code>，实际上运行的是自定义的<code>__hash__</code>。如果两个对象在比较的时候相等的，那么它们的哈希值必须相等，否则哈希表就不能正常工作。比如，如果<code>1 == 1.0</code>为真，那么<code>hash(1) == hash(1.0)</code>也必须为真，但其实这两个数字的内部结构完全不一样。而相等性的检测则是调用特殊方法<code>__eq__</code>。</p>
<p><strong><em>补充</em></strong>：从Python3.3开始，为了防止DOS攻击，<code>str</code>、<code>bytes</code>和<code>datetime</code>对象的哈希值计算过程中多了随机的“加盐”步骤。所加的盐值是Python进程中的一个常量，但每次启动Python解释器都会生成一个不同的盐值。</p>
<h2 id="python中的哈希算法">4.2 Python中的哈希算法</h2>
<p>为获取<code>my_dict[search_key]</code>背后的值（不是哈希值），Python首先会调用<code>hash(search_key)</code>计算哈希值，然后取这个值最低的几位数字当作偏移量（这只是一种哈希算法）去获取所要的值，如果发生了冲突，则再取哈希值的另外几位，知道不冲突为止。</p>
<p>在插入新值的时候，Python可能会按照哈希表的拥挤程度来决定是否要重新分配内存为它扩容。如果增加了散列表的大小，散列值所占的位数和用作索引的位数都会随之增加（目的是为了减少冲突发生的概率）。</p>
<p>这个算法看似费事，但实际上就算<code>dict</code>中有数百万个元素，多数的搜索过程中并不会发生冲突，平均下来每次搜索可能会有一到两次冲突。</p>
<h2 id="dict的优劣">4.3 dict的优劣</h2>
<p><strong>1、键必须是可散列的</strong></p>
<p>一个可散列对象必须满足一下要求：</p>
<p>（1）支持<code>hash()</code>函数，并且通过<code>__hash__()</code>方法得到的哈希值是不变的；</p>
<p>（2）支持通过<code>__eq__()</code>方法来检测相等性；</p>
<p>（3）若<code>a == b</code>为真，则<code>hash(a) == hash(b)</code>也必须为真。</p>
<p>所有自定义的对象默认都是可散列的，因为它们的哈希值有<code>id()</code>函数来获取，而且它们都是不相等的。如果你实现了一个类的<code>__eq__</code>方法，并且希望它是可散列的，那请务必保证这个类满足上面的第3条要求。</p>
<p><strong>2、字典在内存上的开销巨大</strong></p>
<p>典型的用空间换时间的算法。因为哈希表是稀疏的，这导致它的空间利用率很低。</p>
<p>如果需要存放数量巨大的记录，那么放在由元组或命名元组构成的列表中会是比较好的选择；最好不要根据JSON的风格，用由字典组成的列表来存放这些记录。</p>
<p>用元组代替字典就能节省空间的原因有两个：①避免了哈希表所耗费的空间；②无需把记录中字段的名字在每个元素里都存一遍。</p>
<p>关于空间优化：如果你的内存够用，那么空间优化工作可以等到真正需要的时候再开始，因为优化往往是可维护性的对立面。</p>
<p><strong>3、键查询很快</strong></p>
<p>本节最开始的实验已经证明，字典的查询速度非常快。如果再简单计算一下，上面的实验中，在有1000万个元素的字典里，每秒能进行200万次键查询。</p>
<p>这里之所以说的是“键查询”，而不是“查询”，是因为有可能值的数据不在内存，内在磁盘中。一旦涉及到磁盘这样的低速设备，查询速度将大打折扣。</p>
<p><strong>4、键的次序取决于添加顺序</strong></p>
<p>当往<code>dict</code>里添加新键而又发生冲突时，新键可能会被安排存放到另一个位置。并且同一组数据，每次按不同顺序进行添加，那么即便是同一个键，同一个算法，最后的位置也可能不同。最典型的就是这组数据全冲突（所有的<code>hash</code>值都一样），然后采用的是线性探测再散列解决冲突，这时的顺序就是添加时的顺序。</p>
<p><strong>5、向字典中添加新键可能会改变已有键的顺序。</strong></p>
<p>无论何时往字典中添加新的键，Python解释器都有可能做出扩容的决定。扩容时，在将原有的元素添加到新表的过程中就有可能改变原有元素的顺序。如果在迭代一个字典的过程中同时对修改字典，那么这个循环就很有可能会跳过一些键。</p>
<p><strong><em>补充</em></strong>：Python3中，<code>.keys()</code>、<code>.items()</code>和<code>.values()</code>方法返回的都是字典视图。</p>
<h2 id="set的实现">4.4 set的实现</h2>
<p><code>set</code>和<code>frozenset</code>也由哈希表实现，但它们的哈希表中存放的只有元素的引用（类似于在字典里只存放了键而没放值）。在<code>set</code>加入到Python之前，都是把字典加上无意义的值来当集合用。5.3中对字典的几个特点也同样适用于集合。</p>
<h1 id="总结">5. 总结</h1>
<p>字典是Python的基石。除了基本的<code>dict</code>，标准库中还有特殊的映射类型：<code>defaultdict</code>、<code>OrderedDict</code>、<code>ChainMap</code>、<code>Counter</code>和<code>UserDict</code>，这些类都在<code>collections</code>模块中。</p>
<p>大多数映射都提供了两个强大的方法：<code>setdefault</code>和<code>update</code>。前者可避免重复搜索，后者可批量更新。</p>
<p>在映射类型的API中，有个很好用的特殊方法<code>__missing__</code>，可以通过这个方法自定义当对象找不到某个键时的行为。</p>
<p><code>set</code>和<code>dict</code>的实现都用到了哈希表，两者的查找速度都很快，但空间消耗大，典型的以空间换时间的算法。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python进阶</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python进阶</tag>
        <tag>Python字典</tag>
        <tag>Python集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路21-序列构成的数组</title>
    <url>/2018/05/06/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF21-%E5%BA%8F%E5%88%97%E6%9E%84%E6%88%90%E7%9A%84%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<blockquote>
<p>《流畅的Python》笔记。</p>
<p>接下来的三篇都是关于Python的数据结构，本篇主要是Python中的各序列类型</p>
</blockquote>
<a id="more"></a>
<h1 id="内置序列类型概览">1. 内置序列类型概览</h1>
<p>Python标准库用C实现了丰富的序列类型，可分为两大类：</p>
<ul>
<li>容器序列：<code>list</code>，<code>tuple</code>和<code>collections.deque</code>等这些序列能存放不同类型的数据。</li>
<li>扁平序列：<code>str</code>，<code>bytes</code>，<code>bytearray</code>，<code>memoryview</code>和<code>array.array</code>等，这些序列只能容纳一种类型。</li>
</ul>
<p>容器序列存放的是它们所包含的任意类型的对象的引用，而扁平序列存放的是值而不是引用。即，扁平序列其实是一段连续的内存空间，更加紧凑。</p>
<p>序列类型还可以按能否被修改来分来：</p>
<ul>
<li>可变序列（<code>MutableSequence</code>）：<code>list</code>，<code>bytearray</code>，<code>array.array</code>，<code>collections.deque</code>和<code>memoryview</code>；</li>
<li>不可变序列（<code>Sequence</code>）：<code>tuple</code>，<code>str</code>和<code>byte</code>。</li>
</ul>
<p>以下是这两大类的继承关系：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828468/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF21-%E5%BA%8F%E5%88%97%E6%9E%84%E6%88%90%E7%9A%84%E6%95%B0%E7%BB%84/1525593275610.png" /></p>
<p>虽然Python中内置的序列类型并不是直接从<code>Sequence</code>和<code>MutableSequence</code>这两个抽象基类继承而来，但了解这些基类可以总结出那些完整的序列类型包含了哪些功能，以及将上述两种分类方式融会贯通。</p>
<p>下面我们从最常用的列表（<code>list</code>）开始。</p>
<h1 id="列表推导和生成器表达式">2. 列表推导和生成器表达式</h1>
<p>列表推导（list comprehension，简称listcomps）是构建列表的快捷方式，而生成器表达式（generator expression, 简称genexps）则可以用来创建其它任何类型的序列。</p>
<p>有时候，比起用<code>for</code>循环，列表推导可能会更简单可读。通常的原则是，只用列表推导来创建新的列表，并且尽量保持简短。如果列表推导的代码超过了两行，应该考虑是不是得用for循环重写，不过这个度得自己把握。（句法提示：Python会忽略<code>[]</code>,<code>{}</code>,<code>()</code>中的换行，所以可以省略不太好看的换行符<code>\</code>)</p>
<p><strong>注意：</strong>在Python3中，列表推导、生成器表达式，以及和它们很相似的集合（<code>set</code>）推导和字典（<code>dict</code>）推导都有了自己的局部作用域，不会影响外部的同名变量（Python2中则可能会影响），如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; x = <span class="string">"a"</span></span><br><span class="line">&gt;&gt;&gt; <span class="built_in">test</span> = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">"ABC"</span>]</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line"><span class="string">"a"</span>   <span class="comment"># 在Python2中，该结果则可能是 "C"</span></span><br></pre></td></tr></table></figure>
<h2 id="列表推导同filter和map比较">2.1 列表推导同filter和map比较</h2>
<p>列表推导可以过滤或加工一个序列或其他可迭代类型中的元素，然后生成一个新列表。而Python内置的<code>filter</code>和<code>map</code>函数组合起来也能达到这一效果（一般需要借助<code>lambda</code>表达式），但可读性却比不上列表推导，比如下面的代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; symbols = <span class="string">"ABCDEFG"</span></span><br><span class="line">&gt;&gt;&gt; ascii = [ord(s) <span class="keyword">for</span> s <span class="keyword">in</span> symbols <span class="keyword">if</span> ord(s) &gt; 66]</span><br><span class="line">&gt;&gt;&gt; ascii</span><br><span class="line">[67, 68, 69, 70, 71]</span><br><span class="line">&gt;&gt;&gt; ascii = list(filter(lambda c: c &gt; 66, map(ord, symbols)))</span><br><span class="line">&gt;&gt;&gt; ascii</span><br><span class="line">[67, 68, 69, 70, 71]</span><br></pre></td></tr></table></figure>
<p>原本以为<code>map/filter</code>组合起来会比列表推导快一些，但有测试证明该结论不一定成立。对于<code>map</code>, <code>filter</code>的详细介绍将放在后面的文章中。</p>
<h2 id="笛卡尔积">2.2 笛卡尔积</h2>
<p>简单说就是简化嵌套<code>for</code>循环，例子如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">colors = [<span class="string">"black"</span>, <span class="string">"white"</span>]</span><br><span class="line">sizes = [<span class="string">"S"</span>, <span class="string">"M"</span>, <span class="string">"L"</span>]</span><br><span class="line">tshirts = [(color, size) <span class="keyword">for</span> color <span class="keyword">in</span> colors <span class="keyword">for</span> size <span class="keyword">in</span> sizes]</span><br><span class="line"></span><br><span class="line">tshirts_for = [] <span class="comment"># 最后它的内容等价于上面的tshirts</span></span><br><span class="line"><span class="keyword">for</span> color <span class="keyword">in</span> colors:</span><br><span class="line">    <span class="keyword">for</span> size <span class="keyword">in</span> sizes:</span><br><span class="line">        tshirts_for.append((color, size))</span><br></pre></td></tr></table></figure>
<p>列表推导的作用只有一个：生成列表。如果想生成其他类型的序列，则需要使用生成器表达式。</p>
<h2 id="生成器表达式">2.3 生成器表达式</h2>
<p>虽然也可以用列表推导式来初始化元组，数组或其他序列类型，但生成器表达式是更好的选择，因为生成器表达式背后<strong>遵循了迭代器协议</strong>，可以<strong>逐个生成元素</strong>（可节省内存），而不是一次性生成所有元素。</p>
<p>生成器表达式语法跟列表推导差不多，只是<strong>把方括号换成了圆括号</strong>而已，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; symbols = <span class="string">"ABCDEFG"</span></span><br><span class="line">&gt;&gt;&gt; tuple(ord(symbol) <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols)  <span class="comment"># ①</span></span><br><span class="line">(65, 66, 67, 68, 69, 70, 71)</span><br><span class="line">&gt;&gt;&gt; import array</span><br><span class="line">&gt;&gt;&gt; array.array(<span class="string">"I"</span>, (ord(symbol) <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols))  <span class="comment"># ②</span></span><br><span class="line">array(<span class="string">'I'</span>, [65, 66, 67, 68, 69, 70, 71])</span><br></pre></td></tr></table></figure>
<p>①如果生成器表达式是一个函数调用过程中的唯一参数，则可不加括号将其围起来；</p>
<p>②array的构造方法需要两个参数，因此括号是必需的。</p>
<p>下面用生成器表达式改写上面的笛卡尔积代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">colors = [<span class="string">"black"</span>, <span class="string">"white"</span>]</span><br><span class="line">sizes = [<span class="string">"S"</span>, <span class="string">"M"</span>, <span class="string">"L"</span>]</span><br><span class="line"><span class="keyword">for</span> tshirt <span class="keyword">in</span> (<span class="string">"%s %s"</span> % (c, s) <span class="keyword">for</span> c <span class="keyword">in</span> colors <span class="keyword">for</span> s <span class="keyword">in</span> sizes):</span><br><span class="line">    print(tshirts)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">black S</span><br><span class="line">black M</span><br><span class="line">black L</span><br><span class="line">white S</span><br><span class="line">white M</span><br><span class="line">white L</span><br></pre></td></tr></table></figure>
<p>生成器表达式逐个生成元素，不会一次性生成一个含有6个元素的列表。关于生成器表达式的工作原理将在后面的文章中介绍。</p>
<h1 id="元组">3. 元组</h1>
<p>元组除了用作不可变的列表，它还可以用于没有字段名的记录，比如坐标，身份信息等，这里不再举例。</p>
<h2 id="元祖拆包">3.1 元祖拆包</h2>
<p>此概念之前涉及过，这里将其总结一下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 平行赋值</span></span><br><span class="line">a, b = (<span class="string">"test1"</span>, <span class="string">"test2"</span>)</span><br><span class="line"><span class="comment"># 不用中间变量交换两个变量的值</span></span><br><span class="line">b, a = a, b</span><br><span class="line"><span class="comment"># *号运算将可迭代对象拆开作为函数参数</span></span><br><span class="line">t = (20, 8)</span><br><span class="line">divmod(*t)  <span class="comment"># 该函数的意思是： 20 ÷ 8 = 2 …… 4， 函数返回商和余数的元组</span></span><br><span class="line"><span class="comment"># 用*来处理剩下的元素，Python3支持</span></span><br><span class="line">a, b, *rest = range(5)  <span class="comment"># rest的值为[2, 3, 4]</span></span><br><span class="line">a, b, *rest = range(3)  <span class="comment"># rest的值为[2]</span></span><br><span class="line">a, b, *rest = range(2)  <span class="comment"># rest的值为[]</span></span><br><span class="line"><span class="comment"># 在平行赋值中，*前缀只能用在一个变量前，但该变量可在任意位置</span></span><br><span class="line">&gt;&gt;&gt; a, *body, c, d = range(5) <span class="comment"># 值依次为 0, [1, 2], 3, 4</span></span><br><span class="line">&gt;&gt;&gt; *head, b, c, d = range(5) <span class="comment"># 值依次为 [0, 1], 2, 3, 4</span></span><br></pre></td></tr></table></figure>
<h2 id="嵌套元组拆包">3.2 嵌套元组拆包</h2>
<p><strong>接受表达式</strong>的元组可以是<strong>嵌套</strong>式的，例如<code>(a, b, (c, d))</code>，只要这个接受元组的嵌套结构符合表达式本身的嵌套结构，以下用嵌套元组来获取经纬度：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">metro_areas = [</span><br><span class="line">    (<span class="string">"Tokyo"</span>, <span class="string">"JP"</span>, <span class="number">36.933</span>, (<span class="number">35.689722</span>, <span class="number">139.691667</span>)),</span><br><span class="line">    (<span class="string">"Delhi NCR"</span>, <span class="string">"IN"</span>, <span class="number">21.935</span>, (<span class="number">28.613889</span>, <span class="number">77.208889</span>)),</span><br><span class="line">    (<span class="string">"Mexico City"</span>, <span class="string">"MX"</span>, <span class="number">20.142</span>, (<span class="number">19.433333</span>, <span class="number">-99.133333</span>)),</span><br><span class="line">    (<span class="string">"New York-Newark"</span>, <span class="string">"US"</span>, <span class="number">20.104</span>, (<span class="number">40.808611</span>, <span class="number">-74.020386</span>)),</span><br><span class="line">    (<span class="string">"Sao Paulo"</span>, <span class="string">"BR"</span>, <span class="number">19.649</span>, (<span class="number">-23.547778</span>, <span class="number">-46.635833</span>)),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">print(<span class="string">"&#123;:15&#125; | &#123;:^9&#125; | &#123;:^9&#125;"</span>.format(<span class="string">" "</span>, <span class="string">"lat."</span>, <span class="string">"long."</span>))</span><br><span class="line">fmt = <span class="string">"&#123;:15&#125; | &#123;:9.4f&#125; | &#123;:9.4f&#125;"</span></span><br><span class="line"><span class="comment"># 把输入元组的最后一个元素拆包到由变量构成的元组中</span></span><br><span class="line"><span class="keyword">for</span> name, cc, pop, (latitude, longitude) <span class="keyword">in</span> metro_areas:</span><br><span class="line">    <span class="keyword">if</span> longitude &lt;= <span class="number">0</span>:</span><br><span class="line">        print(fmt.format(name, latitude, longitude))</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">                |   lat.    |   long.  </span><br><span class="line">Mexico City     |   <span class="number">19.4333</span> |  <span class="number">-99.1333</span></span><br><span class="line">New York-Newark |   <span class="number">40.8086</span> |  <span class="number">-74.0204</span></span><br><span class="line">Sao Paulo       |  <span class="number">-23.5478</span> |  <span class="number">-46.6358</span></span><br></pre></td></tr></table></figure>
<h2 id="具名元组命名元组">3.3 具名元组（命名元组）</h2>
<p>上篇中有所涉及。<code>collections.namedtuple</code>是一个工厂函数，它可以创建一个带字段名的元组和一个有名字的类——这个带名字的类对调试程序有很大帮助。</p>
<p><code>namedtuple</code>构造的类的实例所消耗的内存跟元组是一样的，因为字段名都存在对于的类中。这个实例跟普通对象实例比起来要小一些，因为Python不会用<code>__dict__</code>来存放这些实例的属性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">City = namedtuple(<span class="string">"City"</span>, <span class="string">"name country population coordinates"</span>)</span><br><span class="line">tokyo = City(<span class="string">"Tokyo"</span>, <span class="string">"JP"</span>, <span class="number">36.933</span>, (<span class="number">35.689722</span>, <span class="number">139.691667</span>))</span><br><span class="line">print(tokyo)</span><br><span class="line">print(tokyo.population)</span><br><span class="line">print(tokyo[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">print(City._fields)</span><br><span class="line">LatLong = namedtuple(<span class="string">"LatLong"</span>, <span class="string">"lat long"</span>)</span><br><span class="line">delhi_data = (<span class="string">"Delhi NCR"</span>, <span class="string">"IN"</span>, <span class="number">21.935</span>, LatLong(<span class="number">28.613889</span>, <span class="number">77.208889</span>))</span><br><span class="line">delhi = City._make(delhi_data)</span><br><span class="line">print(delhi._asdict())</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> delhi._asdict().items():</span><br><span class="line">    print(key + <span class="string">":"</span>, value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">City(name=<span class="string">'Tokyo'</span>, country=<span class="string">'JP'</span>, population=<span class="number">36.933</span>, coordinates=(<span class="number">35.689722</span>, <span class="number">139.691667</span>))</span><br><span class="line"><span class="number">36.933</span></span><br><span class="line">JP</span><br><span class="line">(<span class="string">'name'</span>, <span class="string">'country'</span>, <span class="string">'population'</span>, <span class="string">'coordinates'</span>)</span><br><span class="line">OrderedDict([(<span class="string">'name'</span>, <span class="string">'Delhi NCR'</span>), (<span class="string">'country'</span>, <span class="string">'IN'</span>), (<span class="string">'population'</span>, <span class="number">21.935</span>),</span><br><span class="line">             (<span class="string">'coordinates'</span>, LatLong(lat=<span class="number">28.613889</span>, long=<span class="number">77.208889</span>))])</span><br><span class="line">name: Delhi NCR</span><br><span class="line">country: IN</span><br><span class="line">population: <span class="number">21.935</span></span><br><span class="line">coordinates: LatLong(lat=<span class="number">28.613889</span>, long=<span class="number">77.208889</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>第3行：创建一个具名元组需要两个参数，一个是类名，一个是类的各字段名。后者可以是由数个字符串组成的可迭代对象，或者是由空格分隔的字符串；</li>
<li>第6,7行：可通过字段名或位置来获取一个字段的信息；</li>
<li>第9行：<code>_fields</code>属性是一个包含这个类所有字段名的元组；</li>
<li>第12行：<code>_make()</code>通过接受一个可迭代对象来生成这个类的一个实例，它的作用跟<code>City(*delhi_data)</code>是一样的。</li>
<li>第13行：<code>_asdict()</code>把具名元组以<code>collections.OrderedDict</code>的形式返回。</li>
<li>注意第10，27行！</li>
</ul>
<h2 id="作为不可变列表的元组">3.4 作为不可变列表的元组</h2>
<p>除了跟增减元素相关的方法外，元组支持列表的其他所有方法。还有一个例外就是元组没有<code>__reversed__</code>方法，但这方法只是个优化，<code>reversed(my_tuple)</code>这个方法在没有<code>__reversed__</code>的情况下也是合法的。</p>
<h1 id="切片">4. 切片</h1>
<p>切片在Python基础中介绍了一些遍历的基本操作，这里补充一些高级的用法。</p>
<h2 id="切片赋值">4.1 切片赋值</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="built_in">test</span> = list(range(6))</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">test</span></span><br><span class="line">[0, 1, 2, 3, 4, 5]</span><br><span class="line"><span class="comment"># 指定步长赋值</span></span><br><span class="line">&gt;&gt;&gt; <span class="built_in">test</span>[3::2] = [11, 22]</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">test</span></span><br><span class="line">[0, 1, 2, 11, 4, 22]</span><br><span class="line"><span class="comment"># 将列表变长（也可以变短）</span></span><br><span class="line">&gt;&gt;&gt; <span class="built_in">test</span>[1:3] = [7, 8, 9]</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">test</span></span><br><span class="line">[0, 7, 8, 9, 11, 4, 22]</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">test</span>[1:3] = 100</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;input&gt;"</span>, line 1, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: can only assign an iterable</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">test</span>[1:3] = [100]</span><br><span class="line">[0, 100, 9, 11, 4, 22]</span><br></pre></td></tr></table></figure>
<h2 id="有名字的切片">4.2 有名字的切片</h2>
<p>Python中有一个切片类（<code>slice</code>），可以用它创建切片对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">temp = <span class="string">"adfadfadfadfafasdf"</span></span><br><span class="line">TEST = slice(<span class="number">2</span>, <span class="number">8</span>)  <span class="comment"># 一般大写</span></span><br><span class="line">print(temp[TEST])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">fadfad</span><br></pre></td></tr></table></figure>
<h2 id="多维切片和省略">4.3 多维切片和省略</h2>
<p><code>[ ]</code>运算符中还可以使用以逗号分开的多个索引或者切片，比如第三方库<strong>Numpy</strong>中就用到了这个特性，二维的<code>numpy.ndarray</code>就可以用<code>a[i, j]</code>来获取值（这里的语法和C#一样，相当于C/C++中的<code>a[i][j]</code>），或者<code>a[m:n, k:l]</code>来获得二维切片。要正确处理这种语法，对象的特殊方法<code>__getitem__</code>和<code>__setitem__</code>需要以元组的形式来接收<code>a[i, j]</code>中的索引，即，如果要得到<code>a[i, j]</code>，Python会调用<code>a.__getitem__((i, j))</code>。关于多维切片的例子在本文后面演示。</p>
<p>省略（<code>ellipsis</code>）的写法是三个英语句点（<code>...</code>)，而不是Unicode码位U+2026表示的半个省略号（和前面三个句点几乎一模一样）。省略在Python解释器眼里是一个符号，而实际上它是<code>Elllipsis</code>对象的别名，而<code>Ellipsis</code>对象又是<code>ellipsis</code>类的单一实例（<code>ellipsis</code>是类名，全小写，而它的内置实例写作<code>Ellipsis</code>。这跟<code>bool</code>是小写，而它的两个实例<code>True</code>和<code>False</code>是大写一个道理）。它可以当做切片规范的一部分，也可用在函数的参数列表中，如<code>f(a,...,z)</code>，或<code>a[i: ...]</code>。在Numpy中，<code>...</code>用作多维数组切片的快捷方式，即<code>x[i, ...]</code>就是<code>x[i, :, :, :]</code>的缩写。</p>
<p>笔者暂时还没发现Python标准库中有任何<code>Ellipsis</code>或者多维索引的用法。这些句法上的特性主要是为了支持用户自定义类或者扩展，Numpy就是一个例子。</p>
<h1 id="对序列使用和">5. 对序列使用+和*</h1>
<p>通常<code>+</code>号两侧的序列由相同类型的数据所构成（当然不同类型的也可以相加），返回一个新序列。如果想把一个序列复制几份再拼接，更快捷的做法是乘一个整数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; [1, 2] + [3]</span><br><span class="line">[1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; [1, 2] * 2</span><br><span class="line">[1, 2, 1, 2]</span><br><span class="line">&gt;&gt;&gt; 5 * <span class="string">"abc"</span></span><br><span class="line"><span class="string">'abcabcabcabcabc'</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：这里有深浅复制的问题，如果在<code>A * n</code>这个语句中，序列<code>A</code>中的元素<code>b</code>是对其他可变对象的引用的话，则新序列中<code>A2</code>中的<code>n</code>个元素<code>b1</code>……<code>bn</code>都指向同一个位置，即对<code>b1</code>到<code>bn</code>中任意一个赋值，都会影响其他元素。下面以一个创建多维数组的例子来说明这个情况（字符串是不可变对象，而列表是可变对象！）：</p>
<p>正确的写法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">board = [[<span class="string">"_"</span>] * <span class="number">3</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line">print(board)</span><br><span class="line">board[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">"X"</span></span><br><span class="line">print(board)</span><br><span class="line"><span class="comment"># 等价于：</span></span><br><span class="line">board = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    row = [<span class="string">"_"</span>] * <span class="number">3</span></span><br><span class="line">    board.append(row)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">[[<span class="string">'_'</span>, <span class="string">'_'</span>, <span class="string">'_'</span>], [<span class="string">'_'</span>, <span class="string">'_'</span>, <span class="string">'_'</span>], [<span class="string">'_'</span>, <span class="string">'_'</span>, <span class="string">'_'</span>]]</span><br><span class="line">[[<span class="string">'_'</span>, <span class="string">'_'</span>, <span class="string">'_'</span>], [<span class="string">'_'</span>, <span class="string">'_'</span>, <span class="string">'X'</span>], [<span class="string">'_'</span>, <span class="string">'_'</span>, <span class="string">'_'</span>]]</span><br></pre></td></tr></table></figure>
<p>错误的写法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">weird_board = [[<span class="string">"_"</span>] * <span class="number">3</span>] * <span class="number">3</span></span><br><span class="line">print(weird_board)</span><br><span class="line">weird_board[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">"X"</span></span><br><span class="line">print(weird_board)</span><br><span class="line"><span class="comment"># 等价于：</span></span><br><span class="line">weird_board = []</span><br><span class="line">row = [<span class="string">"_"</span>] * <span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    weird_board.append(row)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">[[<span class="string">'_'</span>, <span class="string">'_'</span>, <span class="string">'_'</span>], [<span class="string">'_'</span>, <span class="string">'_'</span>, <span class="string">'_'</span>], [<span class="string">'_'</span>, <span class="string">'_'</span>, <span class="string">'_'</span>]]</span><br><span class="line">[[<span class="string">'_'</span>, <span class="string">'_'</span>, <span class="string">'X'</span>], [<span class="string">'_'</span>, <span class="string">'_'</span>, <span class="string">'X'</span>], [<span class="string">'_'</span>, <span class="string">'_'</span>, <span class="string">'X'</span>]]</span><br></pre></td></tr></table></figure>
<h1 id="序列的增量赋值">6. 序列的增量赋值</h1>
<p>增量赋值运算符<code>+=</code>和<code>*=</code>的表现取决于它们的第一个操作对象，以<code>+=</code>为例。<code>+=</code>背后的特殊方法是<code>__iadd__</code>(用于“就地加法”)，如果一个类没有实现该方法，则会调用<code>__add__</code>。例如 <code>a += b</code>，如果<code>a</code>实现了<code>__iadd__</code>，则直接调用该方法，修改的是<code>a</code>，不会产生新对象，而如果没有实现该方法，则会调用<code>__add__</code>，执行的运算实际是 <code>a = a + b</code>，该运算会生成一个新变量，存储<code>a + b</code>的结果，然后再把该新变量赋值给<code>a</code>。</p>
<p>总体来说，可变序列一般都实现了<code>__iadd__</code>，而不可变序列根本就不支持这个操作。对不可变序列执行重复拼接操作的话，效率很低，因为每次都会生成新对象，而解释器需要把原来对象中的元素先复制到新对象中，然后再追加新元素。但<code>str</code>是个例外，因为对字符串做<code>+=</code>操作是在太普遍了，于是<code>CPython</code>对它做了优化：<code>str</code>初始化时，程序会为它预留额外的可扩展空间，因此做增量操作时不会涉及复制原有字符串到新位置的操作。</p>
<h2 id="一个关于的谜题">6.1 一个关于+=的谜题</h2>
<p>对于以下操作，大家猜想会得到什么样的结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (1, 2, [3, 4])</span><br><span class="line">&gt;&gt;&gt; t[2] += [5, 6]</span><br></pre></td></tr></table></figure>
<p>它的结果是报错，但<code>t</code>依然被改变了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 紧接上述代码</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;input&gt;"</span>, line 1, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'tuple'</span> object does not support item assignment</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">(1, 2, [3, 4, 5, 6])</span><br><span class="line"><span class="comment"># 如果是t[2].extend([5, 6])则不会报错</span></span><br></pre></td></tr></table></figure>
<p>如果我们看Python表达式 <code>s[a] += b</code>的字节码，便不难理解上述结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import dis</span><br><span class="line">&gt;&gt;&gt; dis.dis(<span class="string">"s[a] += b"</span>)</span><br><span class="line">  1           0 LOAD_NAME                0 (s)</span><br><span class="line">              2 LOAD_NAME                1 (a)</span><br><span class="line">              4 DUP_TOP_TWO</span><br><span class="line">              6 BINARY_SUBSCR</span><br><span class="line">              8 LOAD_NAME                2 (b)</span><br><span class="line">             10 INPLACE_ADD</span><br><span class="line">             12 ROT_THREE</span><br><span class="line">             14 STORE_SUBSCR</span><br><span class="line">             16 LOAD_CONST               0 (None)</span><br><span class="line">             18 RETURN_VALUE</span><br></pre></td></tr></table></figure>
<p>从上述结果可以看出：</p>
<ul>
<li>第6行：将<code>s[a]</code>的值存入<code>TOS</code>(Top Of Stack，栈顶)；</li>
<li>第8行：计算<code>TOS += b</code>， 这一步能够完成，因为<code>TOS</code>指向一个可变对象；</li>
<li>第14行：<code>s[a] = TOS</code>，报错，因为<code>s</code>是个元组，不可变。</li>
</ul>
<p>从上述操作可以得到3个教训：</p>
<ul>
<li>不要把可变对象放在元组中；</li>
<li>增量赋值不是一个原子操作。从上面的结果可以看出，它虽抛出了异常，但仍完成了操作；</li>
<li>查看Python字节码并不难，而且它对我们了解代码背后的运行机制很有帮助。</li>
</ul>
<h1 id="用bisect来管理已排序的序列">7. 用bisect来管理已排序的序列</h1>
<p><code>bisect</code>模块包含两个主要函数，<code>bisect</code>和<code>insort</code>，这两个函数都利用<strong>二分查找算法</strong>在有序列表中查找或插入元素。</p>
<p><code>bisect</code>用于查找元素的位置：<code>biisect(haystack, needle)</code>。它返回<code>needle</code>在<code>haystack</code>中的位置<code>index</code>，如果要插入元素，可以在找到位置后，再调用<code>haystack.insert(index, new_ele)</code>，但也可以用<code>bisect</code>模块中的<code>insert</code>直接插入，并且该方法速度更快。</p>
<p>Python的高产贡献者Raymond Hettinger写了一个排序集合模块<code>sortedcollection</code>，该模块集成了<code>bisect</code>功能，且比独立的<code>bisect</code>更易用。</p>
<p><code>bisect</code>需要注意两点：</p>
<ul>
<li>两个可选参数<code>lo</code>和<code>hi</code>：<code>lo</code>默认值是0，<code>hi</code>默认值是序列的长度，即<code>len()</code>作用域该序列的返回值。</li>
<li><code>bisect</code>函数其实是<code>bisect_right</code>函数的别名，它返回的位置是与<code>needle</code>相等的元素的后一个位置，而它的兄弟函数<code>bisect_left</code>则返回的是与<code>needle</code>相等的元素的位置。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import bisect</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">test</span> = [1, 2, 3, 4, 5, 6, 7]</span><br><span class="line">&gt;&gt;&gt; bisect.bisect(<span class="built_in">test</span>,1)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; bisect.bisect_left(<span class="built_in">test</span>,1)</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>相应的，模块中<code>insort</code>也有两个版本，<code>insort</code>是<code>insort_right</code>的别名，它也有两个可选参数<code>lo</code>和<code>hi</code>，<code>insort_left</code>的背后调用的就是<code>bisect_left</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; bisect.insort(<span class="built_in">test</span>, 1.0)</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">test</span></span><br><span class="line">[1, 1.0, 2, 3, 4, 5, 6, 7]</span><br><span class="line">&gt;&gt;&gt; bisect.insort_left(<span class="built_in">test</span>, 1.0)</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">test</span></span><br><span class="line">[1.0, 1, 1.0, 2, 3, 4, 5, 6, 7]</span><br></pre></td></tr></table></figure>
<h1 id="当列表不是首选时">8. 当列表不是首选时</h1>
<p>当我们有特定的数据集时，<code>list</code>并不一定是首选，比如存放1000万个浮点数，数组（<code>array</code>）的效率就要高很多，因为数组的背后并不是<code>float</code>对象，而是数字的机器翻译，也就是字节表述。这点和C语言中的数组一样。再比如，如果要频繁对序列做先进先出的操作，<code>deque</code>（双端队列）的速度应该会更快。</p>
<h2 id="数组">8.1 数组</h2>
<p>如果需要一个只含数字的列表，<code>array.array</code>会比<code>list</code>更高效，它支持所有跟可变列表有关的操作，包括<code>.pop</code>，<code>.insert</code>，<code>.extend</code>等。另外数组还支持从文件读取和存入文件的更快的方法，比如<code>.frombytes</code>和<code>.tofile</code>。</p>
<p>数组跟C语言数组一样精简，创建一个数组需要指定一个类型码，这个类型码用来表示在底层的C语言应该存放怎样的数据类型，以下是<code>array.array</code>的操作例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">print(<span class="string">"\n\n"</span>)</span><br><span class="line">floats = array(<span class="string">"d"</span>, (random() <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span> ** <span class="number">7</span>)))</span><br><span class="line">print(floats[<span class="number">-1</span>])</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"floats.bin"</span>, <span class="string">"wb"</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    floats.tofile(fp)</span><br><span class="line"></span><br><span class="line">floats2 = array(<span class="string">"d"</span>)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"floats.bin"</span>, <span class="string">"rb"</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    floats2.fromfile(fp, <span class="number">10</span> ** <span class="number">7</span>)</span><br><span class="line">print(floats2[<span class="number">-1</span>])</span><br><span class="line">print(floats2 == floats)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line"><span class="number">0.8220703930498271</span></span><br><span class="line"><span class="number">0.8220703930498271</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>有人做过实验，用<code>array.fromfile</code>从一个二进制文件读出1000万个双精度浮点数只需要0.1秒（笔者电脑有点年代了，达不到这个速度），速度是从文本文件里读取的60倍，因为后者会使用内置的float方法把每一行文字转换成浮点数。另外，<code>array.tofile</code>写入二进制文件也比写入文本文件快7倍。另外，这1000万个数的bin文件只占8千万字节，如果是文本文件的话，需要181515739字节。</p>
<p>另一个快速序列化数字类型的方法是使用<code>pickle</code>模块，<code>pickle.dump</code>处理浮点数组的速度几乎和<code>array.tofile</code>一样快，而且<code>pickle</code>可以处理几乎所有的内置数字类型</p>
<h2 id="内存视图memoryview">8.2 内存视图memoryview</h2>
<p><code>memoryview</code>是个内置类，它让用户在不复制内存的情况下操作同一个数组的不同切片。<code>memoryview</code>的概念受到了Numpy的启发。</p>
<p>内存视图其实是泛化和去数学化的Numpy数组。它让你在不需要复制内容的前提下，在数据结构之间共享内存。其中数据结构可以是任何形式，比如PIL图片、SQLite数据库和Numpy数组等待。这个功能在处理大型数据集合的时候非常重要。</p>
<p><code>memoryview.cast</code>的概念跟数组模型类似，能用不同的方式读取同一块内存数据，而且内存字节不会随意移动。这有点类似于C语言的类型转换。<code>memoryview.cast</code>会把同一块内存里的内容打包成一个全新的<code>memoryview</code>对象返回。</p>
<p>下面这个例子精确地修改一个数组的某个字节：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> array</span><br><span class="line"><span class="comment"># 16位二进制整数</span></span><br><span class="line">numbers = array.array(<span class="string">"h"</span>, [<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">memv = memoryview(numbers)</span><br><span class="line">print(len(memv))</span><br><span class="line">print(memv[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 转换成8位的无符号整数</span></span><br><span class="line">memv_oct = memv.cast(<span class="string">"B"</span>)</span><br><span class="line">print(memv_oct.tolist())</span><br><span class="line"><span class="comment"># 这个坐标刚好是第3个16位二进制数的高位字节</span></span><br><span class="line">memv_oct[<span class="number">5</span>] = <span class="number">4</span></span><br><span class="line">print(numbers)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">-2</span></span><br><span class="line">[<span class="number">254</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>]</span><br><span class="line">array(<span class="string">'h'</span>, [<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1024</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<h2 id="numpy和scipy">8.3 NumPy和SciPy</h2>
<p>拼接这NumPy和SciPy提供的高阶数组和矩阵操作，Python称为科学计算应用的主流语言。NumPy实现了多维同质数组（homogeneous array）和矩阵，这些数据结构不但能处理数字，还能存放其他由用户定义的记录。SciPy是基于NumPy的另一个库，他提供了很多跟科学计算有关的算法，专为线性代数、数值积分和统计学而设计。SciPy的高校和可靠性归功于背后的C和Fortran代码，而这些跟计算有关的部分都源自于Netlib。SciPy把基于C和Fortran的工业级数学计算功能用交互式且高度抽象的Python包装起来。</p>
<p>以下是一些NumPy二维数组的基本操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import numpy</span><br><span class="line">&gt;&gt;&gt; a = numpy.arange(12)</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; <span class="built_in">type</span>(a)</span><br><span class="line">&lt;class <span class="string">'numpy.ndarray'</span>&gt;</span><br><span class="line"><span class="comment"># 数组a的维度</span></span><br><span class="line">&gt;&gt;&gt; a.shape</span><br><span class="line">(12,)</span><br><span class="line"><span class="comment"># 手动设置数组维度，3行4列</span></span><br><span class="line">&gt;&gt;&gt; a.shape = 3, 4</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">array([[ 0,  1,  2,  3],</span><br><span class="line">       [ 4,  5,  6,  7],</span><br><span class="line">       [ 8,  9, 10, 11]])</span><br><span class="line"><span class="comment"># 第2行</span></span><br><span class="line">&gt;&gt;&gt; a[2]</span><br><span class="line">array([ 8,  9, 10, 11])</span><br><span class="line"><span class="comment"># 第2行第1列元素</span></span><br><span class="line">&gt;&gt;&gt; a[2, 1]</span><br><span class="line">9</span><br><span class="line"><span class="comment"># 第1列元素</span></span><br><span class="line">&gt;&gt;&gt; a[:, 1]</span><br><span class="line">array([1, 5, 9])</span><br><span class="line"><span class="comment"># 转置</span></span><br><span class="line">&gt;&gt;&gt; a.transpose()</span><br><span class="line">array([[ 0,  4,  8],</span><br><span class="line">       [ 1,  5,  9],</span><br><span class="line">       [ 2,  6, 10],</span><br><span class="line">       [ 3,  7, 11]])</span><br><span class="line"><span class="comment"># 全部数据乘2</span></span><br><span class="line">&gt;&gt;&gt; a *= 2</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">array([[ 0,  2,  4,  6],</span><br><span class="line">       [ 8, 10, 12, 14],</span><br><span class="line">       [16, 18, 20, 22]])</span><br></pre></td></tr></table></figure>
<p>NumPy也可读取、写入文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从文本文件中读取数据</span></span><br><span class="line">floats = numpy.loadtxt(<span class="string">"filename.txt"</span>)</span><br><span class="line"><span class="comment"># 把数组存入后缀为.npy的二进制文件，会自动加后缀名</span></span><br><span class="line">numpy.save(<span class="string">"filesave"</span>, floats)</span><br><span class="line"><span class="comment"># 从.npy文件中读取数据，这次load方法利用了一种叫做内存映射的机制，它让</span></span><br><span class="line"><span class="comment"># 我们在内存不足的时候仍可以对数组切片</span></span><br><span class="line">floats2 = numpy.load(<span class="string">"filesave.npy"</span>, <span class="string">"r+"</span>)</span><br></pre></td></tr></table></figure>
<p>这两个库都异常强大，它们也是一些其他库的基础，比如Pandas和Blaze数据分析库。</p>
<h2 id="双向队列和其他形式的队列">8.4 双向队列和其他形式的队列</h2>
<p>利用<code>.append</code>和<code>.pop</code>方法，可以将列表（<code>list</code>）变成栈和队列。但删除列表的第一个元素或在第一个元素前插入元素之类的操作会很耗时，因为会移动数据。如果经常要在列表两端操作数据，推荐使用<code>collections.deque</code>类（双向队列）。它是一个线程安全、可快速从两端添加删除元素的数据类型。下面是它的操作示范：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># maxlen是个可选参数，表示队列最大长度，该属性一旦设定变不能修改</span></span><br><span class="line">&gt;&gt;&gt; dq = deque(range(10), maxlen=10)</span><br><span class="line">&gt;&gt;&gt; dq</span><br><span class="line">deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10)</span><br><span class="line"><span class="comment"># 队列旋转操作，接收参数n，当n＞0时，队列最右边n个元素移动到最左边</span></span><br><span class="line"><span class="comment"># 当n＜0时，队列最左边n个元素移动到最右边</span></span><br><span class="line">&gt;&gt;&gt; dq.rotate(3)</span><br><span class="line">&gt;&gt;&gt; dq</span><br><span class="line">deque([7, 8, 9, 0, 1, 2, 3, 4, 5, 6], maxlen=10)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; dq.rotate(-4)</span><br><span class="line">&gt;&gt;&gt; dq</span><br><span class="line">deque([1, 2, 3, 4, 5, 6, 7, 8, 9, 0], maxlen=10)</span><br><span class="line"><span class="comment"># 队列左边添加一个元素-1，由于队列长10，所以元素0被删除</span></span><br><span class="line">&gt;&gt;&gt; dq.appendleft(-1)</span><br><span class="line">&gt;&gt;&gt; dq</span><br><span class="line">deque([-1, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10)</span><br><span class="line"><span class="comment"># 队列右边添加三个元素，挤掉了最前面的三个元素</span></span><br><span class="line">&gt;&gt;&gt; dq.extend([11, 22, 33])</span><br><span class="line">&gt;&gt;&gt; dq</span><br><span class="line">deque([3, 4, 5, 6, 7, 8, 9, 11, 22, 33], maxlen=10)</span><br><span class="line"><span class="comment"># 注意添加的顺序</span></span><br><span class="line">&gt;&gt;&gt; dq.extendleft([10, 20, 30, 40])</span><br><span class="line">&gt;&gt;&gt; dq</span><br><span class="line">deque([40, 30, 20, 10, 3, 4, 5, 6, 7, 8], maxlen=10)</span><br></pre></td></tr></table></figure>
<p>该数据结构还有许多其他操作，<code>append</code>和<code>popleft</code>是原子操作，可在多线程中安全地使用，不用担心资源锁的问题。</p>
<h2 id="python标准库中的队列">8.5 Python标准库中的队列</h2>
<ul>
<li><code>queue</code>：提供了同步（线程安全）类<code>Queue</code>，<code>LifoQueue</code>和<code>PriorityQueue</code>，不同的<strong>线程</strong>可以利用这些数据类型来交换信息。这三个类在队列满的时候不会丢掉旧元素，而是被锁住，直到某线程移除了某个元素。这一特性让这些类很适合用来控制活跃线程的数量。</li>
<li><code>multiprocessing</code>：实现了自己的<code>Queue</code>，和<code>queue.Queue</code>类似，设计给<strong>进程</strong>间通信用的。同时还有一个专门的<code>multiprocessing.JoinableQueue</code>类，该类让任务管理变得方便。</li>
<li><code>asyncio</code>：从Python3.4新增的包，包含<code>Queue</code>，<code>LifoQueue</code>，<code>PriorityQueue</code>和<code>JoinableQueue</code>，这些类受<code>queue</code>和<code>multiprocessing</code>模块的影响，但是为异步编程里的任务管理提供了专门的便利。</li>
<li><code>heapq</code>：和上述三个模块不同，它没有队列类，而是提供了<code>heappush</code>和<code>heappop</code>方法，让用户可以把可变序列当作堆队列或者优先队列来使用。</li>
</ul>
<h1 id="补充">9. 补充</h1>
<ul>
<li>Python入门教材往往会强调列表可以容纳不同类型的元素，但实际上这样做并没有什么特别的好处。之所以用列表来存放东西，是期待在稍后使用它的时候，其中的元素能有一些共有的特性。Python3中，如果列表里的元素不能比较大小，则是不能对列表进行排序的。元组则恰恰相反，它经常用来存放不同类型的元素，这也符合它的本质，元组就是用作存放彼此之间没有关系的数据的记录。</li>
<li><code>list.sort</code>，<code>sorted</code>，<code>max</code>和<code>min</code>函数的<code>key</code>参数是个很棒的设计，相比于其他语言中双参数比较函数，这里的参数<code>key</code>只需提供一个单参数函数来提取或计算一个值作为比较大小的标准。说它更高效，是因为在每个元素上，<code>key</code>函数只被调用一次。诚然，在排序的时候，Python总会比较两个键（key），但那一阶段的计算发生在C语言那一层，这样会比调用用户自定义的Python比较函数更快。<code>key</code>参数也能让你对一个混有数字字符和数值的列表进行排序，只需决定到底是将字符看做数值（数值排序），还是将数值看成字符（ASCII排序），即<code>key</code>到底是等于<code>int</code>还是等于<code>str</code>。</li>
<li><code>sorted</code>和<code>list.sort</code>背后的排序算法是<code>Timsort</code>，它是一种自适应算法，会根据原始数据的顺序特点交替使用插入排序（数列基本有序时）和归并排序（没什么规律时），以达到最佳效率。这样的算法被证明是有效的，因为来自真实世界的数据通常是有一定的顺序特点的。<code>Timsort</code>在2002年的时候首次用在<code>CPython</code>中，自2009年起，Java和Android也开始使用这个算法。后来该算法被广为人知，是因为在Google对Sun的侵权案中，Oracle把<code>Timsort</code>中的一些相关代码作为了呈堂证供。<code>Timsort</code>的创始人是Tim Peters，一位高产的Python核心开发者，他也是“Python之禅”的作者之一。</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python进阶</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python进阶</tag>
        <tag>Python序列</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路20-数据模型</title>
    <url>/2018/05/05/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF20-Python%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<blockquote>
<p>《流畅的Python》笔记。</p>
<p>本篇是Python进阶篇的开始。本篇主要是对Python特殊方法的概述。</p>
</blockquote>
<a id="more"></a>
<h1 id="前言">1. 前言</h1>
<p>数据模型其实是对Python框架的描述，它规范了这门语言自身构件模块的接口，这些模块包括但不限于序列、迭代器、函数、类和上下文管理器。不管在哪种框架下写程序，都会花费大量时间去实现那些会被框架本身调用的方法，Python也不例外。Python解释器碰到特殊句法时，会使用特殊方法去激活一些基本的对象操作，这些特殊方法的名字以两个下划线开头，以两个下划线结尾（所以特殊方法也叫双下方法 dunder method），这些特殊方法名能让自己编写的对象实现和支持以下的语言构架，并与之交互：</p>
<p>迭代、集合类、属性访问、运算符重载、函数和方法的调用、对象的创建和销毁、字符串表示形式和格式化、管理上下文（即<code>with</code>块）。</p>
<p>下面通过一些例子来介绍常用的特殊方法。</p>
<h1 id="python风格纸牌">2. Python风格纸牌</h1>
<p>首先介绍两个特殊方法<code>__getitem__</code>和<code>__len__</code>这两个特殊方法。以下代码创建了一个纸牌类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">Card = collections.namedtuple(<span class="string">"Card"</span>, [<span class="string">"rank"</span>, <span class="string">"suit"</span>])</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrenchDeck</span>:</span></span><br><span class="line">    ranks = [str(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">11</span>)] + list(<span class="string">"JQKA"</span>)</span><br><span class="line">    <span class="comment"># 黑桃，红桃，方块，梅花</span></span><br><span class="line">    suits = <span class="string">"spades diamonds clubs hearts"</span>.split()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 嵌套循环</span></span><br><span class="line">        self._cards = [Card(rank, suit) <span class="keyword">for</span> suit <span class="keyword">in</span> self.suits <span class="keyword">for</span> rank <span class="keyword">in</span> self.ranks]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._cards)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, position)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._cards[position]</span><br></pre></td></tr></table></figure>
<p><code>namedtuple</code>，即命名元组，类似于<code>C/C++</code>中的<code>struct</code>，定义如下：</p>
<p><code>collections.namedtuple(typename, field_names, verbose=False, rename=False)</code></p>
<p>第一个参数是元组名；第二个是该元组中含的属性名；第三个参数表示在构建该命名元组之前先打印出该命名元组的结构，如果在控制台输入第3行代码，并置<code>verbose</code>为<code>True</code>的话，会输出该命名元组的内部结构，实际上它是一个继承自<code>tuple</code>的类，由于输出过长，请大家自行实验；如果该命名元组的元素名中有Python关键字，则需要置第四个参数为<code>True</code>，这些与关键字重名的元素名会被特殊处理。</p>
<p>用命名元组创建一个不带方法的对象十分简单：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from chapter20 import Card, FrenchDeck</span><br><span class="line">&gt;&gt;&gt; beer_card = Card(<span class="string">"7"</span>, <span class="string">"diamonds"</span>)</span><br><span class="line">&gt;&gt;&gt; beer_card</span><br><span class="line">Card(rank=<span class="string">'7'</span>, suit=<span class="string">'diamonds'</span>)</span><br></pre></td></tr></table></figure>
<p>由于<code>FrenchDeck</code>实现了<code>__getitem__</code>方法，所以可以像操作<code>List</code>或<code>Tuple</code>一样操作<code>FrenchDeck</code>，比如随机访问，切片：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; deck = FrenchDeck()</span><br><span class="line">&gt;&gt;&gt; len(deck)</span><br><span class="line">52</span><br><span class="line">&gt;&gt;&gt; deck[0]</span><br><span class="line">Card(rank=<span class="string">'2'</span>, suit=<span class="string">'spades'</span>)</span><br><span class="line">&gt;&gt;&gt; deck[-1]</span><br><span class="line">Card(rank=<span class="string">'A'</span>, suit=<span class="string">'hearts'</span>)</span><br><span class="line">&gt;&gt;&gt; from random import choice</span><br><span class="line">&gt;&gt;&gt; choice(deck)</span><br><span class="line">Card(rank=<span class="string">'4'</span>, suit=<span class="string">'clubs'</span>)</span><br><span class="line">&gt;&gt;&gt; choice(deck)</span><br><span class="line">Card(rank=<span class="string">'J'</span>, suit=<span class="string">'clubs'</span>)</span><br><span class="line">&gt;&gt;&gt; deck[:3]</span><br><span class="line">[Card(rank=<span class="string">'2'</span>, suit=<span class="string">'spades'</span>), Card(rank=<span class="string">'3'</span>, suit=<span class="string">'spades'</span>), Card(rank=<span class="string">'4'</span>, suit=<span class="string">'spades'</span>)]</span><br><span class="line">&gt;&gt;&gt; deck[12::13]</span><br><span class="line">[Card(rank=<span class="string">'A'</span>, suit=<span class="string">'spades'</span>), Card(rank=<span class="string">'A'</span>, suit=<span class="string">'diamonds'</span>), </span><br><span class="line">Card(rank=<span class="string">'A'</span>, suit=<span class="string">'clubs'</span>), Card(rank=<span class="string">'A'</span>, suit=<span class="string">'hearts'</span>)]</span><br></pre></td></tr></table></figure>
<p>由于实现了该方法，<code>FrenchDeck</code>还是个可迭代对象，即可以用<code>for</code>循环对其访问（也可以反向访问<code>reversed</code>）:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">for</span> card <span class="keyword">in</span> deck:</span><br><span class="line">&gt;&gt;&gt; ... <span class="built_in">print</span>(card)</span><br><span class="line">    </span><br><span class="line">Card(rank=<span class="string">'2'</span>, suit=<span class="string">'spades'</span>)</span><br><span class="line">Card(rank=<span class="string">'3'</span>, suit=<span class="string">'spades'</span>)</span><br><span class="line">Card(rank=<span class="string">'4'</span>, suit=<span class="string">'spades'</span>)</span><br><span class="line">-- snip --</span><br><span class="line">Card(rank=<span class="string">'Q'</span>, suit=<span class="string">'hearts'</span>)</span><br><span class="line">Card(rank=<span class="string">'K'</span>, suit=<span class="string">'hearts'</span>)</span><br><span class="line">Card(rank=<span class="string">'A'</span>, suit=<span class="string">'hearts'</span>)</span><br></pre></td></tr></table></figure>
<p>迭代通常是隐式的，譬如说一个集合类型没有实现<code>__contains__</code>方法，那么in运算符就会按顺序做一次迭代搜索（调用<code>__getitem__</code>），于是<code>in</code>运算符可以用在<code>FrenchDeck</code>上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; Card(<span class="string">'2'</span>, <span class="string">'spades'</span>) <span class="keyword">in</span> deck</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>如果对上述<code>deck</code>变量调用<code>sorted</code>函数，Python将按<code>ASCII</code>码进行排序，但这并不是扑克牌的正确排序，所以下面我们自定义排序方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">suit_values = dict(spades=<span class="number">3</span>, hearts=<span class="number">2</span>, diamonds=<span class="number">1</span>, clubs=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spades_high</span><span class="params">(card)</span>:</span></span><br><span class="line">    rank_value = FrenchDeck.ranks.index(card.rank)</span><br><span class="line">    <span class="keyword">return</span> rank_value * len(suit_values) + suit_values[card.suit]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> card <span class="keyword">in</span> sorted(deck, key=spades_high):</span><br><span class="line">    print(card)</span><br></pre></td></tr></table></figure>
<p>此时输出的结果就是先按点数排序，再按花色排序。</p>
<h1 id="如何使用特殊方法">3. 如何使用特殊方法</h1>
<p>需要明确一点，特殊方法的存在是为了给Python解释器调用到，作为程序员并不需要调用他们，也即是说，没有<code>my_object.__len__()</code>这种写法，而应该是<code>len(my_object)</code>。说到<code>__len__</code>方法，如果是Python内置类型，CPython会抄个近路，该方法实际上会直接返回<code>PyVarObject</code>里的<code>ob_size</code>属性，而<code>PyVarObject</code>是表示内存中长度可变的内痔对象的C语言结构体。</p>
<p>很多时候特殊方法的调用是隐式的，比如<code>for i in x:</code>这个语句，背后其实用的是<code>iter(x)</code>，而这个函数的背后则是<code>x.__iter__()</code>方法，当然前提是这个方法在<code>x</code>中被实现（如果没被实现则会调用<code>__getitem__</code>方法）。</p>
<p>直接调用这个值比调用一个方法快很多。直接调用特殊方法的频率应该远远低于你去实现它们的次数。</p>
<p>通过内置的函数（例如<code>len</code>，<code>iter</code>，<code>str</code>等）来使用特殊方法是最好的选择。这些内置函数不仅会调用特殊方法，通常还提供额外的好处，而且对于内置的类来说，它们的速度更快。</p>
<p>还有一点值得注意：不要想当然地随意添加特殊方法，比如<code>__foo__</code>之类的，因为虽然现在这个名字没有被Python内部使用，以后就不一定了。</p>
<h2 id="自定义向量vector">3.1 自定义向量Vector</h2>
<p>使用5个特殊方法实现<code>Vector</code>的字符串输出，取绝对值（如果是复数则是取模），返回布尔值，加法和数乘等运算：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> hypot</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x=<span class="number">0</span>, y=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Vector(%r, %r)"</span> % (self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> hypot(self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在Python中，只有0，NULL才是False，其余均为True</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 更简单的写法是：</span></span><br><span class="line">        <span class="comment"># return bool(self.x or self.y)</span></span><br><span class="line">        <span class="keyword">return</span> bool(abs(self))</span><br><span class="line">	</span><br><span class="line">    <span class="comment"># 实现加法运算符重载</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Vector(self.x + other.x, self.y + other.y)</span><br><span class="line">	</span><br><span class="line">    <span class="comment"># 实现乘法运算符重载，这里是数乘，且还没有实现交换律（需要实现__rmul__方法）</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__mul__</span><span class="params">(self, scalar)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Vector(self.x * scalar, self.y * scalar)</span><br></pre></td></tr></table></figure>
<p>Python有一个内置函数叫做<code>repr</code>。该函数通过特殊方法<code>__repr__</code>来得到一个对象的字符串表示形式，如果没有该特殊方法，当我们在控制台打印一个向量对象时，得到的字符串可能是<code>&lt;Vector object at 0x10e00070&gt;</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">v1 = Vector(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">v2 = Vector(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">print(v1 + v2)</span><br><span class="line">print(abs(v1))</span><br><span class="line">print(v1 * <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">Vector(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="number">4.47213595499958</span></span><br><span class="line">Vector(<span class="number">6</span>, <span class="number">12</span>)</span><br></pre></td></tr></table></figure>
<p><code>__repr__</code>与<code>__str__</code>的区别与联系：前者方便我们调试和记录日志，后者则是给终端用户看的。后者是在<code>str()</code>函数被使用，或者是在<code>print</code>函数打印一个对象的时候才被调用，它返回的字符串对终端用户友好。如果只想实现这两个特殊方法中的一个，<code>__repr__</code>是更好的选择，因为如果一个对象没有<code>__str__</code>函数，Python又需要调用它时，解释器会用<code>__repr__</code>代替。</p>
<p>上述<code>Vector</code>类实现了<code>__bool__</code>方法，它可用于需要布尔值的上下文中（<code>if</code>, <code>while</code>, <code>and</code>, <code>or</code>, <code>not</code>等）。默认情况下，我们自己定义的类的实例总被认为是<code>True</code>，除非重写了这个类的<code>__bool__</code>或<code>__len__</code>方法。<code>bool(x)</code>的背后是调用<code>x.__bool__()</code>；如果不存在<code>__bool__</code>方法，那么<code>bool(x)</code>会尝试调用<code>x.__len__()</code>，如果该方法返回0，则<code>bool</code>返回<code>False</code>，否则返回<code>True</code>。</p>
<h2 id="为什么len不是普通方法">3.2 为什么len不是普通方法</h2>
<p>“实用胜于纯粹”（Python之禅里的一句话）。<code>len</code>之所以不是一个普通方法，是为了让Python自带的数据结构可以走后门，<code>abs</code>也是同理。但多亏了它是特殊方法，我们也可以把<code>len</code>用于自定义数据类型。这种处理方式在保持内置类型的效率和保证语言的一致性之间找到了一个平衡点，也印证了“Python之禅”中的另一句话：“不能让特例特殊到考试破坏既定规则”。</p>
<h1 id="总结">4. 总结</h1>
<p>通过实现特殊方法，自定义数据类型可以表现得跟内置类型一样，从而让我们写出更具Python风格（Pythonic）的代码。后面的内容将围绕更多的特殊方法展开。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python进阶</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路19-设置应用程序的样式并对其进行部署</title>
    <url>/2018/04/27/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF19-%E8%AE%BE%E7%BD%AE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%A0%B7%E5%BC%8F%E5%B9%B6%E5%AF%B9%E5%85%B6%E8%BF%9B%E8%A1%8C%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<blockquote>
<p>《Python编程：从入门到实践》笔记。 本篇将对Django项目做最后的完善。本篇也是这本书的最后一篇。</p>
</blockquote>
<a id="more"></a>
<h1 id="前言">1. 前言</h1>
<p>在本篇中，我们将：</p>
<ul>
<li>使用Bootstrap库设置样式；</li>
<li>把项目部署到Heroku上。</li>
</ul>
<h1 id="设置项目学习笔记的样式">2. 设置项目“学习笔记”的样式</h1>
<p>之前关注的都是项目的功能，现在来为项目添加样式。</p>
<p>我们将使用<code>django-bootstrap3</code>来设置样式。首先请在虚拟环境中安装这个第三方库。</p>
<p>然后像之前在项目<code>settings.py</code>中注册我们自己编写的APP一样，注册<code>bootstrap3</code>这个应用程序。</p>
<p>还需要包含<code>django-bootstrap3</code>包含<code>jQuery</code>，在<code>settings.py</code>末尾添加如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">-- snip --</span><br><span class="line">LOGIN_URL = <span class="string">'/users/login/'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># django-bootstrap3的设置</span></span><br><span class="line">BOOTSTRAP3 = &#123;</span><br><span class="line">    <span class="string">"include_jquery"</span>: <span class="literal">True</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="修改base.html">2.1 修改base.html</h2>
<h3 id="定义html头部">2.1.1 定义HTML头部</h3>
<p>实现访问项目的每个页面时，浏览器标题都现实这个网站的名称。另外还添加了一些在模板中使用Bootstrap所需的信息。删除<code>base.html</code>的全部代码，并添加如下代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% load bootstrap3 %&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"x-ua-compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Learning Log<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  &#123;% bootstrap_css %&#125;</span><br><span class="line">  &#123;% bootstrap_javascript %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>第12行使用了<code>django-bootstrap3</code>的一个自定义模板标签，它让Django包含所有的Bootstrap样式文件。第13行启用可能在页面中使用的所有交互式行为，如可折叠的导航栏。</p>
<h3 id="定义导航栏">2.1.2 定义导航栏</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">-- snip --</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Static navbar --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"navbar navbar-default navbar-static-top"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"navbar-header"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"navbar-toggle collapsed"</span> <span class="attr">data-toggle</span>=<span class="string">"collapse"</span> </span></span><br><span class="line"><span class="tag">              <span class="attr">data-target</span>=<span class="string">"#navbar"</span> <span class="attr">aria-expanded</span>=<span class="string">"false"</span> <span class="attr">aria-controls</span>=<span class="string">"navbar"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"navbar-brand"</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'learning_logs:index' %&#125;"</span>&gt;</span>Learning Log<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"navbar"</span> <span class="attr">class</span>=<span class="string">"navbar-collapse collapse"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"nav navbar-nav"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'learning_logs:topics' %&#125;"</span>&gt;</span>Topics<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"nav navbar-nav navbar-right"</span>&gt;</span></span><br><span class="line">        &#123;% if user.is_authenticated %&#125;</span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span>&gt;</span>Hello, &#123;&#123; user.username &#125;&#125;.<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'users:logout' %&#125;"</span>&gt;</span>log out<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        &#123;% else %&#125;</span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'users:register' %&#125;"</span>&gt;</span>register<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'users:login' %&#125;"</span>&gt;</span>log in<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        &#123;% endif %&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="comment">&lt;!--/.nav-collapse --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>navbar</code>、<code>navbar-default</code>和<code>navbar-static-top</code>是三个选择器，在<code>nav</code>块中的内容将根据选择器在Bootstrap中定义的样式规则来设置样式（额，<code>html</code>中选择器的概念有点忘了，不过不要紧，我们的任务并不是研究HTML）。在第20-28行中是我们之前编写的判断语句，只不过被放在了<code>ul</code>块中，并且设置了一个选择器<code>navbar-right</code>。</p>
<h3 id="定义页面的主要部分">2.1.3 定义页面的主要部分</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">-- snip --</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">-- snip --</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"page-header"</span>&gt;</span></span><br><span class="line">    &#123;% block header %&#125;&#123;% endblock %&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% block content %&#125;&#123;% endblock %&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span> <span class="comment">&lt;!-- /container --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这部分包含一个<code>div</code>块，该块的<code>class</code>属性是<code>container</code>（容器），容器中包含两个元素：一个新增的<code>header</code>块和之前用到的<code>content</code>块。<code>header</code>块的内容告诉用户页面包含哪些信息以及用户可以在页面上执行哪些操作，其<code>class</code>属性值<code>page-header</code>将一系列样式应用于这个块。<code>base.html</code>的修改到此为止。</p>
<h2 id="使用jumbotron设置主页样式">2.2 使用jumbotron设置主页样式</h2>
<p>下面使用新定义的<code>header</code>块及另一个名为<code>jumbotron</code>的Bootstrap元素修改主页。<code>jumbotron</code>元素是一个大框，通常用于在主页中呈现项目的简要描述，修改<code>index.html</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% extends "learning_logs/base.html" %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block header %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"jumbotron"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Track your learning.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% endblock header %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'users:register' %&#125;"</span>&gt;</span>Register an account<span class="tag">&lt;/<span class="name">a</span>&gt;</span>to make your own</span><br><span class="line">    Learning Log, and list the topics you're learning about.</span><br><span class="line">  <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span></span><br><span class="line">    Whenever you learn something new about a topic, make an entry summarizing</span><br><span class="line">    what you've learned.</span><br><span class="line">  <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">&#123;% endblock content %&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>header</code>块中，我们用一个<code>jumbotron</code>元素来修饰一条简短的标语，让首次访问者大致知道网站功能。随后再<code>content</code>块中描述了两种主要操作。下图是实际效果：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828441/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF19-%E8%AE%BE%E7%BD%AE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%A0%B7%E5%BC%8F%E5%B9%B6%E5%AF%B9%E5%85%B6%E8%BF%9B%E8%A1%8C%E9%83%A8%E7%BD%B2/1524795383797.png" /></p>
<h2 id="设置登录页面样式">2.3 设置登录页面样式</h2>
<p>现在的代码改进了登录页面的整体外观（因为修改了<code>base.html</code>），现在来改进登录表单，修改<code>login.html</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% extends "learning_logs/base.html" %&#125;</span><br><span class="line">&#123;% load bootstrap3 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block header %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Log in to your account.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">&#123;% endblock header %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">"form"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">action</span>=<span class="string">"&#123;% url 'users:login' %&#125;"</span>&gt;</span></span><br><span class="line">    &#123;% csrf_token %&#125;</span><br><span class="line">    &#123;% bootstrap_form form %&#125;</span><br><span class="line"></span><br><span class="line">    &#123;% buttons %&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-primary"</span> <span class="attr">name</span>=<span class="string">"submit"</span>&gt;</span>log in<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    &#123;% endbuttons %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"next"</span> <span class="attr">value</span>=<span class="string">"&#123;% url 'learning_logs:index' %&#125;"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;% endblock content %&#125;</span><br></pre></td></tr></table></figure>
<p>第2行代码加载了<code>bootstrap3</code>模板标签；</p>
<p><code>header</code>块描述这个页面时做什么的；</p>
<p>删除了之前的<code>if form.errors</code>代码块，因为<code>django-bootstrap3</code>位自动管理表单错误；</p>
<p><code>form</code>块中添加了属性<code>“form"</code>，然后使用标签模板<code>bootstrap_form</code>来显示表单，这个标签替换掉了之前的<code>form.as_p</code>；</p>
<p><code>button</code>也使用Bootstrap样式进行了替换，下面是实际效果图：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828441/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF19-%E8%AE%BE%E7%BD%AE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%A0%B7%E5%BC%8F%E5%B9%B6%E5%AF%B9%E5%85%B6%E8%BF%9B%E8%A1%8C%E9%83%A8%E7%BD%B2/1524796050010.png" /></p>
<h2 id="设置new_topic.html页面样式">2.4 设置new_topic.html页面样式</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% extends "learning_logs/base.html" %&#125;</span><br><span class="line">&#123;% load bootstrap3 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block header %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Add a new topic:<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">&#123;% endblock header %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">"form"</span> <span class="attr">action</span>=<span class="string">"&#123;% url 'learning_logs:new_topic' %&#125;"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    &#123;% csrf_token %&#125;</span><br><span class="line">    &#123;% bootstrap_form %&#125;</span><br><span class="line"></span><br><span class="line">    &#123;% buttons %&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-primary"</span> <span class="attr">name</span>=<span class="string">"submit"</span>&gt;</span>add topic<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    &#123;% endbuttons %&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;% endblock content %&#125;</span><br></pre></td></tr></table></figure>
<p>上面的修改大多都类似于对<code>login.html</code>的修改。</p>
<h2 id="设置topics.html页面样式">2.5 设置topics.html页面样式</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% extends "learning_logs/base.html" %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block header %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Topics<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&#123;% endblock header %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    &#123;% for topic in topics %&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'learning_logs:topic' topic.id %&#125;"</span>&gt;</span>&#123;&#123; topic &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    &#123;% empty %&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>No topics have been added yet.<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'learning_logs:new_topic' %&#125;"</span>&gt;</span>Add a new topic:<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">&#123;% endblock content %&#125;</span><br></pre></td></tr></table></figure>
<p>这里并没有加载<code>bootstrap3</code>，因为该文件中并没有使用任何<code>bootstrap3</code>自定义标签。</p>
<h2 id="设置topic.html中条目的样式">2.6 设置topic.html中条目的样式</h2>
<p><code>topic</code>页面包含的内容比其他大部分页面都多，所以样式设置要多一些，我们将使用Bootstrap面板（<code>panel</code>）来突出每个条目。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% extends "learning_logs/base.html" %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block header %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; topic &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">&#123;% endblock header %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'learning_logs:new_entry' topic.id %&#125;"</span>&gt;</span>add new entry<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  &#123;% for entry in entries %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"panel panel-default"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"panel-heading"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span></span><br><span class="line">          &#123;&#123; entry.date_added|date:"M d, Y H:i" &#125;&#125;</span><br><span class="line">          <span class="tag">&lt;<span class="name">small</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'learning_logs:edit_entry' entry.id %&#125;"</span>&gt;</span>edit</span><br><span class="line">              entry<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">small</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"panel-body"</span>&gt;</span></span><br><span class="line">        &#123;&#123; entry.text|linebreaks &#125;&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span> <span class="comment">&lt;!-- panel --&gt;</span></span><br><span class="line">  &#123;% empty %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">      There are no entries for this topic yet.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  &#123;% endfor %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endblock content %&#125;</span><br></pre></td></tr></table></figure>
<p>只修改了样式，并没有修改Django代码。下图是实际效果：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828441/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF19-%E8%AE%BE%E7%BD%AE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%A0%B7%E5%BC%8F%E5%B9%B6%E5%AF%B9%E5%85%B6%E8%BF%9B%E8%A1%8C%E9%83%A8%E7%BD%B2/1524797184599.png" /></p>
<p>至此已完成了对页面的修改。</p>
<h1 id="部署学习笔记">3. 部署“学习笔记”</h1>
<p>由于对Web应用不是很了解，笔者查阅资料现在大多用Apache和Nginx来部署Web项目，但本书使用Heroku来部署我们的Web项目。</p>
<p>请到Heroku的官网注册账号，它提供免费使用服务，并到https://toolbelt.heroku.com/ 下载命令行工具。</p>
<p>同时，还需要在Django项目所在的虚拟环境中安装一些额外的包：</p>
<p><code>dj-database-url</code>：帮助Django与Heroku使用的数据库进行通信；</p>
<p><code>dj-static</code>，<code>static3</code>：帮助Django正确管理静态文件（静态文件包括样式规则和JavaScript文件）；</p>
<p><code>gunicorn</code>：一个服务器软件，能够在在线环境中支持应用程序提供的服务。</p>
<h2 id="创建包含包列表的文件requirements.txt">3.1 创建包含包列表的文件requirements.txt</h2>
<p>Heroku需要知道我们的项目依赖于哪些包，使用<code>pip</code>命令来生成这个文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">(venv)learning_log&gt;</span><span class="bash">pip freeze &gt; requirements.txt</span></span><br></pre></td></tr></table></figure>
<p>下面是这个文件所包含的内容（“如果是Windows系统，看到的内容可能不全”——这是书中提示，然而这里的内容还比书中多了一个<code>pytz</code>）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dj-database-url&#x3D;&#x3D;0.5.0</span><br><span class="line">dj-static&#x3D;&#x3D;0.0.6</span><br><span class="line">Django&#x3D;&#x3D;2.0.4</span><br><span class="line">django-bootstrap3&#x3D;&#x3D;9.1.0</span><br><span class="line">gunicorn&#x3D;&#x3D;19.7.1</span><br><span class="line">pytz&#x3D;&#x3D;2018.4</span><br><span class="line">static3&#x3D;&#x3D;0.7.0</span><br></pre></td></tr></table></figure>
<p>在部署项目时，Heroku将创建一个环境，并根据这个文件安装其中的所有包。也因此，项目部署到Heroku后，行为将与它在本地系统上一样。</p>
<p>还需要在包列表中添加<code>psycopg2</code>，它帮助Heroku管理活动数据库。需在<code>requirements.txt</code>最后一行添加如下代码：<code>psycopg2&gt;=2.6.1</code>。该语句表示，有新版则装最新版，没有的话最低安装2.6.1版本。</p>
<h2 id="确定python版本">3.2 确定Python版本</h2>
<p>如果没有指定Python版本，Heroku将使用其当前的Python默认版本。下面来确保Heroku使用我们所使用的版本。如果不知道使用的python的版本，请在项目所在虚拟环境中执行<code>python --version</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">(venv)learning_log&gt;</span><span class="bash">python --version</span></span><br><span class="line">Python 3.6.4</span><br></pre></td></tr></table></figure>
<p>再在<code>manage.py</code>所在的文件夹中新建一个名为<code>runtime.txt</code>的文件，输入Python的版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python-3.6.4</span><br></pre></td></tr></table></figure>
<p>注意：单词小写，中间有一个连字符！</p>
<h2 id="为部署到heroku而修改settings.py">3.3 为部署到Heroku而修改settings.py</h2>
<p>在<code>settings.py</code>末尾添加一个片段，指定一些Heroku环境设置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">-- snip --</span><br><span class="line"><span class="comment"># 书中的判断语句是 if os.getcwd() == '/app': </span></span><br><span class="line"><span class="comment"># 现在估计是Heroku升级了，改为了下面的语句，否则待会儿部署的时候会出错</span></span><br><span class="line"><span class="keyword">if</span> os.environ[<span class="string">'HOME'</span>] == <span class="string">"/app"</span>:</span><br><span class="line">    <span class="keyword">import</span> dj_database_url</span><br><span class="line"></span><br><span class="line">    DATABASES = &#123;</span><br><span class="line">        <span class="string">"default"</span>: dj_database_url.config(default=<span class="string">"postgres://localhost"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 让request.is_secure()承认X-Forwarded-Proto头</span></span><br><span class="line">    SECURE_PROXY_HEADER = (<span class="string">"HTTP_X_FORWARDED_PROTO"</span>, <span class="string">"https"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 支持所有的主机头（host header）</span></span><br><span class="line">    ALLOWED_HOSTS = [<span class="string">"*"</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 静态资产配置</span></span><br><span class="line">    BASE_DIR = os.path.dirname(os.path.abspath(__file__))</span><br><span class="line">    <span class="comment"># 书中设置是这样的： STATIC_ROOT = "staticfiles"</span></span><br><span class="line">    STATIC_ROOT = os.path.join(BASE_DIR, <span class="string">'static'</span>)</span><br><span class="line">    STATICFILES_DIRS = (</span><br><span class="line">        os.path.join(BASE_DIR, <span class="string">"static"</span>),</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p>第2行中，使用<code>getcwd()</code>函数获取当前的工作目录，在Heroku中，这个目录总<code>/app</code>。在本地部署中，这个目录通常是项目文件的名称。这个if测试确保仅当项目被部署到Heroku时才运行这个代码块。<strong>这种结构让我们能够将统一配置文件用于本地开发环境和在线服务器。</strong></p>
<p>在第3行，导入了<code>dj_database_url</code>，用于在Heroku上配置服务器。Heroku使用<code>PostgreSQL</code>（也叫<code>Postgres</code>，一种比<code>SQLite</code>更高级的数据库），这些配置使得项目在Heroku上使用该数据库。</p>
<p>其他配置作用分别如下：支持HTTPS请求（第10行）；让Django能够使用Heroku的URL来提供项目支持的服务（第13行）；设置项目，使其能够在Heroku上正确地提供静态文件（第16-20行）。</p>
<h2 id="创建启动进程的procfile">3.4 创建启动进程的Procfile</h2>
<p><code>Procfile</code>告诉Heroku启动那些进程，以便能够正确地提供项目支持的服务。这个文件只包含一行，文件名为<code>Procfile</code>，不带扩展名，保存到项目根目录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">web: gunicorn learning_log.wsgi --log-file -</span><br></pre></td></tr></table></figure>
<p>这段代码让Heroku将<code>gunicorn</code>用过服务器，并使用<code>learning_log/wsgi.py</code>中的设置来启动应用程序。标志<code>log-file</code>告诉Heroku应将哪些类型的时间写入日志。</p>
<h2 id="为部署到heroku而修改wsgi.py">3.5 为部署到Heroku而修改wsgi.py</h2>
<p>因为Heroku需要的设置与目前一直使用的设置稍有不同，所以还需要修改<code>wsgi.py</code>文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.core.wsgi <span class="keyword">import</span> get_wsgi_application</span><br><span class="line"><span class="keyword">from</span> dj_static <span class="keyword">import</span> Cling</span><br><span class="line"></span><br><span class="line">os.environ.setdefault(<span class="string">"DJANGO_SETTINGS_MODULE"</span>, <span class="string">"learning_log.settings"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 原代码是 application = get_wsgi_application()</span></span><br><span class="line">application = Cling(get_wsgi_application())</span><br></pre></td></tr></table></figure>
<p>注意，这里只有第4,9行是添加的，其余都是自带的。</p>
<h2 id="创建用于存储静态文件的目录">3.6 创建用于存储静态文件的目录</h2>
<p>在Heroku上，Django搜集所有的静态文件，并将它们放在一个地方，以便高效管理。我们需要手动创建这样一个文件夹。在项目文件夹<code>learning_log</code>中，也有一个名为<code>learning_log</code>的子文件夹，在这个子文件夹中，新建一个名为<code>static</code>的文件夹，即这个文件夹的路径为：<code>learning_log/learning_log/static/</code>。由于项目被推送到Heroku时，它将不包含空文件夹，所以，在<code>static</code>文件夹中还需要创建一个占位文件<code>placeholder.txt</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This file ensures that learning_log&#x2F;static&#x2F; will be added to the project.</span><br><span class="line">Django will collect static files and place them in learning_log&#x2F;static&#x2F;.</span><br></pre></td></tr></table></figure>
<h2 id="在本地使用gunicorn服务器">3.7 在本地使用gunicorn服务器</h2>
<p>如果你使用的是Linux或OS X，可在部署到Heroku前尝试在本地使用<code>gunicorn</code>服务器。为此，在虚拟环境中执行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">(ll_env)learning_log$</span><span class="bash"> heroku <span class="built_in">local</span></span></span><br><span class="line">Installing Heroku Toolbelt v4... done</span><br><span class="line">-- snip --</span><br><span class="line">forego | starting web.1 on port 5000</span><br><span class="line">web.1 | [2018-04-27 14:00:00 -0800] [12875] [INFO] Starting gunicorn 19.3.0</span><br><span class="line">-- snip --</span><br></pre></td></tr></table></figure>
<p>但如果使用的是Windows，请跳过这个步骤（笔者用的是Windows，所以上面的输出是从书上照搬过来的）。</p>
<h2 id="使用git跟踪项目文件">3.8 使用Git跟踪项目文件</h2>
<p>Heroku Toolbelt包含Git，这里不再介绍Git怎么安装。</p>
<p>Git跟踪谁修改了项目，即便项目由一个人开发。为了实现跟踪，需要提供用户名和email，但对于联系项目，这俩都可以随便起：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">(ll_env)learning_log$</span><span class="bash"> git config --global user.name <span class="string">"example"</span></span></span><br><span class="line"><span class="meta">(ll_env)learning_log$</span><span class="bash"> git config --global user.email <span class="string">"test@example.com"</span></span></span><br></pre></td></tr></table></figure>
<p>我们无需让Git跟踪项目中的每个文件，因此将让Git忽略一些文件。在项目根目录下创建一个名为 <code>.gitignore</code> 的文件，注意前面有一个实心句点，不含扩展名。在文件中输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ll_env&#x2F;</span><br><span class="line">__pycache__&#x2F;</span><br><span class="line">*.sqlite3</span><br></pre></td></tr></table></figure>
<p>忽略<code>ll_env</code>目录是因为随时都可以重新创建它；忽略<code>__pycache__</code>是因为这个目录包含了Django运行<code>.py</code>文件时自动创建的<code>.pyc</code>文件，目前都是本地数据（如果使用的是python2.7，请将<code>__pycache__</code>替换为<code>*.pyc</code>）；没有跟踪本地数据库是因为如果你在服务器上使用的是<code>SQLite</code>，当你将项目推送到服务器时，可能会不小心把服务器上的数据给覆盖掉。</p>
<p>最后，我们提交项目，而在提交之前需要为我们的项目初始化一个Git仓库，将所有必要的文件都加入到这个仓库中，并提交项目的初始状态，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(ll_env) learning_log&gt;git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> E:/Code/Python/learning_log/.git/</span><br><span class="line"></span><br><span class="line">(ll_env) learning_log&gt;git add .</span><br><span class="line"></span><br><span class="line">(ll_env) learning_log&gt;git commit -am <span class="string">"Ready for deployment to heroku."</span></span><br><span class="line">[master (root-commit) 4109cbc] Ready <span class="keyword">for</span> deployment to heroku.</span><br><span class="line"> 39 files changed, 745 insertions(+)</span><br><span class="line"> create mode 100644 .gitignore</span><br><span class="line"> -- snip --</span><br><span class="line"> create mode 100644 users/views.py</span><br><span class="line"></span><br><span class="line">(ll_env) learning_log&gt;git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>
<p>第一个命令在“学习笔记”所在的目录中初始化一个空仓库；第二个命令（最后有个句点！）将未被忽略的文件都添加到这个仓库中；第三个命令中的标志 <code>-a</code> 让Git在这个提交中包含所有修改过的文件，而标志 <code>-m</code> 让Git记录一条日志消息；第四个命令的输出表明当前位于分支<code>master</code>中，而工作目录是干净（<code>clean</code>）的，每当要将项目推送到Heroku时，都希望看到这个状态。</p>
<h2 id="推送到heroku">3.9 推送到Heroku</h2>
<p>现在开始推送项目。在项目的虚拟环境中执行下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(ll_env) learning_log&gt;heroku login</span><br><span class="line">Enter your Heroku credentials:</span><br><span class="line">Email: kevinwen701@gmail.com</span><br><span class="line">Password: ************</span><br><span class="line">Logged <span class="keyword">in</span> as kevinwen701@gmail.com</span><br><span class="line"></span><br><span class="line">(ll_env) learning_log&gt;heroku create</span><br><span class="line">Creating app... <span class="keyword">done</span>, ⬢ pure-anchorage-27981</span><br><span class="line">https://pure-anchorage-27981.herokuapp.com/ | https://git.heroku.com/pure-anchorage-27981.git</span><br><span class="line"></span><br><span class="line">(ll_env) learning_log&gt;git push heroku master</span><br><span class="line">Counting objects: 46, <span class="keyword">done</span>.</span><br><span class="line">-- snip --</span><br><span class="line">remote: Verifying deploy... <span class="keyword">done</span>.</span><br><span class="line">To https://git.heroku.com/pure-anchorage-27981.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br></pre></td></tr></table></figure>
<p>首先，在终端会话中，使用你在Heroku官网创建的账号登陆，然后让Heroku创建一个空项目。Heroku生成的项目名由两个单词和一个数字组成（可以修改）。然后我们让Git将项目分值<code>master</code>推送到Heroku刚才建立的仓库中；Heroku随后使用这些文件在其服务器上创建项目。最后输出信息还给出了访问这个项目的URL。</p>
<p>大概上述命令执行完后，项目便部署好了，但还未对其做全面的配置。为核实正确地启动了服务器进程，请执行命令<code>heroku ps</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(ll_env) learning_log&gt;heroku ps</span><br><span class="line">Free dyno hours quota remaining this month: 550h 0m (100%)</span><br><span class="line">For more information on dyno sleeping and how to upgrade, see:</span><br><span class="line">https://devcenter.heroku.com/articles/dyno-sleeping</span><br><span class="line"></span><br><span class="line">=== web (Free): gunicorn learning_log.wsgi --<span class="built_in">log</span>-file - (1)</span><br><span class="line">web.1: up 2018/04/27 16:36:42 +0800 (~ 6m ago)</span><br></pre></td></tr></table></figure>
<p>当执行了这条命令后，输出指出项目还可在多长时间内处于活动状态。当超过这个时间后，将显示标准的服务器错误页面，而稍后我们将设置这个错误页面。在倒数第二行，我们发现启动了<code>Procfile</code>指定的进程。</p>
<p>现在，我们可以使用命令<code>heroku open</code>在浏览器中打开这个APP了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(ll_env) learning_log&gt;heroku open</span><br></pre></td></tr></table></figure>
<p>它将自动打开浏览器，显示项目的主页。</p>
<h2 id="在heroku上建立数据库">3.10 在Heroku上建立数据库</h2>
<p>要对Heroku项目执行Django和Python命令，可使用命令<code>heroku run</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(ll_env) learning_log&gt;heroku run python manage.py migrate</span><br><span class="line">Running python manage.py migrate on ⬢ pure-anchorage-27981... up, run.9204 (Free)</span><br><span class="line">-- snip --</span><br><span class="line">Operations to perform:</span><br><span class="line">  Apply all migrations: admin, auth, contenttypes, learning_logs, sessions</span><br><span class="line">Running migrations:</span><br><span class="line">  -- snip --</span><br><span class="line">  Applying learning_logs.0003_topic_owner... OK</span><br><span class="line">  Applying sessions.0001_initial... OK</span><br></pre></td></tr></table></figure>
<p>当执行上述命令后，Heroku创建一个终端会话来执行命令<code>migrate</code>（第2行）。从第6行起，Django应用默认迁移以及我们在开发“学习笔记”期间生成的迁移。</p>
<p>现在可以像在本地系统上一样使用它。然而其中并没有任何数据，因为之前的测试数据并没有复制到服务器中，而且也不建议将测试数据复制到服务器中。</p>
<h2 id="改进heroku部署">3.11 改进Heroku部署</h2>
<h3 id="在heroku上创建超级用户">3.11.1 在Heroku上创建超级用户</h3>
<p>从上面的命令可以看出，我们可以使用<code>heroku run</code>来执行一次性命令，但可以这样执行命令：在连接到了Heroku服务器的情况下，使用命令<code>heroku run bash</code>来打开Bash终端会话。我们将使用Bash终端会话来创建超级用户，以便能够访问在线应用程序的管理网站：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(ll_env) learning_log&gt;heroku run bash</span><br><span class="line">Running bash on ⬢ pure-anchorage-27981... up, run.8093 (Free)</span><br><span class="line">~ $ ls</span><br><span class="line">learning_log  learning_logs  manage.py  Procfile  requirements.txt  runtime.txt  users</span><br><span class="line">~ $ python manage.py createsuperuser</span><br><span class="line">/app/.heroku/python/lib/python3.6/site-packages/psycopg2/__init__.py:144: UserWarning:</span><br><span class="line">The psycopg2 wheel package will be renamed from release 2.8; <span class="keyword">in</span> order to keep installing</span><br><span class="line">from binary please use <span class="string">"pip install psycopg2-binary"</span> instead. For details see: </span><br><span class="line">&lt;http://initd.org/psycopg/docs/install.html<span class="comment">#binary-install-from-pypi&gt;.</span></span><br><span class="line">  <span class="string">""</span><span class="string">")</span></span><br><span class="line"><span class="string">Username (leave blank to use 'u10229'): ll_admin</span></span><br><span class="line"><span class="string">Email address:</span></span><br><span class="line"><span class="string">Password:</span></span><br><span class="line"><span class="string">Password (again):</span></span><br><span class="line"><span class="string">Superuser created successfully.</span></span><br><span class="line"><span class="string">~ $ exit</span></span><br><span class="line"><span class="string">exit</span></span><br><span class="line"><span class="string">(venv) learning_log&gt;</span></span><br></pre></td></tr></table></figure>
<p>进入Bash后，我们首先执行了<code>ls</code>命令，以查看服务器上有哪些文件和目录，发现和本地系统相同。然后我们执行了常见超级用户的命令，执行过程和之前创建超级用户一样。现在可以通过在APP的URL后面加<code>/admin/</code>来登陆管理网站了。</p>
<h3 id="在heroku上创建对用户友好的url">3.11.2 在Heroku上创建对用户友好的URL</h3>
<p>由于在服务器上我们的项目名不是<code>learning_log</code>，而是其他自动生成的名字，为此，我们使用一个命令来重命名这个APP：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(ll_env) learning_log&gt;heroku apps:rename kevins-learning-log</span><br><span class="line">Renaming pure-anchorage-27981 to kevins-learning-log... <span class="keyword">done</span></span><br><span class="line">https://kevins-learning-log.herokuapp.com/ | https://git.heroku.com/kevins-learning-log.git</span><br><span class="line">Git remote heroku updated</span><br><span class="line"> !    Don<span class="string">'t forget to update git remotes for all other local checkouts of the app.</span></span><br></pre></td></tr></table></figure>
<h2 id="确保项目的安全">3.12 确保项目的安全</h2>
<p>当前这个项目存在一个严重的安全问题：<code>settings.py</code>中包含设置<code>DEBUG=True</code>，它在发生错误时显示调试信息。开发项目时，Django的错误页面向你显示了重要的调试信息，如果将项目部署到服务器后依然保留这个设置，讲给攻击者提供大量可供利用的信息。我们还需要确保任何人都无法看到这些信息，也不能冒充项目托管网站来重定向请求。</p>
<p>下面修改<code>settings.py</code>文件，以让我们能够在本地看到错误信息，但部署到服务器后不显示任何错误信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">-- snip --</span><br><span class="line"><span class="keyword">if</span> os.environ[<span class="string">"HOME"</span>] == <span class="string">"/app"</span>:</span><br><span class="line">    -- snip --</span><br><span class="line">    <span class="comment"># 只允许Heroku托管这个项目</span></span><br><span class="line">    ALLOWED_HOSTS = [<span class="string">"kevins-learning-log.herokuapp.com"</span>]</span><br><span class="line">    </span><br><span class="line">    DEBUG = <span class="literal">False</span></span><br><span class="line">    -- snip --</span><br></pre></td></tr></table></figure>
<p>然后我们提交并推送修改。先将修改提交到Git仓库，在推送到Heroku：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(venv) E:\Code\Python\learning_log&gt;git commit -am <span class="string">"Set DEBUG=False for heroku."</span></span><br><span class="line">[master 563b175] Set DEBUG=False <span class="keyword">for</span> heroku.</span><br><span class="line"> 1 file changed, 6 insertions(+), 4 deletions(-)</span><br><span class="line"></span><br><span class="line">(venv) E:\Code\Python\learning_log&gt;git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line">(venv) E:\Code\Python\learning_log&gt;git push heroku master</span><br><span class="line">-- snip --</span><br><span class="line">remote: -----&gt; Python app detected</span><br><span class="line">remote: -----&gt; Installing requirements with pip</span><br><span class="line">-- snip --</span><br><span class="line">remote: -----&gt; Launching...</span><br><span class="line">remote:        Released v7</span><br><span class="line">remote:        https://kevins-learning-log.herokuapp.com/ deployed to Heroku</span><br><span class="line">remote:</span><br><span class="line">remote: Verifying deploy... <span class="keyword">done</span>.</span><br><span class="line">To https://git.heroku.com/kevins-learning-log.git</span><br><span class="line">   9bc1c2d..563b175  master -&gt; master</span><br></pre></td></tr></table></figure>
<p>Heroku发现仓库发生了变化，因此重建了项目，确保所有的修改都已生效。它不会重建数据库，因此本次无需执行命令<code>migrate</code>。</p>
<p>现在如果访问未定义的扩展将会看到一个标准的错误页面，它不包含任何关于项目的具体信息。</p>
<h2 id="创建自定义错误页面">3.13 创建自定义错误页面</h2>
<p>编写两个风格与我们项目相符的404和500错误页面模板。这些模板必须放在根模板目录中。为此，在文件夹<code>leraning_log/learning_log</code>中新建一个文件夹<code>templates</code>，再在这个文件夹中新建一个<code>404.html</code>文件，并输入如下内容：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% extends "learning_logs/base.html" %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block header %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>The item you requested is not available.(404)<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">&#123;% endblock header %&#125;</span><br></pre></td></tr></table></figure>
<p>再创建一个名为<code>500.html</code>的文件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% extends "learning_logs/base.html" %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block header %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>There has been an internal error. (500)<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">&#123;% endblock header %&#125;</span><br></pre></td></tr></table></figure>
<p>这些新文件要求对<code>settings.py</code>做细微的修改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">-- snip --</span><br><span class="line">TEMPLATES = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'BACKEND'</span>: <span class="string">'django.template.backends.django.DjangoTemplates'</span>,</span><br><span class="line">        <span class="string">'DIRS'</span>: [os.path.join(BASE_DIR, <span class="string">'learning_log/templates'</span>)],</span><br><span class="line">        <span class="string">'APP_DIRS'</span>: <span class="literal">True</span>,</span><br><span class="line">        -- snip --</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br><span class="line">-- snip --</span><br></pre></td></tr></table></figure>
<p>在将修改推送到服务器之前，可以在本地查看错误页面时什么样的，不过得先在本地设置<code>DEBUG=False</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># settings.py文件</span></span><br><span class="line"><span class="comment"># SECURITY WARNING: don't run with debug turned on in production!</span></span><br><span class="line">DEBUG = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">ALLOWED_HOSTS = [<span class="string">"localhost"</span>]</span><br></pre></td></tr></table></figure>
<p>现在本地访问不存在的页面时将得到我们自定义的错误页面。</p>
<p>最后，想之前一样，将修改推送到服务器，代码不再演示，注意为推送添加一条简短的日志信息。</p>
<p>现在，如果用户手工请求不存在的主题或条目将导致500错误。Django尝试渲染请求的页面，但没有足够的信息来完成这项任务，进而引发<code>500</code>错误。对于这种情况，将其视为<code>404</code>错误更合适，为此可使用Django快捷函数<code>get_object_or_404()</code>。这个函数尝试从数据库获取请求的对象，当对象不存在时，引发<code>404</code>错误。我们在<code>views.py</code>中导入这个函数，并用它替换函数<code>get()</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render, get_object_or_404</span><br><span class="line"><span class="meta">@login_required</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topic</span><span class="params">(request, topic_id)</span>:</span></span><br><span class="line">    <span class="string">"""显示单个主题及其所有的条目"""</span></span><br><span class="line">    topic = get_object_or_404(Topic, id=topic_id)</span><br><span class="line">    -- snip --</span><br></pre></td></tr></table></figure>
<p>再次提交并推送修改。</p>
<h2 id="部署总结">3.14 部署总结</h2>
<p>从前面这些例子可看出，开发与部署的过程如下：</p>
<p>①修改项目。如果创建了新文件，使用命令 <code>git add</code>. （最后有个句点！）将它们加到Git仓库中。如果要迁移数据库，也需要执行该命令，因为每个迁移都生成了新的迁移文件。</p>
<p>②执行 <code>git commit -am "commit message"</code>，将修改提交到仓库。</p>
<p>③执行 <code>git push heroku master</code> 将修改推送到服务器。</p>
<p>④如果本地迁移了数据库，也需要迁移在线数据库，可以使用一次性命令 <code>heroku run python manage.py migrate</code> ，也可以使用 <code>heroku run bash</code>打开一个远程终端会话，再执行迁移。</p>
<h2 id="设置secret_key">3.15 设置SECRET_KEY</h2>
<p>Django根据<code>settings.py</code>中的<code>SECRET_KEY</code>来实现大量的安全协议。本项目中设置的<code>SECRET_KEY</code>对一个练习项目来说已经足够了，但是对于生产网站，请务必认真对待这个值。</p>
<h2 id="将项目从heroku删除">3.16 将项目从Heroku删除</h2>
<p>Heroku限制了你可免费托管的项目数，另外，我们也不希望自己的账户中塞满大量的联系项目。除了可以登录到Heroku，在应用程序的Settings中手动删除项目，也可以在命令行中执行如下命令删除项目：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(ll_env)learning_log$ heroku apps:destroy --app appname</span><br></pre></td></tr></table></figure>
<h1 id="总结">4. 总结</h1>
<p>现在大家可以访问这个网站 https://kevins-learning-log.herokuapp.com （笔者在免费期过期前不会删除这个网站）。本篇主要介绍了如何使用Bootstrap来设置网页的样式，并学习了如何将项目部署到Heroku的服务器上。至此，Python的Django入门已经完成，这本书也已经看完。暂时告一段落。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python基础</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路18-用户账户</title>
    <url>/2018/04/26/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF18-%E7%94%A8%E6%88%B7%E8%B4%A6%E6%88%B7/</url>
    <content><![CDATA[<blockquote>
<p>《Python编程：从入门到实践》笔记。 本篇记录如何创建用户注册系统，如何实现用户输入自己的数据。</p>
</blockquote>
<a id="more"></a>
<h1 id="前言">1. 前言</h1>
<p>在本篇中，我们将：</p>
<ul>
<li>创建一些表单，让用户能够添加主题和条目，以及编辑既有的条目；</li>
<li>实现一个身份验证系统。</li>
</ul>
<h1 id="让用户能够输入数据">2. 让用户能够输入数据</h1>
<p>先添加几个页面，让用户能够添加新主题，新条目以及编辑条目。</p>
<h2 id="添加新主题">2.1 添加新主题</h2>
<p>和之前创建网页的步骤一样：定义URL，编写视图函数，编写模板。主要区别是，这里需要一个包含表单的模块<code>forms.py</code></p>
<h3 id="创建forms.py模块">2.1.1 创建forms.py模块</h3>
<p>用户输入信息时，需要进行验证，确保提交的信息是正确的数据类型，且不是恶意信息，如中断服务器的代码。然后再处理信息，并保存到数据库中。当然，这些工作很多都由Django自动完成。</p>
<p>在<code>models.py</code>所在的目录中新建<code>forms.py</code>模块。创建表单的最简单方法是继承Django的<code>ModelForm</code>类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> forms</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Topic</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TopicForm</span><span class="params">(forms.ModelForm)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Topic</span><br><span class="line">        fields = [<span class="string">"text"</span>]</span><br><span class="line">        labels = &#123;<span class="string">"text"</span>: <span class="string">""</span>&#125;</span><br></pre></td></tr></table></figure>
<p>最简单的<code>ModelForm</code>版本只包含一个内嵌的<code>Meta</code>类，它告诉Django根据哪个模型创建表单，以及在表单中包含哪些字段。第6行，我们根据<code>Topic</code>创建一个表单，该表单只包含字段<code>text</code>（第7行），并不为该字段生成标签（第8行）。</p>
<h3 id="url模式new_topic">2.1.2 URL模式new_topic</h3>
<p>当用户要添加新主题时，将切换到http://localhost:8000/new_topic/ 。在<code>learning_logs/urls.py</code>中添加如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    -- snip --</span><br><span class="line">    <span class="comment"># 用于添加新主题的网站</span></span><br><span class="line">    path(<span class="string">"new_topic/"</span>, views.new_topic, name=<span class="string">"new_topic"</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="视图函数new_topic">2.1.3 视图函数new_topic()</h3>
<p>该函数需要处理两种情形：①刚进入<code>new_topic</code>网页，显示一个空表单；②对提交的表单数据进行处理，并将用户重定向到网页<code>topics</code>。修改<code>views.py</code>文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponseRedirect</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> reverse</span><br><span class="line"><span class="keyword">from</span> .forms <span class="keyword">import</span> TopicForm</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_topic</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">"""添加新主题"""</span></span><br><span class="line">    <span class="keyword">if</span> request.method != <span class="string">"POST"</span>:</span><br><span class="line">        <span class="comment"># 为提价数据：创建一个新表单</span></span><br><span class="line">        form = TopicForm()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># POST提交的数据，对数据进行处理</span></span><br><span class="line">        form = TopicForm(request.POST)</span><br><span class="line">        <span class="keyword">if</span> form.is_valid():</span><br><span class="line">            form.save()</span><br><span class="line">            <span class="comment"># 该类将用户重定向到网页topics，函数reverse()根据指定的URL模型确定URL</span></span><br><span class="line">            <span class="keyword">return</span> HttpResponseRedirect(reverse(<span class="string">"learning_logs:topics"</span>))</span><br><span class="line"></span><br><span class="line">    context = &#123;<span class="string">"form"</span>: form&#125;</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">"learning_logs/new_topic.html"</span>, context)</span><br></pre></td></tr></table></figure>
<h3 id="get请求和post请求">2.1.4 GET请求和POST请求</h3>
<p>创建Web应用程序时，将用到两种主要数据请求类型：<code>GET</code>请求和<code>POST</code>请求。从这俩英文单词可以看出，如果只从服务器读取数据页面，则使用<code>GET</code>请求；如果要提交用户填写的表单，通常使用<code>POST</code>请求。当然还有一些其他的请求类型，但这个项目中没有使用。本项目中处理表单都使用<code>POST</code>方法。</p>
<p><code>request.method</code>存储了请求的类型（第7行代码）。</p>
<p>当不是<code>POST</code>请求时，我们生成一个空表单传递给模板<code>new_topic.html</code>，然后返回给用户；当请求是<code>POST</code>时，我们从<code>request.POST</code>这个变量中获取用户提交的数据，并暂存到<code>form</code>变量中。</p>
<p>通过<code>is_valid()</code>方法验证表单数据是否满足要求：用户是否填写了所有必不可少的字段（表单字段默认都是必填的），且输入的数据与字段类型是否一致。当然这些验证都是Django自动进行的。如果表单有效，在通过<code>form</code>的<code>save()</code>方法存储到数据库，然后通过<code>reverse()</code>函数获取页面<code>topics</code>的URL，并将其传递给<code>HTTPResponseRedirect()</code>以重定向到<code>topics</code>页面。如果表单无效，把这些数据重新传回给用户。</p>
<h3 id="模板new_topic.html">2.1.5 模板new_topic.html</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% extends "learning_logs/base.html" %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Add a new topic:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"&#123;% url 'learning_logs:new_topic' %&#125;"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    &#123;% csrf_token %&#125;</span><br><span class="line">    &#123;&#123; form.as_p &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">name</span>=<span class="string">"submit"</span>&gt;</span>add topic<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">&#123;% endblock content %&#125;</span><br></pre></td></tr></table></figure>
<p>模板继承了<code>base.html</code>，因此其基本结构和项目中的其他页面相同。第6行中，参数<code>action</code>告诉<strong>服务器</strong>将提交的表单数据送到什么位置去处理，参数<code>method</code>让<strong>浏览器</strong>以<code>POST</code>请求的方式提交数据。</p>
<p>Django使用模板标签<code>csrf_token</code>（第7行）来防止攻击者利用表单获得对服务器未经授权的访问（跨站请求伪造）。</p>
<p>Django显示表单非常方便：只需要使用模板变量<code>form.as_p</code>，修饰符<code>as_p</code>让Django以段落格式渲染所有表单元素，这是一种整洁地显示表单的简单方法。</p>
<p>Django不自动创建提交表单的按钮，需自行创建。</p>
<h3 id="链接到页面new_topic">2.1.6 链接到页面new_topic</h3>
<p>在页面<code>topics.html</code>中添加一个到页面<code>new_topic</code>的链接：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% extends "learning_logs/base.html" %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">  -- snip --</span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'learning_logs:new_topic' %&#125;"</span>&gt;</span>Add a new topic:<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">&#123;% endblock content %&#125;</span><br></pre></td></tr></table></figure>
<h3 id="效果">2.1.7 效果</h3>
<p>以下是实际效果图：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828409/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF18-%E7%94%A8%E6%88%B7%E8%B4%A6%E6%88%B7/1524647465351.png" /></p>
<p>通过这个页面，随意添加几个主题，如下：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828409/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF18-%E7%94%A8%E6%88%B7%E8%B4%A6%E6%88%B7/1524647632084.png" /></p>
<h2 id="添加新条目">2.2 添加新条目</h2>
<p>和前面的步骤相似：创建条目表单，添加URL，添加视图，添加模板，链接到页面</p>
<h3 id="创建条目表单">2.2.1 创建条目表单</h3>
<p>创建一个与模型Entry相关联的表单，但这个表单的自定义程度比<code>TopicForm</code>要高些，依然是在刚才创建的<code>forms.py</code>中添加：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Topic, Entry</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EntryForm</span><span class="params">(forms.ModelForm)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Entry</span><br><span class="line">        fields = [<span class="string">"text"</span>]</span><br><span class="line">        labels = &#123;<span class="string">"text"</span>: <span class="string">""</span>&#125;</span><br><span class="line">        widgets = &#123;<span class="string">"text"</span>: forms.Textarea(attrs=&#123;<span class="string">"cols"</span>: <span class="number">80</span>&#125;)&#125;</span><br></pre></td></tr></table></figure>
<p>代码中定义了属性<code>widgets</code>。小部件（widget）是一个HTML表单元素，如单行文本框、多行文本框或下拉列表。通过设置属性widgets可以覆盖Django选择的默认小部件。通过Django的<code>forms.Textarea</code>定制字段<code>“text"</code>的输入小部件，将文本框的宽度设置为80列，而不是默认的40列。</p>
<h3 id="添加url模式new_entry">2.2.2 添加URL模式new_entry</h3>
<p>修改<code>learning_logs/urls.py</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    -- snip --</span><br><span class="line">    path(<span class="string">"new_entry/&lt;int:topic_id&gt;/"</span>, views.new_entry, name=<span class="string">"new_entry"</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>该URL模式与形式为http://localhost:8000/new_entry/topi_id/ 的URL匹配，其中<code>topic_id</code>是主题的ID。</p>
<h3 id="视图函数new_entry">2.2.3 视图函数new_entry()</h3>
<p>与函数<code>new_topic()</code>很像：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> .forms <span class="keyword">import</span> TopicForm, EntryForm</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_entry</span><span class="params">(request, topic_id)</span>:</span></span><br><span class="line">    <span class="string">"""在特定的主题中添加新条目"""</span></span><br><span class="line">    topic = Topic.objects.get(id=topic_id)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> request.method != <span class="string">"POST"</span>:</span><br><span class="line">        <span class="comment"># 未提交数据，创建一个空表单</span></span><br><span class="line">        form = EntryForm()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># POST提交的数据，对数据进行处理</span></span><br><span class="line">        form = EntryForm(data=request.POST)</span><br><span class="line">        <span class="keyword">if</span> form.is_valid():</span><br><span class="line">            new_entry = form.save(commit=<span class="literal">False</span>)</span><br><span class="line">            new_entry.topic = topic</span><br><span class="line">            new_entry.save()</span><br><span class="line">            <span class="keyword">return</span> HttpResponseRedirect(reverse(<span class="string">"learning_logs:topic"</span>, args=[topic_id]))</span><br><span class="line"></span><br><span class="line">    context = &#123;<span class="string">"topic"</span>: topic, <span class="string">"form"</span>: form&#125;</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">"learning_logs/new_entry.html"</span>, context)</span><br></pre></td></tr></table></figure>
<p><code>new_entry()</code>的定义包含形参<code>topic_id</code>，用于存储从URL中获得的值。</p>
<p>在调用<code>save()</code>时传递了参数<code>commit=False</code>（第14行），它让Django创建一个新的条目对象，但并不立刻提交数据库，而是暂时存储在变量<code>new_entry</code>中，待为这个新条目对象添加了属性<code>topic</code>之后再提交数据库。</p>
<p>在重定向时，<code>reverse()</code>函数中传递了两个参数，URL模式的名称以及列表<code>args</code>，<code>args</code>包含要包含在URL中的所有参数。</p>
<h3 id="模板new_entry.html">2.2.4 模板new_entry.html</h3>
<p>类似于<code>new_topic</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% extends "learning_logs/base.html" %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'learning_logs:topic' topic.id %&#125;"</span>&gt;</span>&#123;&#123; topic &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Add a new entry:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"&#123;% url 'learning_logs:new_entry' topic.id %&#125;"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    &#123;% csrf_token %&#125;</span><br><span class="line">    &#123;&#123; form.as_p &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">name</span>=<span class="string">"submit"</span>&gt;</span>add entry<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">&#123;% endblock content %&#125;</span><br></pre></td></tr></table></figure>
<p>注意第4行代码，改行代码返回到特定主题页面。</p>
<h3 id="链接到页面new_entry">2.2.5 链接到页面new_entry</h3>
<p>在显示特定主题的页面中添加到页面<code>new_entry</code>的链接，修改<code>topic.html</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% extends "learning_logs/base.html" %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Topic: &#123;&#123; topic &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Entries:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'learning_logs:new_entry' topic.id %&#125;"</span>&gt;</span>add new entry<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  -- snip --</span><br><span class="line"></span><br><span class="line">&#123;% endblock content %&#125;</span><br></pre></td></tr></table></figure>
<h3 id="效果-1">2.2.6 效果</h3>
<p>下图是实际效果，请随意添加一些条目：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828409/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF18-%E7%94%A8%E6%88%B7%E8%B4%A6%E6%88%B7/1524650445421.png" /></p>
<h2 id="编辑条目">2.3 编辑条目</h2>
<p>创建一个页面，让用户能编辑既有条目。顺序是：添加URL，添加视图，添加模板，链接到页面。</p>
<h3 id="url模式edit_entry">2.3.1 URL模式edit_entry</h3>
<p>修改<code>learning_logs/urls.py</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    -- snip --</span><br><span class="line">    path(<span class="string">"edit_entry/&lt;int:entry_id&gt;/"</span>, views.edit_entry, name=<span class="string">"edit_entry"</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="视图函数edit_entry">2.3.2 视图函数edit_entry()</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Topic, Entry</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit_entry</span><span class="params">(request, entry_id)</span>:</span></span><br><span class="line">    <span class="string">"""编辑既有条目"""</span></span><br><span class="line">    entry = Entry.objects.get(id=entry_id)</span><br><span class="line">    topic = entry.topic</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> request.method != <span class="string">"POST"</span>:</span><br><span class="line">        <span class="comment"># 初次请求，使用当前条目填充表单</span></span><br><span class="line">        form = EntryForm(instance=entry)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># POST提交的数据，对数据进行处理</span></span><br><span class="line">        form = EntryForm(instance=entry, data=request.POST)</span><br><span class="line">        <span class="keyword">if</span> form.is_valid():</span><br><span class="line">            form.save()</span><br><span class="line">            <span class="keyword">return</span> HttpResponseRedirect(reverse(<span class="string">'learning_logs:topic'</span>, args=[topic.id]))</span><br><span class="line"></span><br><span class="line">    context = &#123;<span class="string">"entry"</span>: entry, <span class="string">"topic"</span>: topic, <span class="string">"form"</span>: form&#125;</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">"learning_logs/edit_entry.html"</span>, context)</span><br></pre></td></tr></table></figure>
<p>首先获取要被修改的<code>entry</code>以及与该条目相关的主题。处理<code>GET</code>请求时，通过参数<code>instance=entry</code>创建<code>EntryForm</code>实例，该参数让Django创建一个表单，并使用既有条目对象中的信息填充它。处理<code>POST</code>请求时，还传入了<code>data=request.POST</code>参数，Django根据POST中的相关数据对<code>entry</code>进行修改。</p>
<h3 id="模板edit_entry.html">2.3.3 模板edit_entry.html</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% extends "learning_logs/base.html" %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'learning_logs:topic' topic.id %&#125;"</span>&gt;</span>&#123;&#123; topic &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Edit entry:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"&#123;% url 'learning_logs:edit_entry' entry.id %&#125;"</span>&gt;</span></span><br><span class="line">    &#123;% csrf_token %&#125;</span><br><span class="line">    &#123;&#123; form.as_p &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">name</span>=<span class="string">"submit"</span>&gt;</span>save changes<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;% endblock content %&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链接到页面edit_entry.html">2.3.4 链接到页面edit_entry.html</h3>
<p>在显示特定主题的页面中，需要给每个条目添加到页面<code>edit_entry.html</code>的链接，为此，修改<code>topic.html</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">-- snip --</span><br><span class="line">    &#123;% for entry in entries %&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; entry.date_added|date:'M d, Y H:i' &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; entry.text|linebreaks &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'learning_logs:edit_entry' entry.id %&#125;"</span>&gt;</span>edit entry<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">-- snip --</span><br></pre></td></tr></table></figure>
<h3 id="效果-2">2.3.5 效果</h3>
<p>以下是实际效果图：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828409/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF18-%E7%94%A8%E6%88%B7%E8%B4%A6%E6%88%B7/1524652800514.png" /></p>
<h1 id="创建用户账户">3. 创建用户账户</h1>
<p>现在开始建立一个用户注册和身份验证系统。为此将创建一个新的应用程序，其中包含处理用户账户相关的所有功能。对<code>Topic</code>模型也要做稍许修改，让每个主题都归属于特定用户。</p>
<h2 id="创建应用程序users">3.1 创建应用程序users</h2>
<p>希望大家还记得如何使用<code>startapp</code>命令还创建APP：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python manage.py startapp users</span><br></pre></td></tr></table></figure>
<p>将APP添加到settings.py中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    -- snip --</span><br><span class="line">    <span class="string">"users.apps.UsersConfig"</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>在APP根目录下创建<code>urls.py</code>文件，并添加命名空间：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">app_name = <span class="string">"users"</span></span><br></pre></td></tr></table></figure>
<p>为APP定义URL，修改项目根目录中的<code>urls.py</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">""</span>, include(<span class="string">"learning_logs.urls"</span>)),</span><br><span class="line">    path(<span class="string">"users/"</span>, include(<span class="string">"users.urls"</span>)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="登陆页面">3.2 登陆页面</h2>
<p>使用Django提供的默认登陆视图，URL模式会有所不同。在<code>users</code>中的<code>urls.py</code>中添加如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""为应用程序users定义URL模式"""</span></span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.views <span class="keyword">import</span> login</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"></span><br><span class="line">app_name = <span class="string">"users"</span></span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    <span class="comment"># 登陆页面</span></span><br><span class="line">    path(<span class="string">"login/"</span>, login, &#123;<span class="string">"template_name"</span>: <span class="string">"users/login.html"</span>&#125;, name=<span class="string">"login"</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>代码中，我们使用Django自带的login视图函数（注意，参数是<code>login</code>，而不是<code>views.login</code>）。从之前的例子可以看出，我们渲染模板的代码都是在自己写的视图函数中。但这里使用了自带的视图函数，无法自行编写进行渲染的代码。所以，我们还传了一个字典给<code>path</code>，告诉Django到哪里查找我们要用到的模板。注意，该模板在<code>users</code>中，而不是在<code>learning_logs</code>中。</p>
<h3 id="新建模板login.html">3.2.1 新建模板login.html</h3>
<p>在<code>learning_log/users/templates/users</code>中创建<code>login.html</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% extends "learning_logs/base.html" %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line"></span><br><span class="line">  &#123;% if form.errors %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">P</span>&gt;</span>Your username and password didn't match. Please try again.<span class="tag">&lt;/<span class="name">P</span>&gt;</span></span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">action</span>=<span class="string">"&#123;% url 'users:login' %&#125;"</span>&gt;</span></span><br><span class="line">    &#123;% csrf_token %&#125;</span><br><span class="line">    &#123;&#123; form.as_p &#125;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">name</span>=<span class="string">"submit"</span>&gt;</span>log in<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"next"</span> <span class="attr">value</span>=<span class="string">"&#123;% url 'learning_logs:index' %&#125;"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">&#123;% endblock content %&#125;</span><br></pre></td></tr></table></figure>
<p>如果表单的<code>errors</code>属性被设置，则显示一条提示账号密码错误的信息。</p>
<h3 id="链接到登陆页面">3.2.2 链接到登陆页面</h3>
<p>在<code>base.html</code>中添加到登陆页面的链接，让所有页面都包含它。将这个链接嵌套在一个<code>if</code>标签中，用户已登录时隐藏掉该链接：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'learning_logs:index' %&#125;"</span>&gt;</span>Learning Log<span class="tag">&lt;/<span class="name">a</span>&gt;</span> -</span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'learning_logs:topics' %&#125;"</span>&gt;</span>Topics<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  &#123;% if user.is_authenticated %&#125;</span><br><span class="line">    Hello, &#123;&#123; user.username &#125;&#125;</span><br><span class="line">  &#123;% else %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'users:login' %&#125;"</span>&gt;</span>log in<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;&#123;% endblock content %&#125;</span><br></pre></td></tr></table></figure>
<p>在Django身份验证系统中，每个模板都可使用变量<code>user</code>，这个变量有一个<code>is_authenticated</code>属性：如果用户已登录，该属性将为<code>True</code>，否则为<code>False</code>。</p>
<h3 id="使用登陆页面">3.2.3 使用登陆页面</h3>
<p>首先访问<code>localhost:8000/admin</code>注销超级用户，再访问<code>localhost:8000/users/login/</code>，得到如下页面：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828409/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF18-%E7%94%A8%E6%88%B7%E8%B4%A6%E6%88%B7/1524655780559.png" /></p>
<h2 id="注销">3.3 注销</h2>
<p>并不为注销创建单独的页面，而是让用户单击一个连接用于注销并返回主页。因此，需要做如下工作：<strong>注销URL模式，新建视图，链接到注销视图</strong>。</p>
<p>在<code>users/urls.py</code>中添加与http://localhost:8000/users/logout/ 匹配的URL模式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">-- snip --</span><br><span class="line">urlpatterns = [</span><br><span class="line">    -- snip --</span><br><span class="line">    path(<span class="string">"logout/"</span>, views.logout_view, name=<span class="string">"logout"</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>编写视图函数<code>logout_view()</code>，其中，直接调用Django自带的<code>logout()</code>函数，该函数要求<code>request</code>作为参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth <span class="keyword">import</span> logout</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponseRedirect</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> reverse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logout_view</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">"""注销用户"""</span></span><br><span class="line">    logout(request)</span><br><span class="line">    <span class="keyword">return</span> HttpResponseRedirect(reverse(<span class="string">"learning_logs:index"</span>))</span><br></pre></td></tr></table></figure>
<p>在<code>base.html</code>中添加注销链接：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">-- snip --</span><br><span class="line">  &#123;% if user.is_authenticated %&#125;</span><br><span class="line">    Hello, &#123;&#123; user.username &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'users:logout' %&#125;"</span>&gt;</span>log out<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  &#123;% else %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'users:login' %&#125;"</span>&gt;</span>log in<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">-- snip --</span><br></pre></td></tr></table></figure>
<h2 id="注册页面">3.4 注册页面</h2>
<p>使用Django提供的表单<code>UserCreationFrom</code>，但编写自己的视图函数和模板。<code>URL-&gt;view-&gt;template-&gt;link</code>。</p>
<p>首先，<strong>创建注册页面的URL模式</strong>，修改<code>users/urls.py</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">-- snip --</span><br><span class="line">urlpatterns = [</span><br><span class="line">    -- snip --</span><br><span class="line">    path(<span class="string">"register/"</span>, views.register, name=<span class="string">"register"</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>其次，<strong>创建视图<code>register()</code></strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth <span class="keyword">import</span> logout, authenticate, login</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.forms <span class="keyword">import</span> UserCreationForm</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line">-- snip --</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">"""注册新用户"""</span></span><br><span class="line">    <span class="keyword">if</span> request.method != <span class="string">"POST"</span>:</span><br><span class="line">        <span class="comment"># 显示空的注册表单</span></span><br><span class="line">        form = UserCreationForm()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 处理填写好的表单</span></span><br><span class="line">        form = UserCreationForm(data=request.POST)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> form.is_valid():</span><br><span class="line">            new_user = form.save()</span><br><span class="line">            <span class="comment"># 让用户自动登陆，再重定向到主页</span></span><br><span class="line">            <span class="comment"># 注册是要求输入两次密码，所以有password1和password2</span></span><br><span class="line">            authenticated_user = authenticate(username=new_user.username,</span><br><span class="line">                                              password=request.POST[<span class="string">"password1"</span>])</span><br><span class="line">            login(request, authenticated_user)</span><br><span class="line">            <span class="keyword">return</span> HttpResponseRedirect(reverse(<span class="string">"learning_logs:index"</span>))</span><br><span class="line"></span><br><span class="line">    context = &#123;<span class="string">"form"</span>: form&#125;</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">"users/register.html"</span>, context)</span><br></pre></td></tr></table></figure>
<p>以上代码在用户成功创建了用户后会自动登陆，该功能由<code>login()</code>函数实现。该函数将会为通过了身份验证的用户对象创建会话（session）。最后上述代码重定向到主页。</p>
<p>然后，<strong>编写注册页面的模板register.html</strong>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% extends "learning_logs/base.html" %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">action</span>=<span class="string">"&#123;% url 'users:register' %&#125;"</span>&gt;</span></span><br><span class="line">  &#123;% csrf_token %&#125;</span><br><span class="line">  &#123;&#123; form.as_p &#125;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">name</span>=<span class="string">"sumbit"</span>&gt;</span>register<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"next"</span> <span class="attr">value</span>=<span class="string">"&#123;% url 'learning_logs:index' %&#125;"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">&#123;% endblock content %&#125;</span><br></pre></td></tr></table></figure>
<p>最后，<strong>在页面中显示注册链接</strong>，修改<code>base.html</code>，在用户没有登录时显示注册链接：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">-- snip --</span><br><span class="line">  &#123;% if user.is_authenticated %&#125;</span><br><span class="line">    Hello, &#123;&#123; user.username &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'users:logout' %&#125;"</span>&gt;</span>log out<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  &#123;% else %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'users:register' %&#125;"</span>&gt;</span>register<span class="tag">&lt;/<span class="name">a</span>&gt;</span> -</span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'users:login' %&#125;"</span>&gt;</span>log in<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">-- snip --</span><br></pre></td></tr></table></figure>
<p>下面是实际效果：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828409/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF18-%E7%94%A8%E6%88%B7%E8%B4%A6%E6%88%B7/1524671129060.png" /></p>
<p>这是直接点register按钮时的反馈，不过这里有点疑惑，从上面的register.html中看到，其实代码很简单，但这里有个浮动效果，而且在注册模板中并没有像前面那样的form.errors模板标签，但依然有未注册成功时的反应，而且注册的视图函数也是自己写的，并不是用的自带的注册函数，所以不知道是不是和form.as_p有关。之后再慢慢研究吧，</p>
<h1 id="让用户拥有自己的数据">4. 让用户拥有自己的数据</h1>
<p>用户应该能够输入其专有的数据，所以应该创建一个系统，确定各项数据所属的用户，再限制对页面的访问，使得用户只能使用自己的数据，即访问控制。</p>
<h2 id="使用login_required限制访问">4.1 使用@login_required限制访问</h2>
<p>Django提供了装饰器<code>@login_required</code>，使得能轻松实现用户只能访问自己能访问的页面。</p>
<p><strong>限制对topics.html的访问</strong>：</p>
<p>每个主题都归特定用户所有，所以需要加限制，修改<code>learning_logs/views.py</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.decorators <span class="keyword">import</span> login_required</span><br><span class="line"></span><br><span class="line"><span class="meta">@login_required</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topics</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">"""显示所有的主题"""</span></span><br><span class="line">    topics = Topic.objects.order_by(<span class="string">"date_added"</span>)</span><br><span class="line">    <span class="comment"># 一个上下文字典，传递给模板</span></span><br><span class="line">    context = &#123;<span class="string">"topics"</span>: topics&#125;</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">"learning_logs/topics.html"</span>, context)</span><br></pre></td></tr></table></figure>
<p>装饰器也是一个函数，python在运行<code>topics()</code>前会先运行<code>login_required()</code>的代码。</p>
<p><code>login_required()</code>函数检查用户是否登录，仅当用户已登录时，Django才运行<code>topics()</code>函数，若未登录，就重定向到登陆界面。而为了实现这个重定向，还需要修改<strong>项目</strong>的<code>settings.py</code>文件，在该文件中添加这样一个常量（其实也是变量），一般在文件末尾添加：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">-- snip --</span><br><span class="line">LOGIN_URL = <span class="string">'/users/login/'</span></span><br></pre></td></tr></table></figure>
<p><strong>全面限制对项目“学习笔记”的访问</strong>：</p>
<p>Django能轻松地限制对页面的访问，但得自己设计需要限制哪些页面。一般先确定哪些页面不需要保护，再限制对其他页面的访问。在该项目中，我们不限制对主页、注册页面和注销链接的访问，其他页面均限制。在<code>learning_logs/views.py</code>中，除了<code>index()</code>外，每个视图函数都加上<code>@login_required</code>。</p>
<h2 id="将数据关联到用户">4.2 将数据关联到用户</h2>
<p>为了禁止用户访问其他用户的数据，需要将用户与数据关联。只需要将最高层的数据关联到用户，这样更低层的数据将自动关联到用户。下面修改<code>Topic</code>模型和相关视图：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> User</span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Topic</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="string">"""用户学习的主题"""</span></span><br><span class="line">    text = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    date_added = models.DateTimeField(auto_now_add=<span class="literal">True</span>)</span><br><span class="line">    owner = models.ForeignKey(User, on_delete=models.CASCADE)</span><br><span class="line">    -- snip --</span><br></pre></td></tr></table></figure>
<p>修改模型后，还需要迁移数据库。此时，需要将主题与用户关联。这里并没有通过代码进行关联，我们在迁移数据库时手动进行关联。为此，我们需要先知道有哪些用户，以及这些用户的ID。我们通过<code>Django shell</code>查询用户信息，当然也可以直接查看数据库，这里不再演示。我们将主题都关联到超级用户<code>ll_admin</code>上，它的ID是1。现在我们执行数据迁移：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">(venv)learning_logs$</span><span class="bash"> python manage.py makeimgrations learning_logs</span></span><br><span class="line">You are trying to add a non-nullable field 'owner' to topic without a default; </span><br><span class="line">we can't do that (the database needs something to populate existing rows).</span><br><span class="line">Please select a fix:</span><br><span class="line"> 1) Provide a one-off default now (will be set on all existing rows with a null value for </span><br><span class="line"> this column)</span><br><span class="line"> 2) Quit, and let me add a default in models.py</span><br><span class="line">Select an option:  1</span><br><span class="line">Please enter the default value now, as valid Python</span><br><span class="line">The datetime and django.utils.timezone modules are available, so you can do e.g. timezone.now</span><br><span class="line">Type 'exit' to exit this prompt</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;  1</span></span><br><span class="line">Migrations for 'learning_logs':</span><br><span class="line">  learning_logs\migrations\0003_topic_owner.py</span><br><span class="line">    - Add field owner to topic</span><br></pre></td></tr></table></figure>
<p>Django指出试图给既有模型<code>Topic</code>添加一个必不可少（不可为空）的字段，而该字段没有默认值，需要我们采取措施：要么现在提供默认值，要么退出并在<code>models.py</code>中添加默认值。我们选择了直接输入默认值。接下来，Django使用这个值来迁移数据库，并生成了迁移文件<code>0003_topic_owner.py</code>，它在模型Topic中添加字段<code>owner</code>。</p>
<p>现在执行迁移命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">(venv)learning_logs$</span><span class="bash"> python manage.py migrate</span></span><br><span class="line">Operations to perform:</span><br><span class="line">  Apply all migrations: admin, auth, contenttypes, learning_logs, sessions</span><br><span class="line">Running migrations:</span><br><span class="line">  Applying learning_logs.0003_topic_owner... OK</span><br></pre></td></tr></table></figure>
<p>执行后可以在<code>Django shell</code>中验证是否迁移成功，这里不再验证。</p>
<h2 id="只允许用户访问自己的主题">4.3 只允许用户访问自己的主题</h2>
<p>目前不管以哪个用户身份登录，都能看到所有主题。现在我们添加限制，让用户只能看到自己的主题。在<code>views.py</code>中，对<code>topics()</code>做如下修改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">-- snip --</span><br><span class="line"><span class="meta">@login_required</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topics</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">"""显示所有的主题"""</span></span><br><span class="line">    topics = Topic.objects.filter(owner=request.user).order_by(<span class="string">"date_added"</span>)</span><br><span class="line">    <span class="comment"># 一个上下文字典，传递给模板</span></span><br><span class="line">    context = &#123;<span class="string">"topics"</span>: topics&#125;</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">"learning_logs/topics.html"</span>, context)</span><br><span class="line">-- snip --</span><br></pre></td></tr></table></figure>
<p>用户登录后，<code>request</code>对象将有一个<code>user</code>属性，这个属性存储了有关该用户的信息。第5行代码让Django只从数据库中读取特定用户的数据。</p>
<h2 id="保护用户的主题">4.4 保护用户的主题</h2>
<p>上述代码做到了登录后只显示相应用户的数据，但是，如果登录后直接通过URL访问，如直接输入http://localhost:8000/topics/1/ ，依然可以访问不属于自己的特定主题页面。下面修改<code>views.py</code>中的<code>topic()</code>函数来加以限制：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponseRedirect, Http404</span><br><span class="line"></span><br><span class="line"><span class="meta">@login_required</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topic</span><span class="params">(request, topic_id)</span>:</span></span><br><span class="line">    <span class="string">"""显示单个主题及其所有的条目"""</span></span><br><span class="line">    topic = Topic.objects.get(id=topic_id)</span><br><span class="line">    <span class="comment"># 确认请求的主题属于当前用户</span></span><br><span class="line">    <span class="keyword">if</span> topic.owner != request.user:</span><br><span class="line">        <span class="keyword">raise</span> Http404</span><br><span class="line">    -- snip --</span><br></pre></td></tr></table></figure>
<h2 id="保护页面edit_entry">4.5 保护页面edit_entry</h2>
<p>此时用户也可以像上面一样，登陆后直接通过URL来访问<code>edit_entry.html</code>，现在我们对这个页面也加以限制：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@login_required</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit_entry</span><span class="params">(request, entry_id)</span>:</span></span><br><span class="line">    <span class="string">"""编辑既有条目"""</span></span><br><span class="line">    entry = Entry.objects.get(id=entry_id)</span><br><span class="line">    topic = entry.topic</span><br><span class="line">    <span class="keyword">if</span> topic.owner != request.user:</span><br><span class="line">        <span class="keyword">raise</span> Http404</span><br><span class="line">    </span><br><span class="line">    -- snip --</span><br></pre></td></tr></table></figure>
<h2 id="最后一步将新主题关联到当前用户">4.6 最后一步：将新主题关联到当前用户</h2>
<p>当前用于添加新主题的页面存在问题，因为它没有将新主题关联到特定用户。如果此时尝试添加新主题，将看到错误信息<code>IntegrityError</code>，指出<code>learning_logs_topic.user_id</code>不能为<code>NULL</code>，下面修改<code>new_topic()</code>函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@login_required</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_topic</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">"""添加新主题"""</span></span><br><span class="line">    <span class="keyword">if</span> request.method != <span class="string">"POST"</span>:</span><br><span class="line">        <span class="comment"># 为提价数据：创建一个新表单</span></span><br><span class="line">        form = TopicForm()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># POST提交的数据，对数据进行处理</span></span><br><span class="line">        form = TopicForm(request.POST)</span><br><span class="line">        <span class="keyword">if</span> form.is_valid():</span><br><span class="line">            <span class="comment"># 添加新主题时关联到特定用户</span></span><br><span class="line">            new_topic = form.save(commit=<span class="literal">False</span>)</span><br><span class="line">            new_topic.owner = request.user</span><br><span class="line">            new_topic.save()</span><br><span class="line">            <span class="comment"># 该类将用户重定向到网页topics，函数reverse()根据指定的URL模型确定URL</span></span><br><span class="line">            <span class="keyword">return</span> HttpResponseRedirect(reverse(<span class="string">"learning_logs:topics"</span>))</span><br><span class="line"></span><br><span class="line">    context = &#123;<span class="string">"form"</span>: form&#125;</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">"learning_logs/new_topic.html"</span>, context)</span><br></pre></td></tr></table></figure>
<p>现在，这个项目允许任何用户注册，而每个用户想添加多少新主题都可以，每个用户只能访问自己的数据，无论是查看数据、输入新数据还是修改旧数据时都是如此。</p>
<h1 id="小结">5. 小结</h1>
<p>本篇主要讲述了如何使用表单来让用户添加新主题、添加新条目和编辑既有条目；如何实现注册，登录与注销，如何使用装饰器来限制访问，如何对用户数据进行保护等。下一篇中，我们将使这个项目更漂亮，并且部署到服务器上。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python基础</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路17-Django入门</title>
    <url>/2018/04/22/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF17-Django%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<blockquote>
<p>《Python编程：从入门到实践》笔记。 从本篇开始将是该书的最后一个项目，将用3篇文章来介绍Django的基础。完成一个“学习笔记”的小网站。</p>
</blockquote>
<a id="more"></a>
<h1 id="前言">1. 前言</h1>
<p>在本篇中，我们将：</p>
<ul>
<li>用Django来开发一个名为“学习笔记”(Learning Log)的项目；</li>
<li>为这个项目制定规范，然后为应用程序使用的数据定义模型；</li>
<li>使用Django的管理系统来输入一些初试数据，再学习编写视图和模板，让Django能够为我们的网站创建网页。</li>
</ul>
<p>不过在开始之前，请先新建一个<strong>虚拟环境</strong>并安装Django。如果没有虚拟环境，通过<code>pip</code>安装的所有库都会保存到python的<code>site-packages</code>目录下。开发多个项目时，都会用同一个python，而某些项目并不需要其中的所有第三方库，但如果将这些不需要库的删除，又会影响到其他项目。而且，如果A项目需要Django2.0.4，B项目需要Django2.0.0，这该怎么办？此时就需要虚拟环境。它其实就相当于一个新的文件夹，将新项目与其他项目隔离，本项目的库不与其他项目的库相关联，类似于操作系统的多用户概念。</p>
<p>如果使用的是Python 3，可以使用命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python -m venv ll_env</span><br></pre></td></tr></table></figure>
<p>如果该命令不成功，可能是没有安装<code>virtualenv</code>模块：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install virtualenv</span><br></pre></td></tr></table></figure>
<p>然后创建并激活虚拟环境：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">virtualenv ll_env</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> linux:</span></span><br><span class="line">source ll_env/bin/activate</span><br><span class="line"><span class="meta">#</span><span class="bash"> windows:</span></span><br><span class="line">ll_env\Scripts\activate</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停用：</span></span><br><span class="line">deactivate</span><br></pre></td></tr></table></figure>
<p>管理虚拟环境的库还有很多，有兴趣的话可以到网上搜一搜。</p>
<p>如果你使用的是新版的PyCharm，那么它在新建项目的时候默认就会创建新的虚拟环境。</p>
<p>激活虚拟环境后就可以安装Django了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install django</span><br></pre></td></tr></table></figure>
<h1 id="建立项目">2. 建立项目</h1>
<h2 id="在django中创建项目">2.1 在Django中创建项目</h2>
<h3 id="生成项目">2.1.1 生成项目</h3>
<p>在虚拟环境中执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 主要最后有个实心句号！</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这个句点让新项目使用合适的目录结构，这样开发完成后可以轻松地将应用程序部署到服务器</span></span><br><span class="line">django-admin startproject learning_log .</span><br></pre></td></tr></table></figure>
<p>执行上述命令后，将多出一个<code>manage.py</code>文件和一个<code>learning_log</code>文件夹，当然还有本身的一个<code>ll_env</code>文件夹。</p>
<p>而在<code>learning_log</code>文件夹中，又有四个文件：<code>__init__.py</code>，<code>settings.py</code>，<code>urls.py</code>，<code>wsgi.py</code>。</p>
<ul>
<li><code>manage.py</code>是一个简单的程序，它接收命令并将其交给Django的相关部分去运行；</li>
<li><code>settings.py</code>指定Django如何与你的系统交互以及如何管理项目，其实就是配置文件；</li>
<li><code>urls.py</code>告诉Django应创建哪些网页来响应浏览器请求；</li>
<li><code>wsgi.py</code>是web server gateway interface(Web服务器网关接口)的缩写，帮助Django提供它创建的文件。</li>
</ul>
<p>至于<code>__init__.py</code>，它是个空文件，Python的每个模块下必须要有这个文件。</p>
<h3 id="创建数据库">2.1.2 创建数据库</h3>
<p>Django将大部分与项目相关的信息都存储在数据库中，所有还需要创建一个供Django使用的数据库。依然是在虚拟环境下执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure>
<p>在PyCharm中的话，可以通过点击工具栏Tools中的Run manage.py Task（Ctrl+Alt+R），在弹出的命令行中直接输入原命令中<code>manage.py</code>后面的部分，后面的命令也可以这样执行（<code>[appname]</code>是自动提示）。</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828383/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF17-Django%E5%85%A5%E9%97%A8/1524317369448.png" /></p>
<p>"migrate"这个单词其实是迁移的意思，并不是“创建(create)”。之所以使用这个词，是因为一般将修改数据库的过程称为迁移数据库（笔者数据库学得渣，这段解释直接从书里照搬的，希望哪位大神在留言区解释一波）。如果是刚创建的项目，并且第一次执行，将会得到如下输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Operations to perform:</span><br><span class="line">  Apply all migrations: admin, auth, contenttypes, sessions</span><br><span class="line">Running migrations:</span><br><span class="line">  Applying contenttypes.0001_initial... OK</span><br><span class="line">  -- snip --</span><br><span class="line">  Applying sessions.0001_initial... OK</span><br></pre></td></tr></table></figure>
<p>从第2行结果可以看出，Django将创建和修改数据库看做是对数据库的迁移，Apply all migrations确保数据库结构与当前代码匹配（比如你修改了类的结构，添加了属性，这就相当于修改了数据表）。</p>
<p>执行命令后，项目的根目录下会多出一个名为<code>db.sqlite3</code>的数据库文件。SQLite是一种使用单个文件的轻量级数据库，常用于开发简单应用程序，它让你不用太关注数据库管理的问题。</p>
<h3 id="运行项目">2.1.3 运行项目</h3>
<p>依然在项目的虚拟环境下输入如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure>
<p>得到如下输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Performing system checks...</span><br><span class="line"></span><br><span class="line">System check identified no issues (0 silenced).</span><br><span class="line">April 21, 2018 - 20:46:48</span><br><span class="line">Django version 2.0.4, using settings 'learning_log.settings'</span><br><span class="line">Starting development server at http://127.0.0.1:8000/</span><br><span class="line">Quit the server with CTRL-BREAK.</span><br></pre></td></tr></table></figure>
<p>现在在浏览器中地址栏输入<code>localhost:8000</code> (或者<code>127.0.0.1:8000</code>)，将得到如下页面：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828384/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF17-Django%E5%85%A5%E9%97%A8/1524316623415.png" /></p>
<p>这是最新版的Django的默认启动界面。</p>
<h2 id="创建应用程序app">2.2 创建应用程序（APP）</h2>
<h3 id="创建模型">2.2.1 创建模型</h3>
<p>Django项目由一系列应用程序组成，它们协同工作，让项目成为一个整体。我们在项目根目录下执行如下命令，创建一个名为learning_logs的应用程序：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python manage.py startapp learning_logs</span><br></pre></td></tr></table></figure>
<p>执行命令后，根目录下会多出一个名为<code>learning_logs</code>的文件夹（笔者第一次接触Django的时候发现这玩意儿居然叫做APP，和平时用的手机上的各种APP相差也太大了，很不适应），它的结构如下：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828383/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF17-Django%E5%85%A5%E9%97%A8/1524317551180.png" /></p>
<p>重要的是其中的<code>models.py</code>、<code>admin.py</code>和<code>views.py</code>文件，我们将使用<code>models.py</code>来定义我们要在应用程序中管理的数据。另外两个文件稍后再介绍。</p>
<p>打开<code>models.py</code>文件，发现其中自带两行代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your models here.</span></span><br></pre></td></tr></table></figure>
<p>在代码层面，模型就是一个类，和之前的文章中的类一样，包含属性和方法。下面创建一个“主题”类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Topic</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="string">"""用户学习的主题"""</span></span><br><span class="line">    text = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    date_added = models.DateTimeField(auto_now_add=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回模型的字符串表示"""</span></span><br><span class="line">        <span class="keyword">return</span> self.text</span><br></pre></td></tr></table></figure>
<p><code>Model</code>类是Django中的一个定义了模型基本功能的类。<code>Topic</code>类只有两个属性<code>text</code>和<code>date_added</code>。模型中如<code>CharField</code>，<code>DateTimeField</code>这些字段还有很多，Django自动根据数据库的不同调用不同的SQL语句创建数据表，即屏蔽底层数据库的差异。</p>
<p>同时还重写了<code>__str__()</code>方法，之所以说“重写”是因为每个类都有这个方法，当直接将一个类<code>A</code>放入<code>print()</code>之类的语句中时，就会调用<code>A</code>的<code>__str__()</code>方法。如果没有重写这个方法，一般会输出这个对象的内存地址之类的，大家可以苏随便写个类试一试。</p>
<h3 id="激活模型">2.2.2 激活模型</h3>
<p>使用模型前，必须将APP包含到项目中，打开<code>settings.py</code>文件，将APP添加到<code>INSTALLED_APPS</code>中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">'django.contrib.admin'</span>,</span><br><span class="line">    <span class="string">'django.contrib.auth'</span>,</span><br><span class="line">    <span class="string">'django.contrib.contenttypes'</span>,</span><br><span class="line">    <span class="string">'django.contrib.sessions'</span>,</span><br><span class="line">    <span class="string">'django.contrib.messages'</span>,</span><br><span class="line">    <span class="string">'django.contrib.staticfiles'</span>,</span><br><span class="line">    <span class="comment"># 添加你的app，上面的都是自带的</span></span><br><span class="line">    <span class="string">"learning_logs.apps.LearningLogsConfig"</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>这里有个需要注意的地方，由于这本书的2016年出版的，当时Django还没有到达2.0版本，所以在书中，注册APP是这样写的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    -- snip --</span><br><span class="line">    <span class="comment"># 添加你的app，上面的都是自带的</span></span><br><span class="line">    <span class="string">"learning_logs"</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>现在官方文档中是按照第一种方式注册APP，并且，最新版的Django在新建APP后，在APP的目录下还多了一个<code>apps.py</code>文件，该文件默认有一个根据APP名称创建的类，此处为<code>LearningLogsConfig</code>，内容如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.apps <span class="keyword">import</span> AppConfig</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LearningLogsConfig</span><span class="params">(AppConfig)</span>:</span></span><br><span class="line">    name = <span class="string">'learning_logs'</span></span><br></pre></td></tr></table></figure>
<p>回到主线，在终端中输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python manage.py makemigrations learning_logs</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出</span></span><br><span class="line">Migrations for 'learning_logs':</span><br><span class="line">  learning_logs\migrations\0001_initial.py</span><br><span class="line">    - Create model Topic</span><br></pre></td></tr></table></figure>
<p><code>makemigrations</code>让<code>Django</code>确定该如何修改数据库，使其能够存储与我们定义的新模型相关联的数据。从输出可以看出，在APP目录下的<code>migrations</code>文件夹中创建了一个名为<code>0001_initial.py</code>的迁移文件，该文件将在数据库中为模型<code>Topic</code>创建一个表。</p>
<p>最后，在命令行中输入:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python manage.py migrate</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出：</span></span><br><span class="line">Running migrations:</span><br><span class="line">  Applying learning_logs.0001_initial... OK</span><br></pre></td></tr></table></figure>
<p>总结：<strong>每当需要修改模型时，都采取如下三个步骤：修改<code>models.py</code>，对你的APP调用<code>makemigrations</code>，让Django迁移项目<code>migrate</code>。</strong></p>
<h3 id="django管理网站">2.2.3 Django管理网站</h3>
<p>Django自带管理后台。首先为网站创建一个<strong>超级用户</strong>。在中断输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python manage.py createsuperuser</span><br></pre></td></tr></table></figure>
<p>随后按提示输入用户名和密码即可，邮箱地址可以留空（直接回车）。</p>
<p>Django自动在管理网站中添加一些模型，如<code>User</code>和<code>Group</code>，但对于我们创建的模型，必须手工注册。</p>
<p>注意前面提到的和<code>models.py</code>在同一目录的<code>admin.py</code>文件，这就是注册自行编写的模型的地方，在该文件中加入后两行代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一行代码是自带的</span></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> learning_logs.models <span class="keyword">import</span> Topic</span><br><span class="line"></span><br><span class="line">admin.site.register(Topic)</span><br></pre></td></tr></table></figure>
<p>现在登录Django自带的网站管理页面 http://localhost:8000/admin/ 登录刚才创建的超级用户和密码后将出现如下界面：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828383/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF17-Django%E5%85%A5%E9%97%A8/1524362041305.png" /></p>
<p>在这里你可以管理用户和组，以及和模型Topic相关的数据。</p>
<p>现在先手动添加两个主题：点击<code>Add</code>创建<code>Chess</code>和<code>Rock Climbing</code>。</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828383/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF17-Django%E5%85%A5%E9%97%A8/1524362685285.png" /></p>
<h3 id="定义模型entry">2.2.4 定义模型Entry</h3>
<p>为使能在每个主题下添加条目，需要定义<code>Entry</code>模型，<code>Entry</code>与<code>Topic</code>的关系是多对一。同样是在<code>models.py</code>中添加模型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Topic</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    -- snip --</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entry</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="string">"""学到的有关某个主题的具体知识"""</span></span><br><span class="line">    <span class="comment"># 由于和“主题”是多对一的关系，所以“主题”是“条目”的外键</span></span><br><span class="line">    topic = models.ForeignKey(Topic, on_delete=models.CASCADE)</span><br><span class="line">    text = models.TextField()</span><br><span class="line">    date_added = models.DateTimeField(auto_now_add=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        verbose_name_plural = <span class="string">"entries"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回模型的字符串表示"""</span></span><br><span class="line">        <span class="comment"># 由于条目包含的文本可能很长，只显示前50个字符</span></span><br><span class="line">        <span class="keyword">return</span> self.text[:<span class="number">50</span>] + <span class="string">"..."</span></span><br></pre></td></tr></table></figure>
<p>注意其中嵌套了一个<code>Meta</code>类，它用于管理模型的额外信息。它让我们能够设置一个特殊属性，让Django在需要时使用<code>Entries</code>来表示多个条目。如果没有这个类，Django将使用<code>Entrys</code>来表示多个条目(保证英语语法正确......不得不说，本书作者还是很细心的)。</p>
<p>添加了新模型，所以需要再次迁移数据库，过程就是前面讲的三个步骤中的后两步。然后在<code>admin.py</code>中注册<code>Entry</code>。</p>
<p>为了让这个网站有一些初试数据，添加三个条目：两个<code>Chess</code>的，一个<code>Rock Climbing</code>的。在管理页面中点击<code>Entries</code>的<code>Add</code>按钮，你将看到一个下拉列表，用于选择<code>Topic</code>，还有个文本框，用于输入内容。随便输入一点内容就可以，具体内容不再详细列出。</p>
<h3 id="django-shell">2.2.5 Django shell</h3>
<p>输入一些数据后，可通过交互式终端会话以编程方式查看这些数据。这种交互式环境称为Django shell，常用语测试项目和排除故障。以下是在shell中的一些操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">(ll_env)learning_log$</span><span class="bash"> python manage.py shell   <span class="comment"># 启动shell</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; from learning_logs.models import Topic</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Topic.objects.all()   <span class="comment"># 获得模型Topic的所有实例</span></span></span><br><span class="line">&lt;QuerySet [&lt;Topic: Chess&gt;, &lt;Topic: Rock Climbing&gt;]&gt;  # 返回了一个查询集QuerySet</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; topics = Topic.objects.all()  <span class="comment"># 查询每个Topic对象</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; <span class="keyword">for</span> topic <span class="keyword">in</span> topics:</span></span><br><span class="line">...     print(topic.id, topic)</span><br><span class="line">...</span><br><span class="line">1 Chess</span><br><span class="line">2 Rock Climbing</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; t = Topic.objects.get(id=1) <span class="comment"># 根据id查看Chess模型的具体内容</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; t.text</span></span><br><span class="line">'Chess'</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; t.date_added</span></span><br><span class="line">datetime.datetime(2018, 4, 22, 2, 4, 3, 723045, tzinfo=&lt;UTC&gt;)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; t.entry_set.all()  <span class="comment"># 查看该主题下的所有条目，通过外键查询，进行了人为换行</span></span></span><br><span class="line">&lt;QuerySet [&lt;Entry: The opening is the first part of the game, roughly...&gt;,</span><br><span class="line">&lt;Entry: In the opening phase of the game, it's important t...&gt;]&gt;</span><br></pre></td></tr></table></figure>
<p>为了通过外键获取数据，注意查询时的语法：<code>模型小写名称+下划线+set</code>，如第19行代码。编写用户可请求的网页时将使用这样的语法。如果代码在shell中的行为符合预期，那么它们在项目文件中也能正确工作。</p>
<h1 id="创建网页学习笔记主页">3. 创建网页：学习笔记主页</h1>
<p>这一部分，书中内容和新版的Django出入比较多。</p>
<h2 id="映射url">3.1 映射URL</h2>
<p>Django创建网页的过程通常分三个阶段：<strong>定义URL、编写视图和编写模板</strong>。</p>
<p>URL模式描述了URL是如何设计的，让Django知道如何将浏览器请求与网站URL匹配，以确定返回哪个网页。每个URL都被映射到特定的视图——视图函数获取并处理网页所需的数据。视图函数通常调用一个模板，后者生成浏览器能够理解的网页。</p>
<p>目前，基础URL(http://localhost:8000/ )返回默认的Django页面，现在修改这个映射，将其映射到我们自己编写的主页。</p>
<p>打开<code>learning_log</code>文件夹中的<code>urls.py</code>，将看到如下内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 书中的内容和实际的内容有些出入，以下是书中内容：</span></span><br><span class="line"><span class="comment"># 新版Django简化了URL路由写法</span></span><br><span class="line"><span class="comment"># from django.conf.urls import include, url</span></span><br><span class="line"><span class="comment"># from django.contrib import admin</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># from django.conf.urls import include, url</span></span><br><span class="line"><span class="comment"># from django.contrib import admin</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># urlpatterns = [</span></span><br><span class="line"><span class="comment">#    url(r'^admin/', include(admin.site.urls)),</span></span><br><span class="line"><span class="comment"># ]</span></span><br></pre></td></tr></table></figure>
<p>变量<code>urlpatterns</code>包含项目中的APP的URL，<code>admin.site.urls</code>模块定义了可在管理网站中请求的所有URL。现在添加代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">""</span>, include(<span class="string">"learning_logs.urls"</span>)),</span><br><span class="line">    <span class="comment"># 书中代码：</span></span><br><span class="line">    <span class="comment"># url(r"", include("learning_logs.urls", namespace="learning_logs")),</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>注意：书中在此处的<code>include()</code>函数中传入了关键字参数<code>namespace="learning_logs"</code>，但在新版中，<strong>命名空间(namespace)</strong>是在APP的<code>urls.py</code>中设置的：在<code>urlpatterns</code>变量前新建一个值为<code>"learning_logs"</code>的<code>app_name</code>变量。</p>
<p><code>namespace</code>让<code>learning_logs</code>的URL同项目中的其他URL区分开，对项目进行扩展时，这样做十分有用。</p>
<p>还需要在<code>learning_logs</code>中创建另一个<code>urls.py</code>文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""定义learning_logs的URL模式"""</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="comment"># 从当前的urls.py模块所在的文件夹中导入视图</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line"><span class="comment"># 该变量包含该APP中可请求的网页</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    <span class="comment"># 主页</span></span><br><span class="line">    path(<span class="string">""</span>, views.index, name=<span class="string">"index"</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><code>path()</code>的第一个参数是正则表达式，第二个参数是要调用的视图函数（当请求的URL和第一个参数匹配时调用），第三个参数为这个URL模式指定一个名字，相当于将这个模式保存在变量<code>index</code>中，以后每当需要提供这个主页的连接时都使用这个名字，而不用再编写URL。</p>
<h2 id="编写视图">3.2 编写视图</h2>
<p>视图函数接收请求中的信息，准备好生成网页所需的数据，再将这些数据发送给浏览器，在发送之前，还套用了网页的模板（如果有模板的话）。</p>
<p>当我们在创建APP时，它的文件夹中有一个<code>views.py</code>文件，该文件默认只有一个导入语句，导入了函数<code>render()</code>，现在编写这个文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">"""学习笔记主页"""</span></span><br><span class="line">    <span class="comment"># 将请求的数据套用到模板中，然后返回给浏览器</span></span><br><span class="line">    <span class="comment"># 第一个参数是原始请求对象，第二是可用于创建网页的模板</span></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">"learning_logs/index.html"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="编写模板">3.3 编写模板</h2>
<p>模板定义了网页的结构，指定了网页时什么样的。每当网页被请求时，Django将填入相关的数据。模板中能访问视图提供的任何数据。</p>
<p>现在创建上面代码中的<code>index.html</code>模板：在<code>learning_logs</code>文件夹中新建一个<code>templates</code>文件夹，再在这个文件夹中新建一个和APP同名的文件夹，即<code>learning_logs</code>文件夹，最后，在这个<code>learning_logs</code>文件夹中新建<code>index.html</code>文件。看起来好像有点多余，但这是Django能够解析的目录结构。<code>index.html</code>文件的内容如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Learning Log<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Learning Log helps you keep track of your learning, </span><br><span class="line">    for any topic your're learning about.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>现在当你访问http://localhost:8000 时，将看到如下主页：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828384/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF17-Django%E5%85%A5%E9%97%A8/1524380898860.png" /></p>
<p>创建网页的过程看起来可能很复杂，实际上这就是一个简单的<code>MVC</code>（<code>Model</code>，<code>View</code>，<code>Controller</code>）模型，但在Django中被称为<code>MVT</code>（<code>Model</code>，<code>View</code>，<code>Template</code>）</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828386/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF17-Django%E5%85%A5%E9%97%A8/QQ20150408-2_2x.png" /></p>
<p>这种方式使代码结构清晰，修改方便，也让我们能各司其职，比如，数据库专家就专注于<code>Model</code>，程序员专注于<code>View</code>，<code>Web</code>设计人员专注于<code>Template</code>。</p>
<h1 id="创建其他网页">4. 创建其他网页</h1>
<p>我们继续扩展我们的项目。创建两个用于显示数据的网页，其中给一个列出所有的主题，另一个显示特定主题的所有条目。对于每个网页都指定URL模式，编写一个视图函数，并编写一个模板。但这么做之前，我们先创建一个父模板，项目中的其他模板都将继承它。</p>
<h2 id="模板继承">4.1 模板继承</h2>
<h3 id="父模板base.html">4.1.1 父模板base.html</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'learning_logs:index' %&#125;"</span>&gt;</span>Learning Log<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;&#123;% endblock content %&#125;</span><br></pre></td></tr></table></figure>
<p>该文件存储在<code>index.html</code>所在的目录中。该文件包含所有页面都有的元素，其他模板继承自它。目前为止，所有页面共有的元素还只有顶端的标题。</p>
<p>我们将这个标题设置为到主页的链接。为了创建这个链接，使用了<strong>模板标签</strong>(花括号加百分号的组合)，其中<code>learning_logs</code>是项目的<strong>命名空间</strong>，index就是这个项目主页的<strong>URL模式名</strong>（注意翻看前面小节的代码）。</p>
<p>还创建了一个块标签(<code>block</code>)，这个块名为<code>content</code>，是一个占位符，其中包含的信息将由子模板指定。</p>
<h3 id="子模板">4.1.2 子模板</h3>
<p>从新编写<code>index.html</code>，使其继承<code>base.html</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% extends "learning_logs/base.html" %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Learning Log helps you keep track of your learning, </span><br><span class="line">        for any topic you're learning about.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endblock content %&#125;</span><br></pre></td></tr></table></figure>
<p>第1行代码导入父模板中的所有内容；<code>extends</code>后面跟父模板所在的路径，虽然这俩文件都在同一目录下，但不能省略掉前面的<code>learning_logs/</code>。</p>
<p>3到6行代码插入了一个名为<code>content</code>的块标签，<strong>不是</strong>从父模板继承的内容都包含在<code>content</code>块中。第6行代码指出内容定义的结束位置。</p>
<p><strong>注意</strong>：在大型项目中，通常有一个用于整个网站的父模板<code>base.html</code>，且网站的每个主要部分都有一个父模板。每个主要部分的父模板又都继承自<code>base.html</code>，而网站的每个网页都继承相应部分的父模板。</p>
<h2 id="主题页面">4.2 主题页面</h2>
<p>该页面显示用户创建的所有主题。他是第一个需要使用数据的页面。</p>
<h3 id="定义url模式">4.2.1 定义URL模式</h3>
<p>在APP的<code>urls.py</code>中添加能转到<code>topics.html</code>的URL模式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    <span class="comment"># 主页</span></span><br><span class="line">    path(<span class="string">""</span>, views.index, name=<span class="string">"index"</span>),</span><br><span class="line">    path(<span class="string">"topics/"</span>, views.topics, name=<span class="string">"topics"</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="添加视图">4.2.2 添加视图</h3>
<p>在<code>views.py</code>中添加相应的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Topic</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    -- snip --</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topics</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">"""显示所有的主题"""</span></span><br><span class="line">    topics = Topic.objects.order_by(<span class="string">"date_added"</span>)</span><br><span class="line">    <span class="comment"># 一个上下文字典，传递给模板</span></span><br><span class="line">    context = &#123;<span class="string">"topics"</span>: topics&#125;</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">"learning_logs/topics.html"</span>, context)</span><br></pre></td></tr></table></figure>
<h3 id="创建模板">4.2.3 创建模板</h3>
<p>创建一个模板，用于显示所有的主题：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% extends "learning_logs/base.html" %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Topics<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        &#123;% for topic in topics %&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; topic &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        &#123;% empty %&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>No topics have been added yet.<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        &#123;% endfor %&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">&#123;% endblock content %&#125;</span><br></pre></td></tr></table></figure>
<p>在这个模板中，我们使用了一个相当于<code>for</code>循环的模板标签，它遍历字典<code>context</code>中的列表<code>topics</code>。并且注意，该模板中没有出现<code>context</code>字样，相当于模板自动从<code>context</code>取得<code>topics</code>的内容。</p>
<p>模板中使用的代码与Python代码存在一些重要差别：Python使用缩进来指出哪些代码行是<code>for</code>循环的组成部分，而在模板中，每个<code>for</code>循环都必须明确的指出结束为止。</p>
<p>要在模板中打印变量，需要将变量名用<strong>双花括号</strong>括起来，每次循环时，该代码都会被替换为<code>topic</code>的当前值。</p>
<p>还使用了<strong>空模板标签(empty)</strong>，它告诉Django在列表<code>topics</code>为空时该怎么办。</p>
<p>这些花括号都不会出现在网页中，它们只是用于告诉Django我们使用了一个模板变量。</p>
<p>修改父模板<code>base.html</code>，使其包含能转到主题页面的连接（第3行为添加的代码，第2行最后添加了一个连字符）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'learning_logs:index' %&#125;"</span>&gt;</span>Learning Log<span class="tag">&lt;/<span class="name">a</span>&gt;</span> -</span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'learning_logs:topics' %&#125;"</span>&gt;</span>Topics<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>现在再次输入http://localhost:8000 将看到我们添加的<code>Topics</code>链接，点击它，将跳转到如下页面：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828384/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF17-Django%E5%85%A5%E9%97%A8/1524381462830.png" /></p>
<h2 id="特定主题页面">4.3 特定主题页面</h2>
<p>该页面用于显示该主题下的所有条目。和上面的步骤一样，定义URL模式，编写<code>views.py</code>中的处理函数，编写网页模板。</p>
<h3 id="url模式">4.3.1 URL模式</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    -- snip --</span><br><span class="line">    path(<span class="string">"topics/&lt;int:topic_id&gt;/"</span>, views.topic, name=<span class="string">"topic"</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="添加视图-1">4.3.2 添加视图</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topic</span><span class="params">(request, topic_id)</span>:</span></span><br><span class="line">    <span class="string">"""显示单个主题及其所有的条目"""</span></span><br><span class="line">    <span class="comment"># 通过Topic的id获得所有条目</span></span><br><span class="line">    topic = Topic.objects.get(id=topic_id)</span><br><span class="line">    <span class="comment"># 前面的减号表示降序排序</span></span><br><span class="line">    entries = topic.entry_set.order_by(<span class="string">"-date_added"</span>)</span><br><span class="line">    context = &#123;<span class="string">"topic"</span>: topic, <span class="string">"entries"</span>: entries&#125;</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">"learning_logs/topic.html"</span>, context)</span><br></pre></td></tr></table></figure>
<p>第4,6行的代码叫做查询，如果你和笔者一样是个初学者，比起代码都写完了，最后发现查询语句有问题，再来修改，那么先在Django shell中运行下代码看看结果，这样更高效。</p>
<h3 id="模板topic.html">4.3.3 模板topic.html</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% extends "learning_logs/base.html" %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Topic: &#123;&#123; topic &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Entries:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    &#123;% for entry in entries %&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; entry.date_added|date:'M d, Y H:i' &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; entry.text|linebreaks &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    &#123;% empty %&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        There are no entries for this topic yet.</span><br><span class="line">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;% endblock content %&#125;</span><br></pre></td></tr></table></figure>
<p>在Django模板中，<strong>竖线</strong>（|）表示模板过滤器（对模板变量的值进行修改的函数）。过滤器date: 'M d, Y H:i'以这样的格式显示时间戳：April 22, 2018 16:09。接下来的一行显示txt的完整值，而不仅仅是<code>entry</code>的前50个字符。过滤器<code>linebreaks</code>将包含换行符的长条目转换成浏览器能够理解的格式，以免显示一个不换行的文本块。</p>
<h3 id="修改topics.html模板">4.3.4 修改topics.html模板</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">-- snip --</span><br><span class="line">&#123;% for topic in topics %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'learning_logs:topic' topic.id %&#125;"</span>&gt;</span>&#123;&#123; topic &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">&#123;% empty %&#125;</span><br><span class="line">-- snip --</span><br></pre></td></tr></table></figure>
<h2 id="效果">4.4 效果</h2>
<p>现在我们回到http://localhost:8000/topics/ 页面，随便点击一个主题，比如第一个，将得到以下界面：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828384/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF17-Django%E5%85%A5%E9%97%A8/1524385446481.png" /></p>
<h1 id="小结">5. 小结</h1>
<p>上述内容主要有：</p>
<ul>
<li>在虚拟环境中安装Django，创建项目，并核实该项目已正确地创建；</li>
<li>在项目中创建APP；</li>
<li>创建表示APP数据的模型；</li>
<li>创建数据库，以及在修改模型后，Django可以为迁移数据库提供什么样的帮助；</li>
<li>创建超级用户，并使用管理网络输入初试数据；</li>
<li>Django shell；</li>
<li>定义URL、创建视图函数、网页模板（包括继承）。</li>
</ul>
<p>下一篇中，我们将：</p>
<ul>
<li>创建对用户友好而直观的网页，让用户无需通过管理网站就能添加新的主题和条目（个人感觉没必要这么做，Django自带的管理系统挺好用的），以及编辑既有的条目；</li>
<li>添加一个用户注册系统，让用户能够创建账户。</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python基础</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路16-使用API</title>
    <url>/2018/04/21/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF16-%E4%BD%BF%E7%94%A8API/</url>
    <content><![CDATA[<blockquote>
<p>《Python编程：从入门到实践》笔记。 本篇是Python数据处理的第三篇，本篇将使用Web应用程序接口自动请求网站的特定信息并可视化。</p>
</blockquote>
<a id="more"></a>
<h1 id="前言">1. 前言</h1>
<p>本将需要用到requests模块来请求网站数据。主要内容如下：</p>
<ul>
<li>向GitHub请求项目数据，按星排序；</li>
<li>使用<code>pygal</code>可视化上述数据；</li>
<li>调用Hacker News的API</li>
</ul>
<h1 id="github-repositories">2. GitHub repositories</h1>
<p>获取GitHub中仓库的描述信息，并按星数排序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行API调用并存储响应,注意不要输错了！</span></span><br><span class="line">url = <span class="string">"https://api.github.com/search/repositories?q=language:python&amp;sort=stars"</span></span><br><span class="line">r = requests.get(url)</span><br><span class="line">print(<span class="string">"Status code:"</span>, r.status_code)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将API响应存储在一个变量中</span></span><br><span class="line">response_dict = r.json()</span><br><span class="line">print(<span class="string">"Total repositories:"</span>, response_dict[<span class="string">"total_count"</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 探索有关仓库的信息</span></span><br><span class="line">repo_dicts = response_dict[<span class="string">"items"</span>]</span><br><span class="line">print(<span class="string">"Repositories returned:"</span>, len(repo_dicts))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 研究第一个仓库</span></span><br><span class="line">repo_dict = repo_dicts[<span class="number">0</span>]</span><br><span class="line">print(<span class="string">"\nKeys:"</span>, len(repo_dict))</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> sorted(repo_dict.keys()):</span><br><span class="line">    print(key)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">Status code: <span class="number">200</span></span><br><span class="line">Total repositories: <span class="number">2563652</span></span><br><span class="line">Repositories returned: <span class="number">30</span></span><br><span class="line"></span><br><span class="line">Keys: <span class="number">72</span></span><br><span class="line">archive_url</span><br><span class="line">archived</span><br><span class="line">assignees_url</span><br><span class="line">blobs_url</span><br><span class="line">-- snip --</span><br></pre></td></tr></table></figure>
<p>有些请求可能并不能成功，可能需要你的个人授权码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">headers = &#123;<span class="string">"Authorization"</span>:<span class="string">"your perosonal token"</span>&#125;</span><br><span class="line">url = <span class="string">"https://api.github.com/search/repositories?q=language:python&amp;sort=stars"</span></span><br><span class="line">r = requests.get(url, headers=headers)</span><br></pre></td></tr></table></figure>
<p>大多数API都存在速率限制，即特定时间内可执行的请求数。对于GitHub的速率限制可以访问 https://api.github.com/rate_limit 访问，时间是“每分钟”。</p>
<h1 id="使用pygal可视化仓库">3. 使用Pygal可视化仓库</h1>
<p>使用一个参数配置类来定义图表的参数，并自定义图表中每个条形的描述信息，并给这些条形添加网址链接。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> pygal</span><br><span class="line"><span class="keyword">from</span> pygal.style <span class="keyword">import</span> LightColorizedStyle <span class="keyword">as</span> LCS, LightenStyle <span class="keyword">as</span> LS</span><br><span class="line"></span><br><span class="line">-- snip --</span><br><span class="line">repo_dicts = response_dict[<span class="string">"items"</span>]</span><br><span class="line"></span><br><span class="line">names, plot_dicts = [], []</span><br><span class="line"><span class="keyword">for</span> repo_dict <span class="keyword">in</span> repo_dicts:</span><br><span class="line">    names.append(repo_dict[<span class="string">"name"</span>])</span><br><span class="line"></span><br><span class="line">    plot_dict = &#123;</span><br><span class="line">        <span class="comment"># 每个数据的值</span></span><br><span class="line">        <span class="string">"value"</span>: repo_dict[<span class="string">"stargazers_count"</span>],</span><br><span class="line">        <span class="comment"># 自定义每个数据的描述信息</span></span><br><span class="line">        <span class="comment"># 原文中没有将其转换成str，报错；可能现在数据类型更改了？</span></span><br><span class="line">        <span class="string">"label"</span>: str(repo_dict[<span class="string">"description"</span>]),</span><br><span class="line">        <span class="comment"># 为每个条添加网址链接</span></span><br><span class="line">        <span class="string">"xlink"</span>: repo_dict[<span class="string">"html_url"</span>],</span><br><span class="line">    &#125;</span><br><span class="line">    plot_dicts.append(plot_dict)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化</span></span><br><span class="line">my_style = LS(<span class="string">"#333366"</span>, base_style=LCS)</span><br><span class="line"><span class="comment"># 图表配置类</span></span><br><span class="line">my_config = pygal.Config()</span><br><span class="line"><span class="comment"># x轴标签顺时针旋转45度</span></span><br><span class="line">my_config.x_label_rotation = <span class="number">45</span></span><br><span class="line"><span class="comment"># 不显示图例</span></span><br><span class="line">my_config.show_legend = <span class="literal">False</span></span><br><span class="line">my_config.title_font_size = <span class="number">24</span></span><br><span class="line">my_config.label_font_size = <span class="number">14</span></span><br><span class="line"><span class="comment"># 主标签大小，y轴</span></span><br><span class="line">my_config.major_label_font_size = <span class="number">18</span></span><br><span class="line"><span class="comment"># x轴标签最长15个字符</span></span><br><span class="line">my_config.truncate_label = <span class="number">15</span></span><br><span class="line"><span class="comment"># 隐藏水平线</span></span><br><span class="line">my_config.show_y_guides = <span class="literal">False</span></span><br><span class="line">my_config.width = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">chart = pygal.Bar(my_config, style=my_style)</span><br><span class="line">chart.title = <span class="string">"Most-Starred Python Projects on GitHub"</span></span><br><span class="line">chart.x_labels = names</span><br><span class="line"></span><br><span class="line">chart.add(<span class="string">""</span>, plot_dicts)</span><br><span class="line">chart.render_to_file(<span class="string">"python_repos.svg"</span>)</span><br></pre></td></tr></table></figure>
<p>得到如下表格：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828358/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF16-%E4%BD%BF%E7%94%A8API/1524293871331.png" /></p>
<p>现在每一个数据都有自己的描述信息，并且点击它们还能跳到它们的项目网站。注意左侧y轴上的刻度，书中的刻度很密集，但同样的代码在这里不知道为什么很稀疏，所以这里没有体现出第34行代码的效果。</p>
<h1 id="hacker-news-api">4. Hacker News API</h1>
<p>Hacker News的API能让你访问该网站所有文章和评论的信息，且不用注册获取秘钥。下面通过一个API调用获取其上当前热门文章的ID，再查看前30篇文章(有可能访问不了，至于原因以及具体怎么做，你懂的)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行API调用并存储响应</span></span><br><span class="line">url = <span class="string">"https://hacker-news.firebaseio.com/v0/topstories.json"</span></span><br><span class="line">r = requests.get(url)</span><br><span class="line">print(<span class="string">"Status code:"</span>, r.status_code)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理有关每篇文章的信息</span></span><br><span class="line">submission_ids = r.json()</span><br><span class="line">submission_dicts = []</span><br><span class="line"><span class="keyword">for</span> submission_id <span class="keyword">in</span> submission_ids[:<span class="number">30</span>]:</span><br><span class="line">    <span class="comment"># 对于每篇文章，都执行一个API调用</span></span><br><span class="line">    url = (<span class="string">"https://hacker-news.firebaseio.com/v0/item/"</span> + str(submission_id) + <span class="string">".json"</span>)</span><br><span class="line">    submission_r = requests.get(url)</span><br><span class="line">    print(submission_r.status_code)</span><br><span class="line">    response_dict = submission_r.json()</span><br><span class="line"></span><br><span class="line">    submission_dict = &#123;</span><br><span class="line">        <span class="string">"title"</span>: response_dict[<span class="string">"title"</span>],</span><br><span class="line">        <span class="string">"link"</span>: <span class="string">"http://news.ycombinator.com/item?id="</span> + str(submission_id),</span><br><span class="line">        <span class="string">"comments"</span>: response_dict.get(<span class="string">"descendants"</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    submission_dicts.append(submission_dict)</span><br><span class="line"></span><br><span class="line">submission_dicts = sorted(submission_dicts, key=itemgetter(<span class="string">"comments"</span>), reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> submission_dict <span class="keyword">in</span> submission_dicts:</span><br><span class="line">    print(<span class="string">"\nTitle:"</span>, submission_dict[<span class="string">"title"</span>])</span><br><span class="line">    print(<span class="string">"Discussion link:"</span>, submission_dict[<span class="string">"link"</span>])</span><br><span class="line">    print(<span class="string">"Comments:"</span>, submission_dict[<span class="string">"comments"</span>])</span><br></pre></td></tr></table></figure>
<p>以下是输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Status code: <span class="number">200</span></span><br><span class="line"><span class="number">200</span></span><br><span class="line"><span class="number">200</span></span><br><span class="line">-- snip --</span><br><span class="line"></span><br><span class="line">Title: Wells Fargo Hit <span class="keyword">with</span> $<span class="number">1</span>B <span class="keyword">in</span> Fines</span><br><span class="line">Discussion link: http://news.ycombinator.com/item?id=16886328</span><br><span class="line">Comments: <span class="number">358</span></span><br><span class="line"></span><br><span class="line">Title: Want airline food? Take Amtrak</span><br><span class="line">Discussion link: http://news.ycombinator.com/item?id=16882231</span><br><span class="line">Comments: <span class="number">160</span></span><br><span class="line"></span><br><span class="line">-- snip --</span><br></pre></td></tr></table></figure>
<h1 id="小结">5. 小结</h1>
<p>目前已经完成了两个项目，这本书还剩最后一个Django项目，从下一篇开始，也是用三篇文章来初步了解Django，制作一个简单的web应用。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python基础</tag>
        <tag>数据可视化</tag>
        <tag>pygal</tag>
        <tag>web api</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路15-下载数据</title>
    <url>/2018/04/18/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF15-%E4%B8%8B%E8%BD%BD%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<blockquote>
<p>《Python编程：从入门到实践》笔记。 本篇是Python数据处理的第二篇，本篇将使用网上下载的数据，对这些数据进行可视化。</p>
</blockquote>
<a id="more"></a>
<h1 id="前言">1. 前言</h1>
<p>本篇将访问并可视化以两种常见格式存储的数据：CSV和JSON：</p>
<ul>
<li>使用Python的<code>csv</code>模块来处理以CSV（逗号分隔的值）格式存储的天气数据，找出两个不同地区在一段时间内的最高温度和最低温度；</li>
<li>使用<code>json</code>模块来访问以JSON格式存储的交易收盘价数据。</li>
</ul>
<p>本文数据均可从图书官网下载( http://www.ituring.com.cn/book/1861 )。</p>
<h1 id="csv文件格式">2. CSV文件格式</h1>
<p>新建一个项目，将文件<code>death_valley_2014.csv</code>复制到项目根目录，并新建<code>highs_lows.py</code>文件，改程序读取加州死亡谷2014年的温度数据，提取出每天的最高和最低气温，并绘制出折线图：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">filename = <span class="string">"death_valley_2014.csv"</span></span><br><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> f:</span><br><span class="line">    reader = csv.reader(f)</span><br><span class="line">    header_row = next(reader)</span><br><span class="line"></span><br><span class="line">    dates, highs, lows = [], [], []</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            current_date = datetime.strptime(row[<span class="number">0</span>], <span class="string">"%Y-%m-%d"</span>)</span><br><span class="line">            high = int(row[<span class="number">1</span>])</span><br><span class="line">            low = int(row[<span class="number">3</span>])</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            print(current_date, <span class="string">"missing data"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dates.append(current_date)</span><br><span class="line">            highs.append(high)</span><br><span class="line">            lows.append(low)</span><br><span class="line"></span><br><span class="line">fig = plt.figure(dpi=<span class="number">141</span>, figsize=(<span class="number">10</span>, <span class="number">6</span>))</span><br><span class="line"><span class="comment"># 绘制最高气温折线图</span></span><br><span class="line">plt.plot(dates, highs, c=<span class="string">"red"</span>)</span><br><span class="line"><span class="comment"># 绘制最低气温折线图</span></span><br><span class="line">plt.plot(dates, lows, c=<span class="string">"blue"</span>)</span><br><span class="line"><span class="comment"># 填充两个折现之间的空间，alpha为透明度，0为全透明，1为不透明</span></span><br><span class="line">plt.fill_between(dates, highs, lows, facecolor=<span class="string">"blue"</span>, alpha=<span class="number">0.1</span>)</span><br><span class="line">plt.title(<span class="string">"Daily high and low temperatures - 2014\nDeath Valley, CA"</span>, fontsize=<span class="number">20</span>)</span><br><span class="line">plt.xlabel(<span class="string">""</span>, fontsize=<span class="number">16</span>)</span><br><span class="line"><span class="comment"># 自动排版x轴的日期数据，避免重叠</span></span><br><span class="line">fig.autofmt_xdate()</span><br><span class="line">plt.ylabel(<span class="string">"Temperature(F)"</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">plt.tick_params(axis=<span class="string">"both"</span>, which=<span class="string">"major"</span>, labelsize=<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>代码现将文件打开，然后通过<code>csv.reader()</code>函数创建一个CSV文件阅读器，参数就是刚才打开的文件；通过<code>next()</code>函数读取文件的一行，并自动将数据转换为列表；然后通过一个<code>for</code>循环读取全部数据。<code>for</code>循环中还添加了错误检查，以防文件中数据丢失等问题造成程序终止。我们还通过<code>fill_between()</code>函数将两个折现之间的区域着色。最后得到的图像如下：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828329/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF15-%E4%B8%8B%E8%BD%BD%E6%95%B0%E6%8D%AE/1524034941829.png" /></p>
<p>同时我们还得到了一条信息输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">2014</span><span class="number">-02</span><span class="number">-16</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> missing data</span><br></pre></td></tr></table></figure>
<p>即该日的数据丢失了。</p>
<h1 id="制作交易收盘价走势图json格式">3. 制作交易收盘价走势图：JSON格式</h1>
<p>现将将<code>btc_close_2017.json</code>拷贝到项目根目录下。本节中将绘制5幅图像：收盘折线图，收盘价对数变换，收盘价月日均值，收盘价周日均值，收盘价星期均值。均使用<code>Pygal</code>绘制。</p>
<h2 id="绘制收盘价折线图">3.1 绘制收盘价折线图</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> pygal</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据加载到一个列表中,列表中的元素是字典</span></span><br><span class="line">filename = <span class="string">"btc_close_2017.json"</span></span><br><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> f:</span><br><span class="line">    btc_data = json.load(f)</span><br><span class="line"></span><br><span class="line">dates, months, weeks, weekdays, close = [], [], [], [], []</span><br><span class="line"><span class="keyword">for</span> btc_dict <span class="keyword">in</span> btc_data:</span><br><span class="line">    dates.append(btc_dict[<span class="string">"date"</span>])</span><br><span class="line">    months.append(int(btc_dict[<span class="string">"month"</span>]))</span><br><span class="line">    weeks.append(int(btc_dict[<span class="string">"week"</span>]))</span><br><span class="line">    weekdays.append(btc_dict[<span class="string">"weekday"</span>])</span><br><span class="line">    close.append(int(float(btc_dict[<span class="string">"close"</span>])))</span><br><span class="line"></span><br><span class="line"><span class="comment"># x轴坐标上的刻度顺时针旋转20度</span></span><br><span class="line">line_chart = pygal.Line(x_label_rotation=<span class="number">20</span>, show_minor_x_labels=<span class="literal">False</span>)</span><br><span class="line">line_chart.title = <span class="string">"收盘价(¥)"</span></span><br><span class="line">line_chart.x_labels = dates</span><br><span class="line">N = <span class="number">20</span>  <span class="comment"># x轴坐标每隔20天显示一次</span></span><br><span class="line">line_chart.x_labels_major = dates[::N]</span><br><span class="line">line_chart.add(<span class="string">"收盘价"</span>, close)</span><br><span class="line">line_chart.render_to_file(<span class="string">"收盘价折线图(¥).svg"</span>)</span><br></pre></td></tr></table></figure>
<p>最后得到的图像如下：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828326/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF15-%E4%B8%8B%E8%BD%BD%E6%95%B0%E6%8D%AE/1524037846975.png" /></p>
<h2 id="收盘价对数变换">3.2 收盘价对数变换</h2>
<p>从上图可以看出，收盘价基本呈指数增长，但其中有一些相似的波动（3,6,9月）。尽管这些波动被增长的趋势掩盖了，但也许其中有周期性。为了验证周期性的假设，需要首先将非线性的趋势消除。对数变换是常用的处理方法之一。我们使用Python标准库中的<code>math</code>模块来解决此问题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">-- snip --</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">line_chart = pygal.Line(x_label_rotation=<span class="number">20</span>, show_minor_x_labels=<span class="literal">False</span>)</span><br><span class="line">line_chart.title = <span class="string">"收盘价对数变换(¥)"</span></span><br><span class="line">line_chart.x_labels = dates</span><br><span class="line">N = <span class="number">20</span>  <span class="comment"># x轴坐标每隔20天显示一次</span></span><br><span class="line">line_chart.x_labels_major = dates[::N]</span><br><span class="line"><span class="comment"># 对数变换</span></span><br><span class="line">close_log = [math.log10(_) <span class="keyword">for</span> _ <span class="keyword">in</span> close]</span><br><span class="line">line_chart.add(<span class="string">"log收盘价"</span>, close_log)</span><br><span class="line">line_chart.render_to_file(<span class="string">"收盘价对数变换折线图(¥).svg"</span>)</span><br></pre></td></tr></table></figure>
<p>得到了如下图像：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828325/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF15-%E4%B8%8B%E8%BD%BD%E6%95%B0%E6%8D%AE/1524038394012.png" /></p>
<p>可以看出，3,6,9月都出现了剧烈的波动。下面再看看收盘价的月日均值和周日均值。</p>
<h2 id="收盘价均值">3.3 收盘价均值</h2>
<h3 id="月日均值">3.3.1 月日均值</h3>
<p><strong>在继续新的代码之前，需要补充一些知识：</strong>对于<code>zip()</code>函数，它将多个列表按照元素的位置组成新的列表，而新列表的元素是元组。如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码</span></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">c = [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">zipped_1 = zip(a,b)</span><br><span class="line">zipped_2 = zip(a, b, c)</span><br><span class="line">print(zipped_1)</span><br><span class="line">print(list(zipped_1))</span><br><span class="line">print(list(zipped_2))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">&lt;zip object at <span class="number">0x0000021D732DCDC8</span>&gt;</span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">6</span>)]</span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>), (<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>), (<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>)]</span><br></pre></td></tr></table></figure>
<p>在python2中，<code>zip()</code>直接返回一个列表，但在python3中，<code>zip()</code>返回一个可迭代的<code>zip</code>对象，这里我们将其转化为列表。也在前面加星号对<code>zip</code>对象进行“解压”（解包）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">print(*zipped_1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">4</span>) (<span class="number">2</span>, <span class="number">5</span>) (<span class="number">3</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p>星号不止能对<code>zip</code>对象进行解包，还可以对<code>list</code>等类型进行解包。</p>
<p>我们还会用到<code>groupby()</code>函数，但在使用该函数之前，需要对列表进行排序。我们使用<code>sorted()</code>函数进行排序，python3中<code>sorted()</code>函数默认按照元素顺序进行比较，比如这里的列表的元素是元组，则<code>sorted()</code>先比较元组中第一个元素的值，再比较第二个元素的值，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">test = [(<span class="number">1</span>, <span class="number">5</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>)]</span><br><span class="line">print(sorted(test))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">1</span>, <span class="number">5</span>), (<span class="number">2</span>, <span class="number">3</span>)]</span><br></pre></td></tr></table></figure>
<p>接下来通过<code>groupby()</code>函数对这些数据进行分组，通过关键字参数<code>key=itemgetter(0)</code>指定根据列表元素（即元组）的第一个值进行分组。也可以将这里的<code>itemgetter()</code>函数替换为<code>lambda</code>表达式，如等价的<code>lambda</code>表达式为<code>lambda x: x[0]</code>。在python3中，<code>groupby()</code>返回一个可迭代的<code>groupby</code>对象，如果将其转换成<code>list</code>，<code>list</code>中的每个元素的第二个值也是个可迭代对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">test = [(<span class="number">1</span>, <span class="number">5</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">3</span>, <span class="number">5</span>)]</span><br><span class="line">temp = groupby(sorted(test), key=itemgetter(<span class="number">0</span>))</span><br><span class="line">print(temp)</span><br><span class="line">print(list(temp))</span><br><span class="line"><span class="keyword">for</span> a, b <span class="keyword">in</span> temp:</span><br><span class="line">    print(list(b))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">&lt;itertools.groupby object at <span class="number">0x0000013CD9A4D458</span>&gt;</span><br><span class="line">[(<span class="number">1</span>, &lt;itertools._grouper object at <span class="number">0x0000013CE8AAE160</span>&gt;), </span><br><span class="line"> (<span class="number">2</span>, &lt;itertools._grouper object at <span class="number">0x0000013CE8AAE128</span>&gt;), </span><br><span class="line"> (<span class="number">3</span>, &lt;itertools._grouper object at <span class="number">0x0000013CE8AAE198</span>&gt;)]</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">1</span>, <span class="number">5</span>)]</span><br><span class="line">[(<span class="number">2</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>)]</span><br><span class="line">[(<span class="number">3</span>, <span class="number">5</span>)]</span><br></pre></td></tr></table></figure>
<p>从上面的<code>for</code>循环的结果来看，可以将<code>groupby()</code>返回的对象看做一个字典，该字典的键为上面的<code>key</code>的值，该字典的值为还没分组时列表中的部分元素（可能组成了列表，也可能组成了元组）。</p>
<p><strong>现在言归正传，回到主线。</strong></p>
<p>绘制2017年前11个月的日均值，前49周的日均值，以及每周中各天（Monday~Sunday）的日均值。首先我们需要封装一些代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> groupby</span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_line</span><span class="params">(x_data, y_data, title, y_legend)</span>:</span></span><br><span class="line">    xy_map = []</span><br><span class="line">    <span class="comment"># 本段见后面解释</span></span><br><span class="line">    <span class="keyword">for</span> x, y <span class="keyword">in</span> groupby(sorted(zip(x_data, y_data)), key=itemgetter(<span class="number">0</span>)):</span><br><span class="line">        y_list = [v <span class="keyword">for</span> _, v <span class="keyword">in</span> y]</span><br><span class="line">        xy_map.append([x, sum(y_list) / len(y_list)])</span><br><span class="line">    x_unique, y_mean = [*zip(*xy_map)]</span><br><span class="line">    line_chart = pygal.Line()</span><br><span class="line">    line_chart.title = title</span><br><span class="line">    line_chart.x_labels = x_unique</span><br><span class="line">    line_chart.add(y_legend, y_mean)</span><br><span class="line">    line_chart.render_to_file(title + <span class="string">".svg"</span>)</span><br><span class="line">    <span class="keyword">return</span> line_chart</span><br></pre></td></tr></table></figure>
<p><strong>本段代码有些绕。</strong>从前面的介绍可以知道，<code>for</code>循环中的变量<code>y</code>相当于一个<code>list</code>，这个<code>list</code>的元素是<code>tuple</code>，<code>tuple</code>的第一个元素是<code>x_data</code>中的值，不再重复需要，所以取第二个值组成<code>list</code>，即第8行代码。<code>xy_map</code>是个<code>list</code>对象，而它的元素也是<code>list</code>，即它是一个二维数组。注意第10行的操作，<code>*xy_map</code>将<code>list</code>进行解包，<code>zip()</code>函数将解包后的元素再次打包成一个<code>zip</code>对象，如果将其看做<code>list</code>对象，则这个对象含有两个<code>tuple</code>元素，然后将这个<code>zip</code>对象也解包，最外面再套一层<code>list</code>，得到一个含两个<code>tuple</code>元素的<code>list</code>，最后再平行赋值。为了更具体的体现这段操作，下面用一些简单数据进行模拟：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">temp = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line">x, y = [*zip(*temp)]</span><br><span class="line">print(x)</span><br><span class="line">print(y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p>最后，终于到了画图阶段：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">-- 读取文件内容的代码和前面一样 --</span><br><span class="line">idx_month = dates.index(<span class="string">"2017-12-01"</span>)</span><br><span class="line">line_chart_month = draw_line(months[:idx_month], close[:idx_month], </span><br><span class="line">                             <span class="string">"收盘价月日均值（¥）"</span>, <span class="string">"月日均值"</span>)</span><br></pre></td></tr></table></figure>
<p>得到的结果如下：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828325/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF15-%E4%B8%8B%E8%BD%BD%E6%95%B0%E6%8D%AE/1524058805333.png" /></p>
<h3 id="周日均值">3.3.2 周日均值</h3>
<p>2017年的第一周从2017年1月2日开始，第49周周日是2017年12月10日。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">-- 读取文件内容的代码和前面一样 --</span><br><span class="line">idx_week = dates.index(<span class="string">"2017-12-11"</span>)</span><br><span class="line">line_chart_week = draw_line(weeks[<span class="number">1</span>:idx_week], close[<span class="number">1</span>:idx_week], </span><br><span class="line">                            <span class="string">"收盘价周日均值（¥）"</span>, <span class="string">"周日均值"</span>)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828328/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF15-%E4%B8%8B%E8%BD%BD%E6%95%B0%E6%8D%AE/1524059214179.png" /></p>
<h3 id="每周中各天的均值">3.3.3 每周中各天的均值</h3>
<p>如果直接用<code>weekdays</code>这个列表生成图表，由于该列表存储的是字符串，排序的时候是按<code>ASCII</code>码进行排序，最后生成的图表星期的顺序会出错，所以将其转换成数字。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">idx_week = dates.index(<span class="string">"2017-12-11"</span>)</span><br><span class="line">wd = [<span class="string">"Monday"</span>, <span class="string">"Tuesday"</span>, <span class="string">"Wednesday"</span>, <span class="string">"Thursday"</span>, <span class="string">"Friday"</span>, <span class="string">"Saturday"</span>,</span><br><span class="line">      <span class="string">"Sunday"</span>]</span><br><span class="line">weekdays_int = [wd.index(w) + <span class="number">1</span> <span class="keyword">for</span> w <span class="keyword">in</span> weekdays[<span class="number">1</span>:idx_week]]</span><br><span class="line">line_chart_weekday = draw_line(weekdays_int, close[<span class="number">1</span>:idx_week], </span><br><span class="line">                               <span class="string">"收盘价星期均值（¥）"</span>, <span class="string">"星期均值"</span>)</span><br><span class="line">line_chart_weekday.x_labels = [<span class="string">"周一"</span>, <span class="string">"周二"</span>, <span class="string">"周三"</span>, <span class="string">"周四"</span>, <span class="string">"周五"</span>, <span class="string">"周六"</span>, <span class="string">"周日"</span>]</span><br><span class="line">line_chart_weekday.render_to_file(<span class="string">"收盘价星期均值（¥）.svg"</span>)</span><br></pre></td></tr></table></figure>
<p>最后的结果如下：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828328/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF15-%E4%B8%8B%E8%BD%BD%E6%95%B0%E6%8D%AE/1524059980723.png" /></p>
<h2 id="收盘价数据仪表盘">3.4 收盘价数据仪表盘</h2>
<p>最后我们将五张表整合到一个文件中，做成一个仪表盘：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'收盘价Dashboard.html'</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf8'</span>) <span class="keyword">as</span> html_file:</span><br><span class="line">    title = <span class="string">'&lt;html&gt;&lt;head&gt;&lt;title&gt;收盘价Dashboard&lt;/title&gt;&lt;meta charset="utf-8"&gt;&lt;/head&gt;&lt;body&gt;\n'</span></span><br><span class="line">    html_file.write(title)</span><br><span class="line">    <span class="keyword">for</span> svg <span class="keyword">in</span> [</span><br><span class="line">        <span class="string">'收盘价折线图（¥）.svg'</span>, <span class="string">'收盘价对数变换折线图（¥）.svg'</span>, <span class="string">'收盘价月日均值（¥）.svg'</span>,</span><br><span class="line">        <span class="string">'收盘价周日均值（¥）.svg'</span>, <span class="string">'收盘价星期均值（¥）.svg'</span></span><br><span class="line">    ]:</span><br><span class="line">        html_file.write(</span><br><span class="line">            <span class="string">'    &lt;object type="image/svg+xml" data="&#123;0&#125;" height=500&gt;&lt;/object&gt;\n'</span>.format(svg))</span><br><span class="line">    html_file.write(<span class="string">'&lt;/body&gt;&lt;/html&gt;'</span>)</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828327/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF15-%E4%B8%8B%E8%BD%BD%E6%95%B0%E6%8D%AE/1524060462234.png" /></p>
<p>这是将浏览器放大后的效果，默认100%的话这五张图都在同一行，且非常小。</p>
<h1 id="小结">4. 小结</h1>
<p>本篇中主要内容有：</p>
<ul>
<li>如何使用网上的数据集；</li>
<li>如何处理CSV和JSON文件，以及如何提取你感兴趣的数据；</li>
<li>如何使用<code>matplotlib</code>来处理以往的天气数据，包括如何使用<code>datetime</code>模块，以及如何在同一个图表中绘制多个数据系列；</li>
<li>如何<code>json</code>模块来访问JSON格式存储的交易收盘价数据，并使用<code>Pygal</code>绘制图形以探索价格变化的周期性，以及如何将<code>Pygal</code>图形组合成数据仪表盘。</li>
</ul>
<p>下一篇将从网上采集数据并对其进行可视化。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python基础</tag>
        <tag>数据可视化</tag>
        <tag>matplotlib</tag>
        <tag>pygal</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路14-生成数据</title>
    <url>/2018/04/17/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF14-%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<blockquote>
<p>《Python编程：从入门到实践》笔记。 从本篇起将用三篇的篇幅介绍如何用Python进行数据可视化。</p>
</blockquote>
<a id="more"></a>
<h1 id="前言">1. 前言</h1>
<p>从本篇开始，我们将用三篇的篇幅来初步介绍如何使用Python来进行数据可视化操作。本篇的内容包括：</p>
<ul>
<li>绘制简单的折线图；</li>
<li>随机漫步；</li>
<li>使用<code>Pygal</code>模拟掷骰子。</li>
</ul>
<p>在正式开始之前，需要安装两个扩展包：<code>matplotlib</code>和<code>pygal</code>。Python中安装第三方库的方式已在上一个项目中介绍过了，这里不再赘述。</p>
<h1 id="绘制简单的折线图">2. 绘制简单的折线图</h1>
<h2 id="简单的折线图">2.1 简单的折线图</h2>
<p>首先我们绘制一个简单的折线图，代码保存到<code>mpl_squares.py</code>文件中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入数据, x轴</span></span><br><span class="line">input_values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment"># 输出数据, y轴</span></span><br><span class="line">squares = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line"><span class="comment"># linewidth表示线条的粗细</span></span><br><span class="line">plt.plot(input_values, squares, linewidth=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置图标标题，并给坐标轴加上标签</span></span><br><span class="line">plt.title(<span class="string">"Square Numbers"</span>, fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">"Value"</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">"Square of Value"</span>, fontsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置刻度标记的大小</span></span><br><span class="line">plt.tick_params(axis=<span class="string">"both"</span>, labelsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><code>matplotlib.pyplot.plot()</code>函数可以只传入一个<code>squares</code>参数，表示<code>y</code>轴的值，此时将从<code>x</code>轴0点处开始一一对应。有时这样很简便，但在此例中图标将不正确，所以我们传入了<code>input_values</code>列表，将其与<code>squares</code>列表一一对应。</p>
<p>代码从第10行到15行都可以省了，这些代码只是让图表的信息更全。最终的结果如下：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828284/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF14-%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE/1523965060972.png" /></p>
<h2 id="生成散点图">2.2 生成散点图</h2>
<p>我们使用<code>matplotlib.pyplot</code>中的<code>scatter()</code>函数来生成散点图，将代码保存到<code>scatter_squares.py</code>文件中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x_values = list(range(<span class="number">1</span>, <span class="number">1001</span>))</span><br><span class="line">y_values = [x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> x_values]</span><br><span class="line"></span><br><span class="line"><span class="comment"># s表示点的大小，edgecolor表示点的轮廓的颜色,c表示数据点的颜色(可以使用RGB颜色)</span></span><br><span class="line"><span class="comment"># plt.scatter(x_values, y_values, s=4, edgecolor="none", c="red")</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用渐变色, 给c赋值了一个y值列表，并使用参数cmap告诉pylot使用哪个颜色来映射</span></span><br><span class="line">plt.scatter(x_values, y_values, s=<span class="number">40</span>, edgecolor=<span class="string">"none"</span>, c=y_values, cmap=plt.cm.Blues)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置图表标题并给坐标轴加上标签</span></span><br><span class="line">plt.title(<span class="string">"Square Number"</span>, fontsize=<span class="number">24</span>)</span><br><span class="line">plt.xlabel(<span class="string">"Value"</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">"Square of Value"</span>, fontsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置刻度的大小</span></span><br><span class="line">plt.tick_params(axis=<span class="string">"both"</span>, which=<span class="string">"major"</span>, labelsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个坐标轴的取值范围</span></span><br><span class="line">plt.axis([<span class="number">0</span>, <span class="number">1100</span>, <span class="number">0</span>, <span class="number">1100000</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一个参数是路径名，第二个参数指定将图表多余的空白区域裁减掉。</span></span><br><span class="line">plt.savefig(<span class="string">"squares.png"</span>, bbox_inches=<span class="string">"tight"</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>我们使用了列表生成式来生成y轴的数据，并使用渐变色来绘制图像，<code>matplotlib.pyplot.cm.Blues</code>是<code>matplotlib</code>自带的渐变色，它和<code>c</code>的每一个值对应。通过<code>pyplot</code>的<code>axis()</code>函数来设置每个轴的取值范围。最后将图像保存到本地。生成的图像如下：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828284/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF14-%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE/1523967507756.png" /></p>
<h1 id="随机漫步">3. 随机漫步</h1>
<p>随机漫步指的是：每次行走都完全随机，没有明确的方向，结果是由一系列随机决策决定的。在自然界、物理学、生物学、化学和经济领域，随机漫步都有其实际用途。</p>
<p>使用Python生成随机漫步数据，再使用<code>matplotlib</code>将这些数据绘制出来。首先创建<code>RandomWalk</code>类，代码保存到<code>random_walk.py</code>文件中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomWalk</span>:</span></span><br><span class="line">    <span class="string">"""一个生成随机漫步数据的类"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num_points=<span class="number">5000</span>)</span>:</span></span><br><span class="line">        <span class="string">"""初始化随机漫步的属性"""</span></span><br><span class="line">        self.num_points = num_points</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 所有随机漫步都始于(0, 0)，这两个列表用于存储随机漫步数据</span></span><br><span class="line">        self.x_values = [<span class="number">0</span>]</span><br><span class="line">        self.y_values = [<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fill_walk</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""计算随机漫步包含的所有点"""</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 不断漫步，直到列表到达指定的长度</span></span><br><span class="line">        <span class="keyword">while</span> len(self.x_values) &lt; self.num_points:</span><br><span class="line">            <span class="comment"># 决定前进方向以及沿这个方向前进的距离</span></span><br><span class="line">            <span class="comment"># 通过choice从给定值中随机选取</span></span><br><span class="line">            x_direction = choice([<span class="number">1</span>, <span class="number">-1</span>])  <span class="comment"># 正向还是负向</span></span><br><span class="line">            x_distance = choice([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])  <span class="comment"># 移动的距离</span></span><br><span class="line">            x_step = x_direction * x_distance</span><br><span class="line"></span><br><span class="line">            y_direction = choice([<span class="number">1</span>, <span class="number">-1</span>])</span><br><span class="line">            y_distance = choice([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">            y_step = y_direction * y_distance</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 拒绝原地踏步</span></span><br><span class="line">            <span class="keyword">if</span> x_step == <span class="number">0</span> <span class="keyword">and</span> y_step == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 计算下一个点的坐标</span></span><br><span class="line">            next_x = self.x_values[<span class="number">-1</span>] + x_step</span><br><span class="line">            next_y = self.y_values[<span class="number">-1</span>] + y_step</span><br><span class="line"></span><br><span class="line">            self.x_values.append(next_x)</span><br><span class="line">            self.y_values.append(next_y)</span><br></pre></td></tr></table></figure>
<p>下面的代码用于生成随机漫步图像，代码保存到<code>rw_visual.py</code>文件中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> random_walk <span class="keyword">import</span> RandomWalk</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    rw = RandomWalk(<span class="number">50000</span>)</span><br><span class="line">    rw.fill_walk()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置绘图窗口的尺寸</span></span><br><span class="line">    plt.figure(figsize=(<span class="number">10</span>, <span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绘制随机漫步的图像</span></span><br><span class="line">    point_number = list(range(rw.num_points))</span><br><span class="line">    plt.scatter(rw.x_values, rw.y_values, s=<span class="number">1</span>, c=point_number,</span><br><span class="line">                edgecolors=<span class="string">"none"</span>, cmap=plt.cm.Blues)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 突出起点和终点</span></span><br><span class="line">    plt.scatter(<span class="number">0</span>, <span class="number">0</span>, c=<span class="string">"green"</span>, edgecolors=<span class="string">"none"</span>, s=<span class="number">100</span>)</span><br><span class="line">    plt.scatter(rw.x_values[<span class="number">-1</span>], rw.y_values[<span class="number">-1</span>], c=<span class="string">"red"</span>, edgecolors=<span class="string">"none"</span>,</span><br><span class="line">                s=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 隐藏坐标轴</span></span><br><span class="line">    plt.axes().get_xaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line">    plt.axes().get_yaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> input(<span class="string">"Make another walk?(y/n)"</span>) == <span class="string">"n"</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>程序通过一个循环类多次绘制随机漫步图；通过<code>pyplot</code>的<code>figure()</code>函数来设置图像的尺寸，<code>figsize</code>的单位是英寸；通过渐变色来绘制图像的路径，颜色由浅到深，并且我们将起点（绿色）和终点（红色）显著标出；最后隐藏坐标轴。最终的图像如下（每次运行的效果都不同）：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828294/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF14-%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE/1523970221035.png" /></p>
<h1 id="使用pygal模拟掷骰子">4. 使用Pygal模拟掷骰子</h1>
<p>首先我们需要创建一个骰子类<code>Dice</code>，将其保存到<code>dice.py</code>中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dice</span>:</span></span><br><span class="line">    <span class="string">"""表示一个骰子类"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num_sides=<span class="number">6</span>)</span>:</span></span><br><span class="line">        <span class="string">"""骰子默认为6面"""</span></span><br><span class="line">        self.num_sides = num_sides</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">roll</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回一个位于1和骰子面数之间的随机值"""</span></span><br><span class="line">        <span class="keyword">return</span> randint(<span class="number">1</span>, self.num_sides)</span><br></pre></td></tr></table></figure>
<p>可以自行设定骰子的面数。下面是掷两个骰子50000次，统计俩骰子点数之和的分布的模拟，最后生成了一个矢量文件<code>.svg</code>文件，它能在浏览器中打开，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pygal</span><br><span class="line"><span class="keyword">from</span> dice <span class="keyword">import</span> Dice</span><br><span class="line"></span><br><span class="line">dice_1 = Dice()</span><br><span class="line">dice_2 = Dice(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 掷骰子多次，并将结果存储在一个列表中</span></span><br><span class="line">results = []</span><br><span class="line"><span class="keyword">for</span> roll_num <span class="keyword">in</span> range(<span class="number">50000</span>):</span><br><span class="line">    results.append(dice_1.roll() + dice_2.roll())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分析结果</span></span><br><span class="line">frequences = []</span><br><span class="line"><span class="comment"># 能够模拟掷任何双骰子的情况，不管这些骰子有多少面</span></span><br><span class="line">max_result = dice_1.num_sides + dice_2.num_sides</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> range(<span class="number">2</span>, max_result + <span class="number">1</span>):</span><br><span class="line">    <span class="comment"># 统计每个结果的频数</span></span><br><span class="line">    frequences.append(results.count(value))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对结果进行可视化</span></span><br><span class="line"><span class="comment"># 创建条形图</span></span><br><span class="line">hist = pygal.Bar()</span><br><span class="line"></span><br><span class="line">hist.title = <span class="string">"Result of rolling a D6 and a D10 50000 times."</span></span><br><span class="line"><span class="comment"># 创建x轴上的刻度</span></span><br><span class="line">hist.x_labels = [str(value) <span class="keyword">for</span> value <span class="keyword">in</span> range(<span class="number">2</span>, max_result + <span class="number">1</span>)]</span><br><span class="line">hist.x_title = <span class="string">"Result"</span></span><br><span class="line">hist.y_title = <span class="string">"Frequency of Result"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给这组数据起个名字，并加到图表中</span></span><br><span class="line">hist.add(<span class="string">"D6 + D10"</span>, frequences)</span><br><span class="line"><span class="comment"># 将图像渲染为svg文件，矢量图</span></span><br><span class="line">hist.render_to_file(<span class="string">"dice_visual.svg"</span>)</span><br></pre></td></tr></table></figure>
<p>注意，<code>frequences</code>中的数据依次与<code>hist.x_labels</code>对应。下面是最终结果：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828287/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF14-%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE/1523978508082.png" /></p>
<p><code>Pygal</code>让这个图表具有交互性：如果你将鼠标指向该图中的任何数据条，将看到它的具体数据。</p>
<h1 id="小结">5. 小结</h1>
<p>本篇主要讲述了：</p>
<ul>
<li>如何生成数据集以及如何对其进行可视化；</li>
<li>如何使用<code>matplotlib</code>创建简单的图表；</li>
<li>如果使用散点图来探索随机漫步过程；</li>
<li>如何使用<code>Pygal</code>创建直方图，以及如何使用直方图来探索同时掷两个面数不同的骰子的结果。</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python基础</tag>
        <tag>数据可视化</tag>
        <tag>matplotlib</tag>
        <tag>pygal</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路13-记分</title>
    <url>/2018/04/16/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF13-%E8%AE%B0%E5%88%86/</url>
    <content><![CDATA[<blockquote>
<p>《Python编程：从入门到实践》笔记。 本篇是Python小游戏《外星人入侵》的最后一篇。</p>
</blockquote>
<a id="more"></a>
<h1 id="前言">1. 前言</h1>
<p>本篇我们将结束Pygame小游戏《外星人入侵》的开发。在本篇中，我们将添加如下内容：</p>
<ul>
<li>添加一个Play按钮，用于根据需要启动游戏以及在游戏结束后重启游戏；</li>
<li>使玩家能提高等级，并在提高等级时加快节奏；</li>
<li>添加一个记分系统</li>
</ul>
<h1 id="添加play按钮">2. 添加Play按钮</h1>
<p>首先为了通过点击Play按钮来开始游戏，需要在<code>GameStats</code>类的构造函数中将<code>self.game_active</code>设置为<code>False</code>。</p>
<h2 id="button类">2.1 Button类</h2>
<p>为了添加<code>Play</code>按钮，我们需要先添加一个<code>Button</code>类。将这个类放在<code>button.py</code>模块中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ai_settings, screen, msg)</span>:</span></span><br><span class="line">        <span class="string">"""初始化按钮属性"""</span></span><br><span class="line">        self.screen = screen</span><br><span class="line">        self.screen_rect = screen.get_rect()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 设置按钮尺寸和其他属性</span></span><br><span class="line">        self.width, self.height = <span class="number">200</span>, <span class="number">50</span>   <span class="comment"># 解包，平行赋值</span></span><br><span class="line">        self.button_color = (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>)</span><br><span class="line">        self.text_color = (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>)</span><br><span class="line">        self.font = pygame.font.SysFont(<span class="literal">None</span>, <span class="number">48</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 创建按钮的rect对象，并使其居中</span></span><br><span class="line">        self.rect = pygame.Rect(<span class="number">0</span>, <span class="number">0</span>, self.width, self.height)</span><br><span class="line">        self.rect.center = self.screen_rect.center</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 按钮的标签只需创建一次</span></span><br><span class="line">        self.prep_msg(msg)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prep_msg</span><span class="params">(self, msg)</span>:</span></span><br><span class="line">        <span class="string">"""将msg渲染为图像，并使其在按钮上居中"""</span></span><br><span class="line">        self.msg_image = self.font.render(msg, <span class="literal">True</span>, self.text_color, self.button_color)</span><br><span class="line">        self.msg_image_rect = self.msg_image.get_rect()</span><br><span class="line">        self.msg_image_rect.center = self.rect.center</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw_button</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 绘制一个用颜色填充的按钮，再绘制文本</span></span><br><span class="line">        self.screen.fill(self.button_color, self.rect)</span><br><span class="line">        self.screen.blit(self.msg_image, self.msg_image_rect)</span><br></pre></td></tr></table></figure>
<p>pygame将字符串渲染为图像来处理文本，通过<code>pygame.font</code>的<code>render()</code>方法来渲染文字，它的第一个参数是要渲染的字符串，第二个是抗锯齿设定（打游戏的老铁应该对这个词很熟悉~~），第三个是字体颜色，第四个是背景颜色，第四个参数如果不设定，将以透明背景的方式渲染文本。最后通过<code>draw_button()</code>方法在窗体中绘制<code>Play</code>按钮。</p>
<h2 id="修改alien_invasion.py">2.2 修改alien_invasion.py</h2>
<p>在主程序中实例化一个<code>Play</code>按钮，并添加它的响应事件，以及将其画出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">-- snip --</span><br><span class="line"><span class="keyword">from</span> button <span class="keyword">import</span> Button</span><br><span class="line">-- snip --</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_game</span><span class="params">()</span>:</span></span><br><span class="line">    -- snip --</span><br><span class="line">    pygame.display.set_caption(<span class="string">"Alien Invasion"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建Play按钮</span></span><br><span class="line">    play_button = Button(ai_settings, screen, <span class="string">"Play"</span>)</span><br><span class="line">    </span><br><span class="line">    -- snip --</span><br><span class="line">    <span class="comment"># 开始游戏的主循环</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 增加了参数，为按钮添加响应事件</span></span><br><span class="line">        gf.check_events(ai_settings, screen, ship, bullets, stats, play_button, aliens)</span><br><span class="line">        -- snip --</span><br><span class="line">        <span class="comment"># 增加了参数，在窗体中画出按钮</span></span><br><span class="line">        gf.update_screen(ai_settings, screen, ship, bullets, aliens, stats, play_button)</span><br><span class="line"></span><br><span class="line">run_game()</span><br></pre></td></tr></table></figure>
<p>注意，不光新增了实例化按钮的代码，还修改了<code>update_screen()</code>和<code>check_events()</code>函数。</p>
<h2 id="修改game_functions.py">2.3 修改game_functions.py</h2>
<p><strong>修改update_screen()函数</strong>：在窗体中画出<code>Play</code>按钮</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 增加了参数，记得修改主程序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_screen</span><span class="params">(ai_settings, screen, ship, bullets, aliens, stats, play_button)</span>:</span></span><br><span class="line">    -- snip --</span><br><span class="line">    <span class="comment"># 如果游戏没启动，则显示Play按钮</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> stats.game_active:</span><br><span class="line">        play_button.draw_button()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 让最近绘制的屏幕可见</span></span><br><span class="line">    pygame.display.flip()</span><br></pre></td></tr></table></figure>
<p><strong>修改check_events()函数</strong>：为<code>Play</code>按钮添加响应事件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 增加了参数，记得修改主程序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_events</span><span class="params">(ai_settings, screen, ship, bullets, stats, play_button, aliens)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> event <span class="keyword">in</span> pygame.event.get():</span><br><span class="line">        -- snip --</span><br><span class="line">        <span class="keyword">elif</span> event.type == pygame.MOUSEBUTTONDOWN:</span><br><span class="line">            mouse_x, mouse_y = pygame.mouse.get_pos()</span><br><span class="line">            check_play_button(stats, play_button, mouse_x, mouse_y, ai_settings,</span><br><span class="line">                              screen, ship, aliens, bullets)</span><br></pre></td></tr></table></figure>
<p><code>pygame.MOUSEBUTTONDOWN</code>表示鼠标按下事件；通过<code>pygame.mouse</code>的<code>get_pos()</code>来获得鼠标点击处的坐标；最后，通过<code>check_play_button()</code>函数来响应鼠标点击事件，该函数的内容如下：</p>
<p><strong>新增check_play_button()函数</strong>：处理鼠标点击事件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_play_button</span><span class="params">(stats, play_button, mouse_x, mouse_y, ai_settings, screen,</span></span></span><br><span class="line"><span class="function"><span class="params">                      ship, aliens, bullets)</span>:</span></span><br><span class="line">    <span class="string">"""在玩家单机Play按钮时开始新游戏"""</span></span><br><span class="line">    <span class="keyword">if</span> play_button.rect.collidepoint(mouse_x, mouse_y) <span class="keyword">and</span> <span class="keyword">not</span> stats.game_active:</span><br><span class="line">        <span class="comment"># 隐藏光标</span></span><br><span class="line">        pygame.mouse.set_visible(<span class="literal">False</span>)</span><br><span class="line">        <span class="comment"># 重置游戏统计信息</span></span><br><span class="line">        stats.reset_stats()</span><br><span class="line">        stats.game_active = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 清空外星人列表和子弹列表</span></span><br><span class="line">        aliens.empty()</span><br><span class="line">        bullets.empty()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 创建一群新的外星人，并让飞船居中</span></span><br><span class="line">        create_fleet(ai_settings, screen, ship, aliens)</span><br><span class="line">        ship.center_ship()</span><br></pre></td></tr></table></figure>
<p>通过<code>play_button.rect</code>的<code>collidepoint()</code>方法来确定鼠标是否点击到了<code>button</code>，如果点击到了，并且当前游戏是“非启动”状态，则启动或者重置游戏；</p>
<p>如果不对<code>stats.game_active</code>进行确认，则在游戏中，即使<code>Play</code>按钮消失了，鼠标点击它原来所在的地方，也会重置游戏。</p>
<p>在游戏中，为了避免光标的影响，游戏时我们通过<code>pygame.mouse</code>的<code>set_visible()</code>方法将其隐藏；游戏结束时，重新显示光标，为此，需要<strong>修改ship_hit()函数</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ship_hit</span><span class="params">(ai_settings, stats, screen, ship, aliens, bullets)</span>:</span></span><br><span class="line">    -- snip --</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        -- snip --</span><br><span class="line">        pygame.mouse.set_visible(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>最后，程序的效果如下：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828259/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF13-%E8%AE%B0%E5%88%86/1523880843704.png" /></p>
<h1 id="游戏提速">3. 游戏提速</h1>
<p>每当消灭一批舰队后，我们就为游戏里的元素提个速，为此，需要修改<code>settings.py</code>和<code>game_functions.py</code>模块。</p>
<h2 id="修改settings.py">3.1 修改settings.py</h2>
<p>添加一个提速倍率参数，并增加两个方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Settings</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        -- snip --</span><br><span class="line">        <span class="comment"># 以什么样的速度提节奏</span></span><br><span class="line">        self.speedup_scale = <span class="number">1.1</span></span><br><span class="line">        <span class="comment"># 前面有四个属性放到了该方法中</span></span><br><span class="line">        self.initialize_dynamic_settings()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize_dynamic_settings</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""初始化随游戏进行而变化的设置"""</span></span><br><span class="line">        self.ship_speed_factor = <span class="number">1.5</span></span><br><span class="line">        self.bullet_speed_factor = <span class="number">3</span></span><br><span class="line">        self.alien_speed_factor = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 外星舰队方向标志：1向右，-1向左</span></span><br><span class="line">        self.fleet_direction = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increase_speed</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""提高速度"""</span></span><br><span class="line">        self.ship_speed_factor *= self.speedup_scale</span><br><span class="line">        self.bullet_speed_factor *= self.speedup_scale</span><br><span class="line">        self.alien_speed_factor *= self.speedup_scale</span><br></pre></td></tr></table></figure>
<p>我们将需要修改的四个参数放到了<code>initialize_dynamic_settings()</code>方法中，<code>increase_speed()</code>方法用于动态改变游戏参数。</p>
<h2 id="修改game_functions.py-1">3.2 修改game_functions.py</h2>
<p>每消灭一批外星舰队，就对游戏提速，需要<strong>修改check_bullet_alien_collisions()函数</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_bullet_alien_collisions</span><span class="params">(ai_settings, screen, ship, aliens, bullets)</span>:</span></span><br><span class="line">    -- snip --</span><br><span class="line">    <span class="keyword">if</span> len(aliens) == <span class="number">0</span>:</span><br><span class="line">        -- snip --</span><br><span class="line">        ai_settings.increase_speed()</span><br><span class="line">        -- snip --</span><br></pre></td></tr></table></figure>
<p>当重新开始游戏时，需要将这些被修改了的参数改回默认值，为此，需要<strong>修改check_play_button()函数</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_play_button</span><span class="params">(stats, play_button, mouse_x, mouse_y, ai_settings, screen,</span></span></span><br><span class="line"><span class="function"><span class="params">                      ship, aliens, bullets)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> play_button.rect.collidepoint(mouse_x,</span><br><span class="line">                                     mouse_y) <span class="keyword">and</span> <span class="keyword">not</span> stats.game_active:</span><br><span class="line">        <span class="comment"># 重置游戏设置</span></span><br><span class="line">        ai_settings.initialize_dynamic_settings()</span><br><span class="line">        -- snip --</span><br></pre></td></tr></table></figure>
<h1 id="记分板">4. 记分板</h1>
<p>下面我们将实现一个记分系统，实时跟踪玩家的得分，并显示最高得分，当前等级和余下的飞船数。首先，我们需要创建一个<code>Scoreboard</code>类。</p>
<h2 id="新增scoreboard.py">4.1 新增scoreboard.py</h2>
<p>新增一个<code>Scoreboard</code>类，用作屏幕中的记分板，它的屏幕正中央上方部分是最高分数，屏幕右边是当前分数和等级，左上角是剩余的飞船数量，飞船数量用图片表示，因此，我们<strong>还要将Ship类更改为从Sprite继承</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"><span class="keyword">from</span> pygame.sprite <span class="keyword">import</span> Group</span><br><span class="line"><span class="keyword">from</span> ship <span class="keyword">import</span> Ship</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scoreboard</span>:</span></span><br><span class="line">    <span class="string">"""显示得分信息的类"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ai_settings, screen, stats)</span>:</span></span><br><span class="line">        <span class="string">"""初始化显示得分涉及的属性"""</span></span><br><span class="line">        self.screen = screen</span><br><span class="line">        self.screen_rect = screen.get_rect()</span><br><span class="line">        self.ai_settings = ai_settings</span><br><span class="line">        self.stats = stats</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 显示得分信息时使用的字体设置</span></span><br><span class="line">        self.text_color = (<span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>)</span><br><span class="line">        self.font = pygame.font.SysFont(<span class="literal">None</span>, <span class="number">48</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 生成当前得分、最高得分、当前等级和当前剩余的飞船数</span></span><br><span class="line">        self.prep_score()</span><br><span class="line">        self.prep_high_score()</span><br><span class="line">        self.prep_level()</span><br><span class="line">        self.prep_ships()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prep_score</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""将得分转换为图片"""</span></span><br><span class="line">        rounded_score = round(self.stats.score, <span class="number">-1</span>)</span><br><span class="line">        <span class="comment"># 在得分中插入逗号</span></span><br><span class="line">        score_str = <span class="string">"&#123;:,&#125;"</span>.format(rounded_score)</span><br><span class="line">        self.score_image = self.font.render(score_str, <span class="literal">True</span>, self.text_color,</span><br><span class="line">                                            self.ai_settings.bg_color)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将得分放在屏幕右上角</span></span><br><span class="line">        self.score_rect = self.score_image.get_rect()</span><br><span class="line">        self.score_rect.right = self.screen_rect.right - <span class="number">20</span></span><br><span class="line">        self.score_rect.top = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prep_high_score</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""将最高得分转化为图像"""</span></span><br><span class="line">        high_score = round(self.stats.high_score, <span class="number">-1</span>)</span><br><span class="line">        high_score_str = <span class="string">"&#123;:,&#125;"</span>.format(high_score)</span><br><span class="line">        self.high_score_image = self.font.render(high_score_str, <span class="literal">True</span>, self.text_color,</span><br><span class="line">                                                 self.ai_settings.bg_color)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将最高得分放在屏幕顶部中央</span></span><br><span class="line">        self.high_score_rect = self.high_score_image.get_rect()</span><br><span class="line">        self.high_score_rect.centerx = self.screen_rect.centerx</span><br><span class="line">        self.high_score_rect.top = self.score_rect.top</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prep_level</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""将等级转化为图像"""</span></span><br><span class="line">        self.level_image = self.font.render(str(self.stats.level), <span class="literal">True</span>, self.text_color,</span><br><span class="line">                                            self.ai_settings.bg_color)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将等级放在得分下方</span></span><br><span class="line">        self.level_rect = self.level_image.get_rect()</span><br><span class="line">        self.level_rect.right = self.score_rect.right</span><br><span class="line">        self.level_rect.top = self.score_rect.bottom + <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prep_ships</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""显示还余下多少艘飞船"""</span></span><br><span class="line">        self.ships = Group()</span><br><span class="line">        <span class="keyword">for</span> ship_number <span class="keyword">in</span> range(self.stats.ships_left):</span><br><span class="line">            ship = Ship(self.ai_settings, self.screen)</span><br><span class="line">            ship.rect.x = <span class="number">10</span> + ship_number * ship.rect.width</span><br><span class="line">            ship.rect.y = <span class="number">10</span></span><br><span class="line">            self.ships.add(ship)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_score</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""在屏幕上显示得分板"""</span></span><br><span class="line">        self.screen.blit(self.score_image, self.score_rect)</span><br><span class="line">        self.screen.blit(self.high_score_image, self.high_score_rect)</span><br><span class="line">        self.screen.blit(self.level_image, self.level_rect)</span><br><span class="line">        <span class="comment"># 绘制飞船</span></span><br><span class="line">        self.ships.draw(self.screen)</span><br></pre></td></tr></table></figure>
<h2 id="修改settings.py-1">4.2 修改settings.py</h2>
<p>设置外星人的分数，外星人分数增长的速度：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Settings</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        -- snip --</span><br><span class="line">        <span class="comment"># 外星人点数的提高速度</span></span><br><span class="line">        self.score_scale = <span class="number">1.5</span></span><br><span class="line"></span><br><span class="line">        self.initialize_dynamic_settings()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize_dynamic_settings</span><span class="params">(self)</span>:</span></span><br><span class="line">        -- snip --</span><br><span class="line">        <span class="comment"># 记分, 每一个外星人的分数</span></span><br><span class="line">        self.alien_points = <span class="number">50</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increase_speed</span><span class="params">(self)</span>:</span></span><br><span class="line">        -- snip --</span><br><span class="line">        <span class="comment"># 动态增加每个外星人的分数</span></span><br><span class="line">        self.alien_points = int(self.alien_points * self.score_scale)</span><br></pre></td></tr></table></figure>
<h2 id="修改game_stats.py">4.3 修改game_stats.py</h2>
<p>在<code>GameStats</code>中设置一个用于记录最高分的属性，也正因此，应该将它放在构造函数中，它只会变大，在没有重新运行游戏前，它不会被重置为<code>0</code>；在<code>reset_stats()</code>方法中，初始化<code>score</code>和<code>level</code>两个属性，这两个属性每点一次<code>Play</code>按钮都会被重置。对于<code>level</code>这个属性，每消灭一批舰队，<code>level</code>就加1.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameStats</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ai_settings)</span>:</span></span><br><span class="line">        -- snip --</span><br><span class="line">        <span class="comment"># 在任何情况下都不应重置最高得分</span></span><br><span class="line">        self.high_score = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reset_stats</span><span class="params">(self)</span>:</span></span><br><span class="line">        -- snip --</span><br><span class="line">        self.score = <span class="number">0</span></span><br><span class="line">        self.level = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="修改主程序alien_invasion.py">4.4 修改主程序alien_invasion.py</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">-- snip --</span><br><span class="line"><span class="keyword">from</span> scoreboard <span class="keyword">import</span> Scoreboard</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_game</span><span class="params">()</span>:</span></span><br><span class="line">    -- snip --</span><br><span class="line">    <span class="comment"># 创建计分板</span></span><br><span class="line">    score = Scoreboard(ai_settings, screen, stats)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始游戏的主循环</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 添加score参数</span></span><br><span class="line">        gf.check_events(ai_settings, screen, ship, bullets, stats, play_button,</span><br><span class="line">                        aliens, score)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> stats.game_active:</span><br><span class="line">            ship.update()</span><br><span class="line">            <span class="comment"># 添加score参数</span></span><br><span class="line">            gf.update_bullets(bullets, aliens, ship, screen, ai_settings, stats, score)</span><br><span class="line">            <span class="comment"># 添加score参数</span></span><br><span class="line">            gf.update_aliens(ai_settings, aliens, ship, screen, bullets, stats, score)</span><br><span class="line">        <span class="comment"># 添加score参数</span></span><br><span class="line">        gf.update_screen(ai_settings, screen, ship, bullets, aliens, stats,</span><br><span class="line">                         play_button, score)</span><br></pre></td></tr></table></figure>
<p>从上面的注释可以看出，我们生成了一个计分板的实例<code>score</code>；<code>game_functions.py</code>中的四个函数都要添加<code>score</code>参数，换句话说，这四个函数都要修改，下面我们逐一修改这四个函数。</p>
<h2 id="修改game_functions.py-2">4.5 修改game_functions.py</h2>
<h3 id="修改参数">4.5.1 修改参数</h3>
<p>有几个函数只需要在参数列表中增加<code>score</code>参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 增加score参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_events</span><span class="params">(ai_settings, screen, ship, bullets, stats, play_button, aliens, score)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> event <span class="keyword">in</span> pygame.event.get():</span><br><span class="line">        -- snip --</span><br><span class="line">        <span class="keyword">elif</span> event.type == pygame.MOUSEBUTTONDOWN:</span><br><span class="line">            mouse_x, mouse_y = pygame.mouse.get_pos()</span><br><span class="line">            <span class="comment"># 增加score参数, 该函数有所改动</span></span><br><span class="line">            check_play_button(stats, play_button, mouse_x, mouse_y, ai_settings,</span><br><span class="line">                              screen, ship, aliens, bullets, score)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加score参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_bullets</span><span class="params">(bullets, aliens, ship, screen, ai_settings, stats, score)</span>:</span></span><br><span class="line">    -- snip --</span><br><span class="line">    <span class="comment"># 增加score参数，该函数有所改动</span></span><br><span class="line">    check_bullet_alien_collisions(ai_settings, screen, ship, aliens, bullets, stats, score)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加score参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_aliens</span><span class="params">(ai_settings, aliens, ship, screen, bullets, stats, score)</span>:</span></span><br><span class="line">    -- snip --</span><br><span class="line">    <span class="keyword">if</span> pygame.sprite.spritecollideany(ship, aliens):</span><br><span class="line">        <span class="comment"># 增加score参数，该函数有所改动</span></span><br><span class="line">        ship_hit(ai_settings, stats, screen, ship, aliens, bullets, score)</span><br><span class="line">    <span class="comment"># 增加score参数，该函数有所改动</span></span><br><span class="line">    check_aliens_bottom(ai_settings, stats, screen, ship, aliens, bullets, score)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加score参数，该函数有所改动</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_screen</span><span class="params">(ai_settings, screen, ship, bullets, aliens, stats, play_button, score)</span>:</span></span><br><span class="line">    -- snip --</span><br><span class="line">    aliens.draw(screen)</span><br><span class="line">    <span class="comment"># 在if语句前面添加绘制计分板的代码</span></span><br><span class="line">    <span class="comment"># 显示得分</span></span><br><span class="line">    score.show_score()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> stats.game_active:</span><br><span class="line">        play_button.draw_button()</span><br><span class="line">    -- snip --</span><br></pre></td></tr></table></figure>
<p>接下来是改动较多的函数。</p>
<h3 id="修改check_play_button函数">4.5.2 修改check_play_button()函数</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加了score参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_play_button</span><span class="params">(stats, play_button, mouse_x, mouse_y, ai_settings, screen,</span></span></span><br><span class="line"><span class="function"><span class="params">                      ship, aliens, bullets, score)</span>:</span></span><br><span class="line">    <span class="string">"""在玩家单机Play按钮时开始新游戏"""</span></span><br><span class="line">    <span class="keyword">if</span> play_button.rect.collidepoint(mouse_x,</span><br><span class="line">                                     mouse_y) <span class="keyword">and</span> <span class="keyword">not</span> stats.game_active:</span><br><span class="line">        -- snip --</span><br><span class="line">        stats.game_active = <span class="literal">True</span>  <span class="comment"># 这一句不是新增的</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 以下四行是新增的</span></span><br><span class="line">        score.prep_score()</span><br><span class="line">        score.prep_high_score()</span><br><span class="line">        score.prep_level()</span><br><span class="line">        score.prep_ships()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 清空外星人列表和子弹列表</span></span><br><span class="line">        -- snip --</span><br></pre></td></tr></table></figure>
<p>首先参数列表添加了<code>score</code>参数，<code>if</code>判断中还添加了四行生成计分板的代码。之所以这里要添加这四行代码，其实是为了当你重新开始（也就是第二次及以后点击<code>Play</code>按钮）游戏时，计分板能正确显示。</p>
<p>当第一运行游戏时，没有这四行也能正确显示计分板。但是从第二次点击Play开始，如果没有这四行，游戏的各个参数虽然更新了（通过<code>check_play_button()</code>中的各种重置函数得到了更新），可这些更新还没有让记分板中这四个参数的图像得到重新绘制，即属性的更新没有自动触发<code>score</code>的这四个函数。所以显示会不正确，因此必须在这里添加这四行代码。</p>
<h3 id="修改update_screen函数">4.5.3 修改update_screen()函数</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 增加了score参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_screen</span><span class="params">(ai_settings, screen, ship, bullets, aliens, stats, play_button, score)</span>:</span></span><br><span class="line">    -- snip --</span><br><span class="line">    <span class="comment"># 增加显示得分的代码</span></span><br><span class="line">    score.show_score()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> stats.game_active:</span><br><span class="line">        -- snip --</span><br></pre></td></tr></table></figure>
<h3 id="修改update_bullets和update_aliens函数">4.5.4 修改update_bullets()和update_aliens()函数</h3>
<p>这俩函数只是增加参数而已。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 增加了score参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_bullets</span><span class="params">(bullets, aliens, ship, screen, ai_settings, stats, score)</span>:</span></span><br><span class="line">    -- snip --</span><br><span class="line">    <span class="comment"># 增加了score参数, 函数有改动</span></span><br><span class="line">    check_bullet_alien_collisions(ai_settings, screen, ship, aliens, bullets, stats, score)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加了score参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_aliens</span><span class="params">(ai_settings, aliens, ship, screen, bullets, stats, score)</span>:</span></span><br><span class="line">    -- snip --</span><br><span class="line">    <span class="comment"># 检测外星人和飞船之间的碰撞</span></span><br><span class="line">    <span class="keyword">if</span> pygame.sprite.spritecollideany(ship, aliens):</span><br><span class="line">        <span class="comment"># 增加了score参数, 函数有改动</span></span><br><span class="line">        ship_hit(ai_settings, stats, screen, ship, aliens, bullets, score)</span><br><span class="line">    <span class="comment"># 增加了score参数</span></span><br><span class="line">    check_aliens_bottom(ai_settings, stats, screen, ship, aliens, bullets, score)</span><br></pre></td></tr></table></figure>
<p><code>check_aliens_bottom()</code>内也变化也不大，该函数的变化不再以代码的形式单独列出：</p>
<p>该函数增加了一个<code>score</code>参数，它内部调用了<code>ship_hit()</code>函数，为这个调用也增加<code>score</code>参数。这就是全部变化。</p>
<h3 id="修改check_bullet_alien_collisions函数">4.5.5 修改check_bullet_alien_collisions()函数</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 增加了score参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_bullet_alien_collisions</span><span class="params">(ai_settings, screen, ship, aliens, bullets, stats, score)</span>:</span></span><br><span class="line">    collisions = pygame.sprite.groupcollide(bullets, aliens, <span class="literal">True</span>, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> collisions:</span><br><span class="line">        <span class="keyword">for</span> aliens <span class="keyword">in</span> collisions.values():</span><br><span class="line">            stats.score += ai_settings.alien_points * len(aliens)</span><br><span class="line">            <span class="comment"># 其实这里可以将其放到for循环之外，应为并不能立刻就呈现分数变化</span></span><br><span class="line">            <span class="comment"># 要等到主程序中的update_screen()中才能呈现</span></span><br><span class="line">            score.prep_score()</span><br><span class="line">        <span class="comment"># 该函数是新增的</span></span><br><span class="line">        check_high_score(stats, score)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(aliens) == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 删除现有的子弹并创建新的舰队</span></span><br><span class="line">        bullets.empty()</span><br><span class="line">        ai_settings.increase_speed()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 提高等级</span></span><br><span class="line">        stats.level += <span class="number">1</span></span><br><span class="line">        score.prep_level()</span><br><span class="line"></span><br><span class="line">        create_fleet(ai_settings, screen, ship, aliens)</span><br></pre></td></tr></table></figure>
<p>首先我们增加了一个判断语句，用于根据消灭的外星人来增加分数，由于有可能一颗子弹打到多个外星人但只算了一个外星人的分数，所有用循环来确保消灭掉的每一个外星人都得到了统计。<code>collisions</code>是一个字典，这里子弹是键，该子弹消灭的外星人对象为值（是个列表）。</p>
<p>我们还新增了一个更新最高积分的函数<code>check_high_score()</code>，它的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_high_score</span><span class="params">(stats, score)</span>:</span></span><br><span class="line">    <span class="string">"""检查是否诞生了新的最高得分"""</span></span><br><span class="line">    <span class="keyword">if</span> stats.score &gt; stats.high_score:</span><br><span class="line">        stats.high_score = stats.score</span><br><span class="line">        score.prep_high_score()</span><br></pre></td></tr></table></figure>
<p>第二个if中，添加了增加等级的语句，紧跟着的是重新在计分板中绘制等级图像。</p>
<h3 id="修改ship_hit和check_aliens_bottom函数">4.5.6 修改ship_hit()和check_aliens_bottom()函数</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 增加了score参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ship_hit</span><span class="params">(ai_settings, stats, screen, ship, aliens, bullets, score)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> stats.ships_left &gt; <span class="number">0</span>:</span><br><span class="line">        stats.ships_left -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 更新记分牌</span></span><br><span class="line">        score.prep_ships()</span><br><span class="line">        <span class="comment"># 清空外星人列表和子弹列表</span></span><br><span class="line">        -- snip --</span><br></pre></td></tr></table></figure>
<h2 id="最后运行效果">4.6 最后运行效果</h2>
<p>至此所有的添加都已经结束，下图是游戏的最终效果：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828259/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF13-%E8%AE%B0%E5%88%86/1523895161395.png" /></p>
<h1 id="小结">5. 小结</h1>
<p>Python小游戏告一段落，一共三篇文章。本文中讲述了：</p>
<ul>
<li>如何创建用于开始新游戏的<code>Play</code>按钮；</li>
<li>如何检测鼠标点击事件；</li>
<li>如何在游戏处于活动状态时隐藏光标；</li>
<li>如何随游戏的进行调整节奏；</li>
<li>如何实现记分系统；</li>
<li>以及如何以文本和非文本方式显示信息。</li>
</ul>
<p>后三篇文章将是使用Python来进行数据统计分析、绘图等内容。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python基础</tag>
        <tag>Pygame</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路12-外星人</title>
    <url>/2018/04/16/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF12-%E5%A4%96%E6%98%9F%E4%BA%BA/</url>
    <content><![CDATA[<blockquote>
<p>《Python编程：从入门到实践》笔记。 本章主要是对上一篇的继续，添加“外星人”，“外星人”与飞船的交互。</p>
</blockquote>
<a id="more"></a>
<h1 id="回顾项目">1. 回顾项目</h1>
<p>开发较大的项目时，进入每个开发阶段前回顾一下开发计划，搞清楚接下来要通过代码实现哪些功能至关重要。本篇将设计一下内容：</p>
<ul>
<li>研究即有代码，确定实现新功能前是否需要重构代码</li>
<li>在屏幕左上角添加一个外星人，并指定合适的边距</li>
<li>根据第一个外星人的边距和屏幕尺寸计算屏幕上可容纳多少个外星人。编写一个循环来填满屏幕的上半部分</li>
<li>让外星舰队向两边和下方移动，直到外星人被全部击落，或有外星人撞到飞船，或有外星人抵达屏幕底部。如果所有外星人都被击落，再创建一批外星人。如果有外星人撞到飞船或到达屏幕底部，则销毁飞船并再创建一群外星人。</li>
<li>限制玩家可用的飞机数，消耗完则游戏结束</li>
</ul>
<p>希望各位上一篇的代码没有删掉。在开始新的代码前，我们先在前面的<code>check_keydown_events()</code>函数中添加“通过快捷键Q结束游戏”的代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_keydown_event</span><span class="params">(event, ship, ai_settings, screen, bullets)</span>:</span></span><br><span class="line">    -- snip --</span><br><span class="line">    <span class="keyword">elif</span> event.key == pygame.K_q:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure>
<h1 id="创建外星人">2. 创建外星人</h1>
<p>首先我们需要编写一个外星人<code>Alien</code>类。新建<code>alien.py</code>模块，在其中加入如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"><span class="keyword">from</span> pygame.sprite <span class="keyword">import</span> Sprite</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Alien</span><span class="params">(Sprite)</span>:</span></span><br><span class="line">    <span class="string">"""表示单个外星人的类"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ai_settings, screen)</span>:</span></span><br><span class="line">        <span class="string">"""初始化外星人并设置其起始位置"""</span></span><br><span class="line">        super(Alien, self).__init__()</span><br><span class="line">        self.screen = screen</span><br><span class="line">        self.ai_settings = ai_settings</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 加载外星人图像，并设置其rect属性</span></span><br><span class="line">        self.image = pygame.image.load(<span class="string">"images/alien.bmp"</span>)</span><br><span class="line">        self.rect = self.image.get_rect()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 每个外星人最初都在屏幕左上角附近</span></span><br><span class="line">        self.rect.x = self.rect.width</span><br><span class="line">        self.rect.y = self.rect.height</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 存储外星人的准确位置</span></span><br><span class="line">        self.x = float(self.rect.x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">blitme</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""在指定位置绘制外星人"""</span></span><br><span class="line">        self.screen.blit(self.image, self.rect)</span><br></pre></td></tr></table></figure>
<p>它和<code>Bullet</code>类一样继承自<code>Sprite</code>类。现在开始创建多行外星人。</p>
<h2 id="修改game_functions.py模块">2.1 修改game_functions.py模块</h2>
<p>首先在<code>game_functions.py</code>模块中添加<code>create_fleet()</code>函数用于创建外星舰队：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_fleet</span><span class="params">(ai_settings, screen, ship, aliens)</span>:</span></span><br><span class="line">    <span class="string">"""创建外星舰队"""</span></span><br><span class="line">    alien = Alien(ai_settings, screen)</span><br><span class="line">    <span class="comment"># 计算每行能放多少个</span></span><br><span class="line">    number_aliens_x = get_number_aliens_x(ai_settings, alien.rect.width)</span><br><span class="line">    <span class="comment"># 计算能放多少行</span></span><br><span class="line">    number_rows = get_number_rows(ai_settings, ship.rect.height,</span><br><span class="line">                                  alien.rect.height)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 嵌套循环创建外星舰队</span></span><br><span class="line">    <span class="keyword">for</span> row_number <span class="keyword">in</span> range(number_rows):</span><br><span class="line">        <span class="keyword">for</span> alien_number <span class="keyword">in</span> range(number_aliens_x):</span><br><span class="line">            <span class="comment"># 创建外星人并将其加入舰队</span></span><br><span class="line">            create_alien(ai_settings, screen, aliens, alien_number, row_number)</span><br></pre></td></tr></table></figure>
<p>然后我们依次补充下面三个函数（注意各个函数的参数），这三个函数也位于<code>game_functions.py</code>中：</p>
<p><strong><code>get_number_aliens_x()</code>: 计算一行能放多少个外星人</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_number_aliens_x</span><span class="params">(ai_settings, alien_width)</span>:</span></span><br><span class="line">    <span class="string">"""计算每行可容纳多少个外星人"""</span></span><br><span class="line">    <span class="comment"># 左右两侧留出一个外星人的宽度</span></span><br><span class="line">    available_space_x = ai_settings.screen_width - <span class="number">2</span> * alien_width</span><br><span class="line">    <span class="comment"># 列间距为一个外星人宽度</span></span><br><span class="line">    number_aliens_x = int(available_space_x / (<span class="number">2</span> * alien_width))</span><br><span class="line">    <span class="keyword">return</span> number_aliens_x</span><br></pre></td></tr></table></figure>
<p><strong><code>get_number_rows()</code>: 计算能放多少行外星人</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_number_rows</span><span class="params">(ai_settings, ship_height, alien_height)</span>:</span></span><br><span class="line">    <span class="string">"""计算屏幕可容纳多少行外星人"""</span></span><br><span class="line">    <span class="comment"># 可用高度 = 窗口高度 - 上方一个外星人高度 - 下方一个飞船高度 - 两个外星人高度作为缓冲空间</span></span><br><span class="line">    available_space_y = (ai_settings.screen_height - <span class="number">3</span> * alien_height - ship_height)</span><br><span class="line">    <span class="comment"># 行距为一个外星人高度</span></span><br><span class="line">    number_rows = int(available_space_y / (<span class="number">2</span> * alien_height))</span><br><span class="line">    <span class="keyword">return</span> number_rows</span><br></pre></td></tr></table></figure>
<p><strong><code>create_alien()</code>: 创建外星人</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_alien</span><span class="params">(ai_settings, screen, aliens, alien_number, row_number)</span>:</span></span><br><span class="line">    <span class="string">"""创建一个外星人并将其放在当前行"""</span></span><br><span class="line">    alien = Alien(ai_settings, screen)</span><br><span class="line">    <span class="comment"># 下面就是根据上面的公式计算每一个外星人在窗口中的位置（这是左上角的坐标）</span></span><br><span class="line">    alien.x = alien.rect.width * (<span class="number">1</span> + <span class="number">2</span> * alien_number)</span><br><span class="line">    alien.rect.x = alien.x</span><br><span class="line">    alien.rect.y = alien.rect.height * (<span class="number">1</span> + <span class="number">2</span> * row_number)</span><br><span class="line">    aliens.add(alien)</span><br></pre></td></tr></table></figure>
<p>现在我们还需要<strong>修改<code>update_screen()</code>函数：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_screen</span><span class="params">(ai_settings, screen, ship, bullets, aliens)</span>:</span></span><br><span class="line">    -- snip --</span><br><span class="line">    <span class="comment"># 绘制外星人，放在绘制子弹的代码后面，让外星人的图像覆盖掉子弹的图像</span></span><br><span class="line">    aliens.draw(screen)</span><br><span class="line">    -- snip --</span><br></pre></td></tr></table></figure>
<p>注意，该函数增加了一个参数<code>aliens</code>，这是个<code>Group</code>对象，所以代码中的<code>draw()</code>方法也跟前一篇中的<code>bullets.update()</code>方法一样，一行代码更新所有对象。</p>
<h2 id="修改alien_invasion.py模块">2.2 修改alien_invasion.py模块</h2>
<p>在主程序中添加创建外星人的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_game</span><span class="params">()</span>:</span></span><br><span class="line">    -- snip --</span><br><span class="line">    gf.create_fleet(ai_settings, screen, ship, aliens)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        -- snip --</span><br><span class="line">        <span class="comment"># 比之前代码多传入了一个aliens参数</span></span><br><span class="line">        gf.update_screen(ai_settings, screen, ship, bullets, aliens)</span><br><span class="line">        </span><br><span class="line">-- snip --</span><br></pre></td></tr></table></figure>
<p>现在我们执行程序将会得到如下结果：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828239/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF12-%E5%A4%96%E6%98%9F%E4%BA%BA/1523796668050.png" /></p>
<h1 id="让外星舰队动起来">3. 让外星舰队动起来</h1>
<p>我们将让外星舰队在窗体中向右移动，撞到屏幕边缘后下以一定距离下降，再沿反方向移动，直到外星人被消灭，或外星人撞上飞船，或有外星人到达窗体底部。</p>
<h2 id="补充settings.py模块">3.1 补充settings.py模块</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Settings</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        -- snip --</span><br><span class="line">        self.fleet_drop_speed = <span class="number">10</span></span><br><span class="line">        <span class="comment"># 外星舰队方向标志：1向右，-1向左</span></span><br><span class="line">        <span class="comment"># 也可以用如left, right之类的标志，但这样会很麻烦</span></span><br><span class="line">        self.fleet_direction = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="修改alien.py模块">3.2 修改alien.py模块</h2>
<p>我们需要在<code>Alien</code>类中添加两个方法，一个用于检测窗体边缘，一个用于更新<code>Alien</code>对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Alien</span><span class="params">(Sprite)</span>:</span></span><br><span class="line">    -- snip --</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_edges</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""如果外星人位于屏幕边缘则返回True"""</span></span><br><span class="line">        screen_rect = self.screen.get_rect()</span><br><span class="line">        <span class="keyword">return</span> self.rect.right &gt;= screen_rect.right <span class="keyword">or</span> self.rect.left &lt;= <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""向右移动外星人"""</span></span><br><span class="line">        <span class="comment"># 以后这样的方式会用的很多</span></span><br><span class="line">        self.x += self.ai_settings.alien_speed_factor * self.ai_settings.fleet_direction</span><br><span class="line">        self.rect.x = self.x</span><br></pre></td></tr></table></figure>
<p>如果使用文本值来控制方向，那就需要添加<code>if-else</code>语句来检测舰队移动方向。鉴于只有两个可能的方向，这里使用<code>-1</code>和<code>1</code>来表示，这样更容易改变外星人对象的坐标。</p>
<h2 id="修改game_functions.py模块-1">3.3 修改game_functions.py模块</h2>
<p>首先，我们在该模块中添加一个更新外星舰队的函数<code>update_aliens()</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_aliens</span><span class="params">(ai_settings, aliens)</span>:</span></span><br><span class="line">    <span class="string">"""检查是否有外星人位于屏幕边缘，并更新外星舰队中所有外星人的位置"""</span></span><br><span class="line">    check_fleet_edges(ai_settings, aliens)</span><br><span class="line">    aliens.update()  <span class="comment"># “一键更新”</span></span><br></pre></td></tr></table></figure>
<p><code>check_fleet_edges()</code>函数用于检测舰队是否碰到了窗体边缘，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_fleet_edges</span><span class="params">(ai_settings, aliens)</span>:</span></span><br><span class="line">    <span class="string">"""有外星人到达边缘时采取相应的措施"""</span></span><br><span class="line">    <span class="comment"># 检测舰队中每一个外星人是否碰到了窗体边缘</span></span><br><span class="line">    <span class="keyword">for</span> alien <span class="keyword">in</span> aliens.sprites():</span><br><span class="line">        <span class="keyword">if</span> alien.check_edges():</span><br><span class="line">            change_fleet_direction(ai_settings, aliens)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p><code>change_fleet_direction()</code>函数用于改变舰队的移动方向，以及让舰队向下移动，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_fleet_direction</span><span class="params">(ai_settings, aliens)</span>:</span></span><br><span class="line">    <span class="string">"""将外星舰队下移，并改变它们的方向"""</span></span><br><span class="line">    <span class="keyword">for</span> alien <span class="keyword">in</span> aliens.sprites():</span><br><span class="line">        alien.rect.y += ai_settings.fleet_drop_speed</span><br><span class="line">    ai_settings.fleet_direction *= <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>上面三个函数就是在<code>game_functions.py</code>中的所有变动。</p>
<h2 id="修改alien_invasion.py模块-1">3.4 修改alien_invasion.py模块</h2>
<p>在该模块中我们只需要在<code>while</code>循环中添加一行代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开始游戏的主循环</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        gf.check_events(ai_settings, screen, ship, bullets)</span><br><span class="line">        ship.update()</span><br><span class="line">        gf.update_bullets(bullets)</span><br><span class="line">        <span class="comment"># 添加对外星舰队的修改</span></span><br><span class="line">        gf.update_aliens(ai_settings, aliens)</span><br><span class="line">        gf.update_screen(ai_settings, screen, ship, bullets, aliens)</span><br></pre></td></tr></table></figure>
<p>最后运行主程序，得到如下效果：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828239/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF12-%E5%A4%96%E6%98%9F%E4%BA%BA/1523801761348.png" /></p>
<p>截了一张静态图，实际是动态的。</p>
<h1 id="击杀外星人">4. 击杀外星人</h1>
<p>对于当前的程序，如果发射子弹，子弹将穿过外星人，而不是击杀，下面我们继续完善该项目，使其能击杀外星人。而要实现这一点，关键就是要检测到子弹图像与外星人图像是否重叠，重叠了则表示击中。</p>
<h2 id="修改game_functions.py">4.1 修改game_functions.py</h2>
<p>为何检测子弹与卫星人的碰撞，我们需要修改<code>update_bullets()</code>函数，这里我们增加了<code>update_bullets()</code>的参数，还调用了一个新函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_bullets</span><span class="params">(bullets, aliens, ship, screen, ai_settings)</span>:</span></span><br><span class="line">    -- snip --</span><br><span class="line">    check_bullet_alien_collisions(ai_settings, screen, ship, aliens, bullets)</span><br></pre></td></tr></table></figure>
<p>函数<code>check_bullet_alien_collisions()</code>用于检测子弹与外星人的碰撞，当外星人被消灭光时，清空现有子弹，并生成新的外星舰队，它的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_bullet_alien_collisions</span><span class="params">(ai_settings, screen, ship, aliens, bullets)</span>:</span></span><br><span class="line">    <span class="string">"""检测是否有子弹击中了外星人，如果有，就删除相应的子弹和外星人"""</span></span><br><span class="line">    <span class="comment"># 下一篇中我们将用该变量实现分数统计</span></span><br><span class="line">    collisions = pygame.sprite.groupcollide(bullets, aliens, <span class="literal">True</span>, <span class="literal">True</span>)</span><br><span class="line">	</span><br><span class="line">    <span class="comment">#如果外星人被消灭光，则生成新的外星人舰队</span></span><br><span class="line">    <span class="keyword">if</span> len(aliens) == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 删除现有的子弹并创建新的舰队</span></span><br><span class="line">        bullets.empty()</span><br><span class="line">        create_fleet(ai_settings, screen, ship, aliens)</span><br></pre></td></tr></table></figure>
<p><code>sprite.groupcollide()</code>方法用于检测对象之间的碰撞，它将<code>bullets</code>中的每个子弹的<code>rect</code>与<code>aliens</code>中的每个外星人的<code>rect</code>进行比较，并返回一个字典。该字典以第一个参数中的对象为键，以第二个参数中的键为值，在这里，以<code>bullets</code>中发生了碰撞的<code>bullet</code>为键，它的值为与之碰撞的<code>alien</code>（不是<code>aliens</code>）！第三个参数表示是否删除第一个参数中发生了碰撞的对象，而四个参数表示是否删除第二个参数中发生了碰撞的对象。</p>
<h2 id="修改alien_invasion.py">4.2 修改alien_invasion.py</h2>
<p>只需要修改调用<code>update_bullets()</code>函数的那行代码即可，增加几个参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gf.update_bullets(bullets, aliens, ship, screen, ai_settings)</span><br></pre></td></tr></table></figure>
<p>基础功能基本完成。</p>
<h2 id="测试技巧补充">4.3 测试技巧补充</h2>
<p>对于上述代码，我们可能需要测试当消灭完外星人后，新的舰队是否能被正确创建等，如果我们以现在游戏的设定，即子弹速度为1，子弹宽度为3，那测试起来将会很痛苦。此时，我们可以修改修改游戏的参数，比如将子弹宽度修改为300，子弹速度修改为3，这样就相当于对游戏进行了快进，此时代码的运行效果如下：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828239/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF12-%E5%A4%96%E6%98%9F%E4%BA%BA/1523803740363.png" /></p>
<p>不过最后记得将参数修改回去。</p>
<h1 id="结束游戏">5. 结束游戏</h1>
<p>接下来我们实现外星人碰到飞船，外星人抵达窗体底部，飞船数用光导致游戏结束的代码。</p>
<h2 id="创建gamestats类">5.1 创建GameStats类</h2>
<p>首先我们创建一个用于存储游戏信息的<code>GameStats</code>类，存放在<code>game_stats.py</code>文件中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameStats</span>:</span></span><br><span class="line">    <span class="string">"""跟踪游戏的统计信息"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ai_settings)</span>:</span></span><br><span class="line">        <span class="string">"""初始化统计信息"""</span></span><br><span class="line">        <span class="comment"># 用于控制游戏启动与否</span></span><br><span class="line">        self.game_active = <span class="literal">True</span></span><br><span class="line">        self.ai_settings = ai_settings</span><br><span class="line">        self.reset_stats()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reset_stats</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""初始化在游戏运行期间可能变化的统计信息"""</span></span><br><span class="line">        <span class="comment"># 重置飞船数</span></span><br><span class="line">        self.ships_left = self.ai_settings.ship_limit</span><br></pre></td></tr></table></figure>
<h2 id="修改settings.py">5.2 修改settings.py</h2>
<p>从上述代码可以看出，我们需要在<code>settings.py</code>中添加一项表示“飞船数”的信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Settings</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""初始化游戏的设置"""</span></span><br><span class="line">        <span class="comment"># 屏幕设置</span></span><br><span class="line">        -- snip --</span><br><span class="line">        <span class="comment"># 设置飞船数量限制</span></span><br><span class="line">        self.ship_limit = <span class="number">3</span></span><br><span class="line">        -- snip --</span><br></pre></td></tr></table></figure>
<h2 id="响应飞船与外星人的碰撞修改game_functions.py">5.3 响应飞船与外星人的碰撞，修改game_functions.py</h2>
<p>我们在更新每个外星人的位置后立即检测外星人和飞船之间的碰撞，随后再检查外星人是否到达了窗体底部。修改<code>update_aliens()</code>函数，使用<code>sprite</code>中的<code>spritecollideany()</code>方法来检测碰撞：将第二参数中的每一个元素与第一个参数比较，检测是否碰撞，返回第二个参数中第一个发生碰撞的对象，如果没有发生碰撞则返回<code>None</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 增加了参数和碰撞检测</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_aliens</span><span class="params">(ai_settings, aliens, ship, screen, bullets, stats)</span>:</span></span><br><span class="line">    -- snip --</span><br><span class="line">    <span class="comment"># 检测外星人和飞船之间的碰撞</span></span><br><span class="line">    <span class="keyword">if</span> pygame.sprite.spritecollideany(ship, aliens):</span><br><span class="line">        ship_hit(ai_settings, stats, screen, ship, aliens, bullets)</span><br><span class="line"></span><br><span class="line">    check_aliens_bottom(ai_settings, stats, screen, ship, aliens, bullets)</span><br></pre></td></tr></table></figure>
<p>为此我们需要增加两个函数：</p>
<p><strong><code>ship_hit()</code></strong>:当外星人与飞船发生碰撞时，调用次函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">-- snip --</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ship_hit</span><span class="params">(ai_settings, stats, screen, ship, aliens, bullets)</span>:</span></span><br><span class="line">    <span class="string">"""响应被外星人撞到的飞船"""</span></span><br><span class="line">    <span class="comment"># 将ship_left减1</span></span><br><span class="line">    <span class="keyword">if</span> stats.ships_left &gt; <span class="number">0</span>:</span><br><span class="line">        stats.ships_left -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 清空外星人列表和子弹列表</span></span><br><span class="line">        aliens.empty()</span><br><span class="line">        bullets.empty()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 创建一群新的外星人，并将飞船恢复到初始位置</span></span><br><span class="line">        create_fleet(ai_settings, screen, ship, aliens)</span><br><span class="line">        ship.center_ship()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 暂停</span></span><br><span class="line">        sleep(<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        stats.game_active = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>从上面的代码还可以看出，我们还需要在<code>Ship</code>类中添加一个<code>center_ship()</code>方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">center_ship</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""让飞船在屏幕上居中"""</span></span><br><span class="line">    self.center = self.screen_rect.centerx</span><br></pre></td></tr></table></figure>
<p><strong><code>check_aliens_bottom()</code></strong>: 当飞船到达窗体底部时调用次函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_aliens_bottom</span><span class="params">(ai_settings, stats, screen, ship, aliens, bullets)</span>:</span></span><br><span class="line">    <span class="string">"""检测是否有外星人到达了屏幕底部"""</span></span><br><span class="line">    screen_rect = screen.get_rect()</span><br><span class="line">    <span class="keyword">for</span> alien <span class="keyword">in</span> aliens.sprites():</span><br><span class="line">        <span class="keyword">if</span> alien.rect.bottom &gt;= screen_rect.bottom:</span><br><span class="line">            <span class="comment"># 和飞船被碰撞是的代码没啥区别，故调用同一个函数</span></span><br><span class="line">            ship_hit(ai_settings, stats, screen, ship, aliens, bullets)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<h2 id="修改主程序alien_invasion.py">5.4 修改主程序alien_invasion.py</h2>
<p>修改游戏的循环部分：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开始游戏的主循环</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    gf.check_events(ai_settings, screen, ship, bullets)</span><br><span class="line">	</span><br><span class="line">    <span class="comment"># 决定程序运行时该执行的部分</span></span><br><span class="line">    <span class="keyword">if</span> stats.game_active:</span><br><span class="line">        ship.update()</span><br><span class="line">        gf.update_bullets(bullets, aliens, ship, screen, ai_settings)</span><br><span class="line">        gf.update_aliens(ai_settings, aliens, ship, screen, bullets, stats)</span><br><span class="line"></span><br><span class="line">    gf.update_screen(ai_settings, screen, ship, bullets, aliens)</span><br></pre></td></tr></table></figure>
<p>在主循环中，任何情况下都需要调用<code>check_events()</code>，即使游戏处于非活动状态；还需要不断更新屏幕，以便在等待玩家是否选择重新开始游戏时能够修改屏幕；其他函数仅在游戏处于活动状态时太需要调用。</p>
<h1 id="小结">6. 小结</h1>
<p>本篇讲述了：</p>
<ul>
<li>如何在游戏中添加大量相同的元素；</li>
<li>如何用嵌套循环来创建元素网格；</li>
<li>如何控制对象在屏幕上移动的方向以及响应事件；</li>
<li>如何检测和响应元素碰撞；</li>
<li>如何在游戏中跟踪统计信息；</li>
<li>如何使用标志<code>game_active</code>来判断游戏是否结束。</li>
</ul>
<p>下一篇中，同时也是本项目的最后一篇，我们将：</p>
<ul>
<li>添加一个Play按钮让玩家能够开始游戏，以及游戏结束后再开始；</li>
<li>每当玩家消灭一群外星人后，加快游戏节奏；</li>
<li>添加一个分数系统。</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python基础</tag>
        <tag>Pygame</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路11-武装飞船</title>
    <url>/2018/04/15/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF11-%E6%AD%A6%E8%A3%85%E9%A3%9E%E8%88%B9/</url>
    <content><![CDATA[<blockquote>
<p>《Python编程：从入门到实践》笔记。 本章主要学习如何使用pygame编写一个简单的小飞机打外星人的游戏，由于本人对用python写游戏并不是特别感兴趣，所以主要是看代码的构建和一些编程规范，代码会有所简略。</p>
</blockquote>
<a id="more"></a>
<h1 id="准备工作">1. 准备工作</h1>
<p>Python标准库中并没有自带<code>pygame</code>模块，所以需要自行安装，可以在控制台（Windows下是cmd）上使用命令行安装：<code>pip install pygame</code>。如果你是用的PyCharm，也可以在设置中安装：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828217/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF11-%E6%AD%A6%E8%A3%85%E9%A3%9E%E8%88%B9/1523762498949.png" /></p>
<p>点击右边的加号，在弹出的窗口中输入pygame，然后安装即可。</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828218/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF11-%E6%AD%A6%E8%A3%85%E9%A3%9E%E8%88%B9/1523762625870.png" /></p>
<p>该项目中需要使用一些书中的图片，这些图片都可以在 <a href="http://www.ituring.com.cn/book/1861" target="_blank" rel="noopener">http://www.ituring.com.cn/book/1861</a> 中下载到。</p>
<h1 id="游戏基本内容">2. 游戏基本内容</h1>
<p>首先需要新建一个项目，笔者取名为<strong>“alien_invasion”</strong>，并在该项目的根目录下新建一个<strong>images</strong>文件夹，用于存放项目中用到的图片。在本节中，我们将先创建4个文件：</p>
<p><code>alien_invasion.py</code>：游戏主程序</p>
<p><code>settings.py</code>：游戏的配置文件</p>
<p><code>game_functions.py</code>：存放游戏的控制函数，比如响应鼠标、键盘等</p>
<p><code>ship.py</code>：飞船类</p>
<h2 id="alien_invasion.py模块">2.1 alien_invasion.py模块：</h2>
<p>该模块经过重构后的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> game_functions <span class="keyword">as</span> gf</span><br><span class="line"><span class="keyword">from</span> settings <span class="keyword">import</span> Settings</span><br><span class="line"><span class="keyword">from</span> ship <span class="keyword">import</span> Ship</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_game</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 初始化游戏并创建一个屏幕对象</span></span><br><span class="line">    pygame.init()   <span class="comment"># 初始化背景设置，让pygame能正常工作</span></span><br><span class="line">    ai_settings = Settings()  <span class="comment"># 实例化一个游戏配置类</span></span><br><span class="line">    <span class="comment"># 返回一个游戏窗口</span></span><br><span class="line">    screen = pygame.display.set_mode(</span><br><span class="line">        (ai_settings.screen_width, ai_settings.screen_height))</span><br><span class="line">    pygame.display.set_caption(<span class="string">"Alien Invasion"</span>)   <span class="comment"># 给这个游戏窗口设置一个标题</span></span><br><span class="line"></span><br><span class="line">    ship = Ship(ai_settings, screen)   <span class="comment"># 实例化一个飞船类，传入了参数ai_settings和屏幕对象screen</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始游戏的主循环</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        gf.check_events(ship)  <span class="comment"># 用于响应游戏事件</span></span><br><span class="line">        ship.update()   <span class="comment"># 更新飞船状态</span></span><br><span class="line">        gf.update_screen(ai_settings, screen, ship)  <span class="comment"># 重绘screen</span></span><br><span class="line"></span><br><span class="line">run_game()</span><br></pre></td></tr></table></figure>
<p>①代码第1行导入<code>pygame</code>模块，它包含开发游戏所需的基本功能；</p>
<p>②代码3到5行导入的是自行编写且经过重构的模块；</p>
<p>③第9行代码执行游戏的初始化工作，比如初始化游戏背景等；</p>
<p>④第10行实例化一个游戏配置类，用于配置游戏参数，该类的具体实现见本篇后面的内容；</p>
<p>⑤代码第12-13行用于生成一个名为<code>screen</code>的显示窗口，长宽从配置对象<code>ai_settings</code>中读出；<code>display.set_mode()</code>返回的是一个<code>surface</code>，在pygame中，<code>surface</code>是屏幕的一部分，用于显示游戏元素，这里的<code>screen</code>表示的是整个游戏窗口。我们激活游戏的循环后，每经过一次循环pygame都将重绘这个<code>screen</code>。</p>
<p>⑥代码第20行的<code>check_events()</code>函数用于响应游戏中发生的时间，比如鼠标，键盘，关闭窗口等。</p>
<p>⑦代码第21行用于更新飞船的信息，如飞船位置</p>
<p>⑧最后一行用于启动游戏，即初始化游戏，并开始主循环。</p>
<h2 id="settings.py模块">2.2 settings.py模块</h2>
<p>该文件主要是游戏的配置信息，存放游戏的各种参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Settings</span>:</span></span><br><span class="line">    <span class="string">"""存储《外星人入侵》的所有设置的类"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""初始化游戏的设置"""</span></span><br><span class="line">        <span class="comment"># 屏幕设置</span></span><br><span class="line">        self.screen_width = <span class="number">1200</span>   <span class="comment"># 游戏窗口宽度</span></span><br><span class="line">        self.screen_height = <span class="number">800</span>   <span class="comment"># 游戏窗口高度</span></span><br><span class="line">        self.bg_color = (<span class="number">230</span>, <span class="number">230</span>, <span class="number">230</span>)  <span class="comment"># 游戏背景颜色</span></span><br><span class="line">        self.ship_speed_factor = <span class="number">1.5</span>  <span class="comment"># 飞船的移动速度</span></span><br></pre></td></tr></table></figure>
<p>这里故意将飞船的速度设置为浮点数，也可以是整数。在设置游戏元素的位置时，如果直接使用浮点数，则只会截取整数部分。</p>
<h2 id="ship.py模块">2.3 ship.py模块</h2>
<p>该模块描述了一个飞船类的基本内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ship</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ai_settings, screen)</span>:</span></span><br><span class="line">        <span class="string">"""初始化飞机并设置其初始位置"""</span></span><br><span class="line">        self.screen = screen</span><br><span class="line">        self.ai_settings = ai_settings</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 加载飞机图片并获取其外接矩形</span></span><br><span class="line">        self.image = pygame.image.load(<span class="string">"images/ship.bmp"</span>)</span><br><span class="line">        self.rect = self.image.get_rect()</span><br><span class="line">        self.screen_rect = screen.get_rect()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将每艘新飞船放在屏幕底部中央</span></span><br><span class="line">        self.rect.centerx = self.screen_rect.centerx</span><br><span class="line">        self.rect.bottom = self.screen_rect.bottom</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 自定义一个能存储浮点数的临时变量,x坐标</span></span><br><span class="line">        self.center = float(self.rect.centerx)</span><br><span class="line">		</span><br><span class="line">        <span class="comment"># 标志，用于表示是否正在向某个方向移动</span></span><br><span class="line">        self.moving_right = <span class="literal">False</span></span><br><span class="line">        self.moving_left = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""根据移动标志调整飞船的位置"""</span></span><br><span class="line">        <span class="keyword">if</span> self.moving_right <span class="keyword">and</span> self.rect.right &lt; self.screen_rect.right:</span><br><span class="line">            self.center += self.ai_settings.ship_speed_factor</span><br><span class="line">        <span class="keyword">if</span> self.moving_left <span class="keyword">and</span> self.rect.left &gt; <span class="number">0</span>:</span><br><span class="line">            self.center -= self.ai_settings.ship_speed_factor</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 用临时变量更新rect的centerx，截取截取整数部分</span></span><br><span class="line">        self.rect.centerx = self.center</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">blitme</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""在指定位置绘制飞船"""</span></span><br><span class="line">        self.screen.blit(self.image, self.rect)</span><br></pre></td></tr></table></figure>
<p>①<code>__init__()</code>中的<code>self.center</code>属性，代码将<code>self.rect.centerx</code>即飞船的中心x坐标转换成浮点数，并将其存储在<code>self.cente</code>r中。之所以转换成浮点数，是因为在<code>settings.py</code>文件中，我们将飞船移动速度设置成了浮点数。</p>
<p>②<code>self.moving_right</code>和<code>self.moving_left</code>标志，用于表示飞船是否正在移动，用于实现飞船在不松开按键下连续移动。</p>
<p>③<code>udpate()</code>方法，用于增减飞船的中心位置<code>x</code>坐标（因为飞船只能在底部移动，所以不用改<code>y</code>坐标），并防止飞船移动出游戏窗口。</p>
<p>④重写了<code>blitme()</code>函数，用于绘制飞船</p>
<h2 id="game_functions.py模块">2.4 game_functions.py模块</h2>
<p>该模块主要是集中处理游戏中发生的各种事件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_keydown_event</span><span class="params">(event, ship)</span>:</span></span><br><span class="line">    <span class="string">"""响应按下按键"""</span></span><br><span class="line">    <span class="keyword">if</span> event.key == pygame.K_RIGHT:</span><br><span class="line">        ship.moving_right = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> event.key == pygame.K_LEFT:</span><br><span class="line">        ship.moving_left = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_keyup_event</span><span class="params">(event, ship)</span>:</span></span><br><span class="line">    <span class="string">"""响应松开按键"""</span></span><br><span class="line">    <span class="keyword">if</span> event.key == pygame.K_RIGHT:</span><br><span class="line">        ship.moving_right = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> event.key == pygame.K_LEFT:</span><br><span class="line">        ship.moving_left = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_events</span><span class="params">(ship)</span>:</span></span><br><span class="line">    <span class="string">"""响应按键和鼠标事件"""</span></span><br><span class="line">    <span class="keyword">for</span> event <span class="keyword">in</span> pygame.event.get():</span><br><span class="line">        <span class="keyword">if</span> event.type == pygame.QUIT:</span><br><span class="line">            sys.exit()</span><br><span class="line">        <span class="keyword">elif</span> event.type == pygame.KEYDOWN:</span><br><span class="line">            check_keydown_event(event, ship)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> event.type == pygame.KEYUP:</span><br><span class="line">            check_keyup_event(event, ship)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_screen</span><span class="params">(ai_settings, screen, ship)</span>:</span></span><br><span class="line">    <span class="string">"""更新屏幕上的图像，并切换到新屏幕"""</span></span><br><span class="line">    <span class="comment"># 每次循环时都重绘屏幕</span></span><br><span class="line">    screen.fill(ai_settings.bg_color)</span><br><span class="line">    ship.blitme()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 让最近绘制的屏幕可见</span></span><br><span class="line">    pygame.display.flip()</span><br></pre></td></tr></table></figure>
<p>①在pygame中，用<code>K_RIGHT</code>，<code>K_LEFT</code>表示方向按键，其实键盘上每个键在pygame中都有所对于，以<code>K_</code>开头。<code>check_keydown_event()</code>函数和<code>check_keyup_event()</code>函数都是对下面的<code>check_event()</code>的进一步简化，这两个函数的代码均可以放在<code>check_event()</code>中，但这样代码将会很臃肿，结构不清晰。</p>
<p>②<code>check_event()</code>函数用于监听游戏的事件，比如<code>pygame.QUIT</code>，它表示游戏推出事件；<code>pygame.KEYDOWN</code>和<code>pygame.KEYUP</code>分别表示键盘按下与松开事件。本次大循环中（外层的<code>while</code>循环）发生的所有事件都存储在<code>pygame.event</code>中，我们使用<code>get()</code>方法获得这些事件。</p>
<p>③在<code>update_screen()</code>函数中，我们使用<code>screen</code>的<code>fill()</code>方法填充窗体的背景色，调用<code>blitme()</code>方法来在窗体中绘制飞船，最后，调用<code>pygame.display.flip()</code>方法让最近的绘制在窗体中可见。</p>
<h2 id="运行游戏">2.5 运行游戏</h2>
<p>现在我们运行<code>alien_invasion.py</code>文件，我们将得到如下窗体：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828217/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF11-%E6%AD%A6%E8%A3%85%E9%A3%9E%E8%88%B9/1523767407281.png" /></p>
<p>目前功能还比较简单，只能实现飞船的左右移动。</p>
<h1 id="添加射击功能">3. 添加射击功能</h1>
<p>为了添加射击功能，需要先添加一个子弹类。</p>
<h2 id="bullet.py">3.1 Bullet.py</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"><span class="keyword">from</span> pygame.sprite <span class="keyword">import</span> Sprite</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bullet</span><span class="params">(Sprite)</span>:</span>  <span class="comment"># 使用精灵</span></span><br><span class="line">    <span class="string">"""一个对飞船发射的子弹进行管理的类"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ai_settings, screen, ship)</span>:</span></span><br><span class="line">        <span class="string">"""在飞船所处的位置创建一个子弹对象"""</span></span><br><span class="line">        super(Bullet, self).__init__()</span><br><span class="line">        self.screen = screen</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 在（0,0）处创建一个表示子弹的矩形，再设置正确的位置</span></span><br><span class="line">        self.rect = pygame.Rect(<span class="number">0</span>, <span class="number">0</span>, ai_settings.bullet_width,</span><br><span class="line">                                ai_settings.bullet_height)</span><br><span class="line">        self.rect.centerx = ship.rect.centerx   <span class="comment"># 从飞机的中央位置射出</span></span><br><span class="line">        self.rect.top = ship.rect.top           <span class="comment"># 从飞机的顶部射出</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 存储用浮点数表示的子弹位置，因为子弹只在y轴上运动，所以不需要x坐标</span></span><br><span class="line">        self.y = float(self.rect.y)</span><br><span class="line"></span><br><span class="line">        self.color = ai_settings.bullet_color   <span class="comment"># 子弹颜色</span></span><br><span class="line">        self.speed_factor = ai_settings.bullet_speed_factor   <span class="comment"># 子弹速度</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""向上移动子弹"""</span></span><br><span class="line">        <span class="comment"># 更新表示子弹位置的浮点数值</span></span><br><span class="line">        self.y -= self.speed_factor</span><br><span class="line">        <span class="comment"># 更新表示子弹的rect的位置</span></span><br><span class="line">        self.rect.y = self.y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw_bullet</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""在屏幕上绘制子弹"""</span></span><br><span class="line">        pygame.draw.rect(self.screen, self.color, self.rect)</span><br></pre></td></tr></table></figure>
<p>首先我们需要导入pygame模块以及其中的<code>Sprite</code>类（直译的话叫做“精灵类”，然而这名字叫的真的很尴尬），它可以让我们在后面方便批量处理相同类型的同一操作，子弹类继承自<code>Sprite</code>类。该子弹类并没有使用图片，而是直接在screen上绘制矩形用于表示子弹。<code>update()</code>方法用于更新子弹的位置。<code>pygame.draw.rect()</code>用于在<code>screen</code>上绘制子弹。</p>
<h2 id="修改settings.py">3.2 修改settings.py</h2>
<p>在该模块中添加子弹类的参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Settings</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        -- snip --</span><br><span class="line">        <span class="comment"># 子弹设置</span></span><br><span class="line">        self.bullet_speed_factor = <span class="number">1</span></span><br><span class="line">        self.bullet_width = <span class="number">3</span></span><br><span class="line">        self.bullet_height = <span class="number">15</span></span><br><span class="line">        self.bullet_color = <span class="number">60</span>, <span class="number">60</span>, <span class="number">60</span></span><br><span class="line">        <span class="comment"># 表示窗口中最多允许存在的子弹数，当然你也可以将其去掉</span></span><br><span class="line">        self.bullets_allowed = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h2 id="修改game_functions.py">3.3 修改game_functions.py</h2>
<p>游戏中我们按空格键发射子弹，并发射子弹的过程单独写在一个函数<code>fire_bullet()</code>中。为了响应空格键，需要修改<code>check_event()</code>函数和<code>check_keydown_event()</code>函数，前者只修改了参数，后者在判断结构中添加了一个判断。有了子弹类，那我们还需要在<code>screen</code>中绘制子弹，所以还需要修改<code>update_screen()</code>函数，而子弹自身信息（比如子弹的移动）的修改则放在了一个新的函数<code>update_bullets()</code>中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"><span class="keyword">from</span> Bullet <span class="keyword">import</span> Bullet</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增函数！</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fire_bullet</span><span class="params">(ai_settings, screen, ship, bullets)</span>:</span></span><br><span class="line">    <span class="string">"""如果还没有到达限制，就发射一颗子弹"""</span></span><br><span class="line">    <span class="comment"># 创建新子弹，并将其加入到编组bullets中</span></span><br><span class="line">    <span class="comment"># 如果你想让飞船能无限发射子弹，可以将判断语句删除</span></span><br><span class="line">    <span class="keyword">if</span> len(bullets) &lt; ai_settings.bullets_allowed:</span><br><span class="line">        new_bullet = Bullet(ai_settings, screen, ship)</span><br><span class="line">        bullets.add(new_bullet)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改了参数！</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_keydown_event</span><span class="params">(event, ship, ai_settings, screen, bullets)</span>:</span></span><br><span class="line">    -- snip --</span><br><span class="line">    <span class="comment"># 按空格键发射子弹</span></span><br><span class="line">    <span class="keyword">elif</span> event.key == pygame.K_SPACE:</span><br><span class="line">        fire_bullet(ai_settings, screen, ship, bullets)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改了参数！</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_events</span><span class="params">(ai_settings, screen, ship, bullets)</span>:</span></span><br><span class="line">    <span class="string">"""响应按键和鼠标事件"""</span></span><br><span class="line">    <span class="keyword">for</span> event <span class="keyword">in</span> pygame.event.get():</span><br><span class="line">        -- snip -- </span><br><span class="line">        <span class="keyword">elif</span> event.type == pygame.KEYDOWN:</span><br><span class="line">            <span class="comment"># 增加了参数</span></span><br><span class="line">            check_keydown_event(event, ship, ai_settings, screen, bullets)</span><br><span class="line">        -- snip --</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改了函数！</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_screen</span><span class="params">(ai_settings, screen, ship, bullets)</span>:</span></span><br><span class="line">    -- snip --</span><br><span class="line">    <span class="comment"># 绘制子弹</span></span><br><span class="line">    <span class="keyword">for</span> bullet <span class="keyword">in</span> bullets.sprites():</span><br><span class="line">        bullet.draw_bullet()</span><br><span class="line">    -- snip --</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_bullets</span><span class="params">(bullets)</span>:</span></span><br><span class="line">    <span class="string">"""更新子弹的位置，并删除已消失的子弹"""</span></span><br><span class="line">    <span class="comment"># 更新子弹的位置</span></span><br><span class="line">    <span class="comment"># bullets是个Group对象，调用一次update()就会调用其中所有Sprite对象的update()</span></span><br><span class="line">    <span class="comment"># 相当于你不用自己写for循环了</span></span><br><span class="line">    bullets.update()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 删除已消失的子弹</span></span><br><span class="line">    <span class="keyword">for</span> bullet <span class="keyword">in</span> bullets.copy():</span><br><span class="line">        <span class="keyword">if</span> bullet.rect.bottom &lt;= <span class="number">0</span>:</span><br><span class="line">            bullets.remove(bullet)</span><br></pre></td></tr></table></figure>
<p>当子弹从窗口中消失时，它并没有从内存中消失，如果对于已经从屏幕中消失的子弹不做处理的话，时间一长，子弹数一多，光子弹一项的内存占用就会越来越多（土豪请忽略），虽然只是线性增长，但作为一个合格的程序员，应该避免这种无谓的浪费。</p>
<h2 id="修改alien_invation.py">3.4 修改alien_invation.py</h2>
<p>最后，我们修改主程序，在其中添加一个<code>pygame.sprite</code>中的<code>Group</code>对象用于表示子弹集合，以及对该对象的操作代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"><span class="keyword">from</span> pygame.sprite <span class="keyword">import</span> Group   <span class="comment"># 导入一个新类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> game_functions <span class="keyword">as</span> gf</span><br><span class="line"><span class="keyword">from</span> settings <span class="keyword">import</span> Settings</span><br><span class="line"><span class="keyword">from</span> ship <span class="keyword">import</span> Ship</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_game</span><span class="params">()</span>:</span></span><br><span class="line">    -- snip --</span><br><span class="line">    bullets = Group()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始游戏的主循环</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        gf.check_events(ai_settings, screen, ship, bullets)</span><br><span class="line">        ship.update()</span><br><span class="line">        gf.update_bullets(bullets)</span><br><span class="line">        gf.update_screen(ai_settings, screen, ship, bullets)</span><br></pre></td></tr></table></figure>
<h2 id="运行新代码">3.5运行新代码</h2>
<p>以下是运行截图：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828217/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF11-%E6%AD%A6%E8%A3%85%E9%A3%9E%E8%88%B9/1523775773240.png" /></p>
<h1 id="小结">4. 小结</h1>
<p>自此，我们创建了一个能开火的小飞机，在下一篇文章中我们将向其中添加外星人。</p>
<p>本篇中的代码都是经过了重构后的代码，但是，当我们自己在编程时，如果对某一框架还是小白，搞不清楚该如何组织代码，那就把所有代码都写在一个或几个文件里（虽然这种习惯很不好），也暂时不用考虑代码结构之类的问题，因为<strong>你的任务是造东西，而不是写漂亮代码，用精巧结构，用别人没看过的语法。</strong>两者能兼备当然更好，但每个人都有当小白的时期，有一定熟练度后，再来考虑代码重构的问题。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python基础</tag>
        <tag>Pygame</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路10-测试代码</title>
    <url>/2018/04/14/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF10-%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<blockquote>
<p>《Python编程：从入门到实践》笔记。 本章主要学习如何使用Python标准库中的unittest模块对代码进行简单的测试。</p>
</blockquote>
<a id="more"></a>
<h1 id="前言">1. 前言</h1>
<p>作为初学者，并非必须为你尝试的所有项目编写测试；但参与工作量较大的项目时，你应对自己编写的函数和类的重要行为进行测试。这样你就能够更加确定自己所做的工作不会破坏项目的其他部分，你就能够随心所欲地改进即有代码。如果不小心破坏了原来的功能，你马上就会知道，从而能够轻松地修复问题。相比于等到Bug出现后再去改，在测试未通过时采取措施要容易得多。而且，如果你想要分享你的项目，有测试的代码更容易让人接受。</p>
<h1 id="测试函数">2. 测试函数</h1>
<h2 id="一个能通过的测试">2.1 一个能通过的测试</h2>
<p>以下是一个将用户输入的姓与名拼接的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># name_function.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_formatted_name</span><span class="params">(first, last)</span>:</span></span><br><span class="line">    <span class="string">"""返回一个整洁的完整姓名"""</span></span><br><span class="line">    full_name = first + <span class="string">" "</span> + last</span><br><span class="line">    <span class="keyword">return</span> full_name.title()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">"Enter 'q' at any time to quit."</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        first = input(<span class="string">"\nPlease give me a first name: "</span>)</span><br><span class="line">        <span class="keyword">if</span> first == <span class="string">"q"</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        last = input(<span class="string">"Please give me a last name: "</span>)</span><br><span class="line">        <span class="keyword">if</span> last == <span class="string">"q"</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        formatted_name = get_formatted_name(first, last)</span><br><span class="line">        print(<span class="string">"\nNeatly formatted name: "</span> + formatted_name + <span class="string">"."</span>)</span><br></pre></td></tr></table></figure>
<p>当然你也可以将if语句下面的代码单独放在一个文件中，并在该文件开头带入<code>get_formatted_name()</code>函数。</p>
<p>对<code>if __name__ == "__main__"</code>的补充：</p>
<p>在Python中，模块就是对象，所有模块都有一个内置属性<code>__name__</code>，当该模块被导入时，该模块的<code>__name__</code>属性会被置为模块名，当直接运行该模块，或者说直接运行该文件时，该属性就会使用默认值<code>"__main__"</code>，可以用一句经典的话总结这个用法：</p>
<p><code>Make a script both importable and executable.</code></p>
<p><code>if</code>语句下面的代码相当于对上面的函数的测试，不过这样的测试每次都需要我们自己输入数据，并自己根据结果判断代码是否工作正常，如果代码稍微多一点，稍微复杂一点，这样的测试方法将会很繁琐，所以，我们使用<code>unittest</code>模块了测试代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码test_name_function.py：</span></span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> name_function <span class="keyword">import</span> get_formatted_name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NamesTestCase</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="string">"""测试name_function.py"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_first_last_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""能够正确地处理像Janis Joplin这样的名字吗？"""</span></span><br><span class="line">        formatted_name = get_formatted_name(<span class="string">"janis"</span>, <span class="string">"joplin"</span>)</span><br><span class="line">        self.assertEqual(formatted_name, <span class="string">"Janis Joplin"</span>)</span><br><span class="line"></span><br><span class="line">unittest.main()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">.     <span class="comment"># 这里有个实心句点</span></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran <span class="number">1</span> test <span class="keyword">in</span> <span class="number">0.001</span>s</span><br><span class="line"></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p>这里先明确两个概念：</p>
<p><strong>单元测试</strong>：用于核实函数在某个方面没有问题</p>
<p><strong>测试用例</strong>：一组单元测试，这些单元测试一起核实函数在各种情况下的行为都符合要求。</p>
<p>也就是说，你可以将上述代码中的<code>test_first_last_name</code>看做单元测试，而将<code>NamesTestCase</code>看做测试用例。</p>
<p>一般测试文件单独放在一个文件夹中，也可以将测试都放在一个文件中。</p>
<p>为函数编写测试用例，可先导入<code>unittest</code>模块和要测试的函数，再创建一个继承<code>unittest.TestCase</code>的类，并编写一系列方法对函数行为的不同方面进行测试。在测试用，我们使用断言<code>self.assertEqual()</code>(并不是只有这一个断言函数)来判断结果与期望是否相同。在测试类中的每一个测试方法都必须以<code>test_</code>开头，否则将不会被认定是一个单元测试。最后我们通过<code>unittest.main()</code>来运行这个文件中的所有测试。当测试通过时，结果中会先输出一个实心句点，输出几个句点表示通过了几个单元测试，然后输出单元测试数目，最后输出<code>OK</code>。</p>
<h2 id="一个不能通过的测试">2.2 一个不能通过的测试</h2>
<p>外国人的名字还有中间名，以上代码并未考虑这个情况。我们通过将上述代码改成含有中间名的版本来演示测试不通过的情况：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_formatted_name</span><span class="params">(first, middle, last)</span>:</span></span><br><span class="line">    <span class="string">"""返回一个整洁的完整姓名"""</span></span><br><span class="line">    full_name = first + <span class="string">" "</span> + middle + <span class="string">" "</span> + last</span><br><span class="line">    <span class="keyword">return</span> full_name.title()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其余代码均不变</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行上面测试代码后的结果：</span></span><br><span class="line">E</span><br><span class="line">======================================================================</span><br><span class="line">ERROR: test_first_last_name (__main__.NamesTestCase)</span><br><span class="line">能够正确地处理像Janis Joplin这样的名字吗？</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"test_name_function.py"</span>, line <span class="number">10</span>, <span class="keyword">in</span> test_first_last_name</span><br><span class="line">    formatted_name = get_formatted_name(<span class="string">"janis"</span>, <span class="string">"joplin"</span>)</span><br><span class="line">TypeError: get_formatted_name() missing <span class="number">1</span> required positional argument: <span class="string">'last'</span></span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran <span class="number">1</span> test <span class="keyword">in</span> <span class="number">0.001</span>s</span><br><span class="line"></span><br><span class="line">FAILED (errors=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>第一行输出了一个字母<code>E</code>，<code>traceback</code>指出缺少了参数。如果你检查的条件没错，测试通过了意味着函数的行为是对的，而测试未通过意味着你编写的新代码有错。因此，测试未通过时，不是去修改测试代码，而失去修改你编写的代码。</p>
<h2 id="添加新测试">2.3 添加新测试</h2>
<p>以下我们将上述的<code>get_formatted_name()</code>函数修改为能自动处理中间名的函数，并在测试文件中添加一个单元测试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># name_function.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_formatted_name</span><span class="params">(first, last, middle=<span class="string">""</span>)</span>:</span></span><br><span class="line">    <span class="string">"""返回一个整洁的完整姓名"""</span></span><br><span class="line">    <span class="keyword">if</span> middle:</span><br><span class="line">        full_name = first + <span class="string">" "</span> + middle + <span class="string">" "</span> + last</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        full_name = first + <span class="string">" "</span> + last</span><br><span class="line">    <span class="keyword">return</span> full_name.title()</span><br><span class="line"></span><br><span class="line"><span class="comment"># test_name_function.py</span></span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> chapter11 <span class="keyword">import</span> get_formatted_name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NamesTestCase</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="string">"""测试name_function.py"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_first_last_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""能够正确地处理像Janis Joplin这样的名字吗？"""</span></span><br><span class="line">        formatted_name = get_formatted_name(<span class="string">"janis"</span>, <span class="string">"joplin"</span>)</span><br><span class="line">        self.assertEqual(formatted_name, <span class="string">"Janis Joplin"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_first_last_middle_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""能够正确地处理像Wolfgang Amadeus Mozart这样的姓名吗？"""</span></span><br><span class="line">        formatted_name = get_formatted_name(<span class="string">"wolfgang"</span>, <span class="string">"mozart"</span>, <span class="string">"amadeus"</span>)</span><br><span class="line">        self.assertEqual(formatted_name, <span class="string">"Wolfgang Amadeus Mozart"</span>)</span><br><span class="line"></span><br><span class="line">unittest.main()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">..</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran <span class="number">2</span> tests <span class="keyword">in</span> <span class="number">0.000</span>s</span><br><span class="line"></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<h1 id="测试类">3. 测试类</h1>
<p>前面讲的都是对函数的测试，这里我们开始对类的测试。在测试之前，先介绍几种常用的断言方法：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">方法</th>
<th style="text-align: left;">用途</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">assertEqual(a, b)</td>
<td style="text-align: left;">核实 a == b</td>
</tr>
<tr class="even">
<td style="text-align: left;">assertNotEqual(a, b)</td>
<td style="text-align: left;">核实 a != b</td>
</tr>
<tr class="odd">
<td style="text-align: left;">assertTrue(x)</td>
<td style="text-align: left;">核实x为True</td>
</tr>
<tr class="even">
<td style="text-align: left;">assertFalse(x)</td>
<td style="text-align: left;">核实x为False</td>
</tr>
<tr class="odd">
<td style="text-align: left;">assertIn(item, list)</td>
<td style="text-align: left;">核实item在list中</td>
</tr>
<tr class="even">
<td style="text-align: left;">assertNotIn(item, list)</td>
<td style="text-align: left;">核实item不在list中</td>
</tr>
</tbody>
</table>
<p>下面创建一个匿名调查类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># survey.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnonymousSurvey</span>:</span></span><br><span class="line">    <span class="string">"""收集匿名调查问卷的答案"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, question)</span>:</span></span><br><span class="line">        <span class="string">"""存储一个问题，并为存储答案做准备"""</span></span><br><span class="line">        self.question = question</span><br><span class="line">        self.responses = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_question</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""显示调查问卷"""</span></span><br><span class="line">        print(self.question)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">store_response</span><span class="params">(self, new_response)</span>:</span></span><br><span class="line">        <span class="string">"""存储单份调查问卷"""</span></span><br><span class="line">        self.responses.append(new_response)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_results</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""显示收集到的所有答卷"""</span></span><br><span class="line">        print(<span class="string">"Survey results:"</span>)</span><br><span class="line">        <span class="keyword">for</span> response <span class="keyword">in</span> self.responses:</span><br><span class="line">            print(<span class="string">"- "</span> + response)</span><br></pre></td></tr></table></figure>
<p>以下是对该类的测试代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test_survey.py</span></span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> chapter11 <span class="keyword">import</span> AnonymousSurvey</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestAnonymousSurvey</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="string">"""针对AnonymousSurvey类的测试"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""创建一个调查对象和一组答案，共测试方法使用"""</span></span><br><span class="line">        question = <span class="string">"What language did you first learn to speak?"</span></span><br><span class="line">        self.my_survey = AnonymousSurvey(question)</span><br><span class="line">        self.responses = [<span class="string">"English"</span>, <span class="string">"Spanish"</span>, <span class="string">"Mandarin"</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_store_single_response</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""测试单个答案呗妥善地存储"""</span></span><br><span class="line">        self.my_survey.store_response(self.responses[<span class="number">0</span>])</span><br><span class="line">        self.assertIn(self.responses[<span class="number">0</span>], self.my_survey.responses)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_store_three_responses</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""测试三个答案会被妥善地存储"""</span></span><br><span class="line">        <span class="keyword">for</span> response <span class="keyword">in</span> self.responses:</span><br><span class="line">            self.my_survey.store_response(response)</span><br><span class="line">        <span class="keyword">for</span> response <span class="keyword">in</span> self.responses:</span><br><span class="line">            self.assertIn(response, self.my_survey.responses)</span><br><span class="line"></span><br><span class="line">unittest.main()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">..</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran <span class="number">2</span> tests <span class="keyword">in</span> <span class="number">0.000</span>s</span><br><span class="line"></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p>这里的<code>setUp()</code>方法相当于普通函数的<code>__init__()</code>方法，用于初始化这个测试类，减少重复代码，比如，如果不用<code>setUp()</code>方法，那么<code>question</code>变量在每个测试函数中都要声明一次，十分麻烦低效。你过测试类中包含了<code>setUp()</code>方法，Python将先运行它，再运行各个以<code>test_</code>开头的方法。</p>
<p><strong>至此，Python的基础部分大致结束，后面将是项目部分，以后可能还会对基础部分进行补充。</strong></p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路9-文件和异常</title>
    <url>/2018/04/12/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF9-%E6%96%87%E4%BB%B6%E5%92%8C%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<blockquote>
<p>《Python编程：从入门到实践》笔记。 本章主要是学习Python的文件操作，主要是从文件中读取数据以及将数据存储到文件中，还有错误处理，异常类，json模块等。</p>
</blockquote>
<a id="more"></a>
<h1 id="从文件中读数据">1. 从文件中读数据</h1>
<h2 id="读取整个文件">1.1 读取整个文件</h2>
<p>以下文件<code>pi_digits.txt</code>包含了精确到小数点后30位的圆周率数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pi_digits.txt文件</span></span><br><span class="line"><span class="number">3.1415926535</span></span><br><span class="line">  <span class="number">8979323846</span></span><br><span class="line">  <span class="number">2643383279</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 代码：</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"pi_digits.txt"</span>, <span class="string">"r"</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">    contents = file_object.read()   <span class="comment"># 一次性读取整个文件</span></span><br><span class="line">    print(contents)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：和上述文件内容一样</span></span><br></pre></td></tr></table></figure>
<p>从上述代码可以看出，我们打开文件使用<code>open()</code>函数，该函数至少接收一个参数，即文件路径。读取文件时需要向<code>open()</code>函数指明是用什么方式读取文件，是只读(<code>"r"</code>)，只写(<code>"w"</code>)，末尾添加(<code>"a"</code>)还是读写均可(<code>"r+"</code>)，<code>open()</code>函数默认以“只读”方式读取文件。这只是4中常用的文件读取方式，此外还有至少8种读写方式。<code>open()</code>函数返回一个文件对象，<code>file_object</code>用于接收该对象。通过文件对象的<code>read()</code>方法读取文件内容，且该方法返回整个文件的内容。</p>
<p>上述代码中的文件和源代码在同一目录中。注意文件路径的问题，绝对路径（不提倡）和相对路径（相对于源文件的路径）以及Windows和Linux下路径的写法。</p>
<p>注意代码中的<code>with</code>关键字。其实读写文件不需要该关键字，打开文件使用<code>open()</code>函数，文件读取完后关闭文件使用<code>close()</code>函数，读取内容可以调用<code>read()</code>方法。而之所以使用<code>with</code>关键字，主要是因为①你最后忘记关闭文件，就想忘了关灯一样；②也可能是在关闭前程序出错，导致<code>close()</code>语句未执行。这些让文件没有关闭的情况都有可能导致数据丢失或损坏。<code>with</code>关键字则被用来应对这些情况，它保证在结束<code>with</code>块时，文件一定会被关闭。</p>
<h2 id="逐行读取">1.2 逐行读取</h2>
<p>上述代码一次性读取整个文件，这在文件较小或者内存充裕的时候没有问题，但如果文件特别大，内存容量又很羞涩，则只能逐行读取：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">file_name = <span class="string">"pi_digits.txt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(file_name) <span class="keyword">as</span> file_pi:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> file_pi:  <span class="comment"># 也可以通过while循环配合readline()方法逐行读取文件</span></span><br><span class="line">        print(line)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line"><span class="number">3.1415926535</span></span><br><span class="line"></span><br><span class="line">  <span class="number">8979323846</span></span><br><span class="line"></span><br><span class="line">  <span class="number">2643383279</span></span><br></pre></td></tr></table></figure>
<p>这里需要注意一个问题，就是对行以及文件末尾空字符的读取问题，<code>read()</code>和<code>readline()</code>方法会读取末尾的空字符（这里是换行符）。我们可以通过之前讲的<code>rstrip()</code>方法去掉末尾的空字符。</p>
<h2 id="将文件每一行放入列表中">1.3 将文件每一行放入列表中</h2>
<p><code>readlines()</code>方法将文件中每一行存入列表并返回，以下代码进一步处理文件中的内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">file_name = <span class="string">"pi_digits.txt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(file_name) <span class="keyword">as</span> file_pi:</span><br><span class="line">    lines = file_pi.readlines()</span><br><span class="line"></span><br><span class="line">pi_string = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    pi_string += line.strip()</span><br><span class="line"></span><br><span class="line">print(pi_string)</span><br><span class="line">print(len(pi_string))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line"><span class="number">3.141592653589793238462643383279</span></span><br><span class="line"><span class="number">32</span></span><br></pre></td></tr></table></figure>
<p>注意，Python从文件中读取出的所有内容都是字符串，如果你想要的是数字，请记得转换。</p>
<h1 id="写入文件">2. 写入文件</h1>
<p>以下是一个简单的文件写入程序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">filename = <span class="string">"python.txt"</span></span><br><span class="line"><span class="keyword">with</span> open(filename, <span class="string">"w"</span>) <span class="keyword">as</span> file_obj:</span><br><span class="line">    file_obj.write(<span class="string">"I love python!"</span>)</span><br></pre></td></tr></table></figure>
<p>执行改代码后你会看到在同一目录下会生成一个名为“python.txt"的文件。需要注意的是，以<code>"w"</code>方式打开文件，如果要写入的文件不存在，则会自动创建该文件；如果该文件存在，该文件的内容会被清空，然后再写入。如果不想文件被清空，请使用<code>"a"</code>（文件指针放在文件末尾）或<code>"r+"</code>（文件指针指向文件开头）方式打开文件。还有一点，<code>write()</code>函数不会在文件末尾添加换行符，如果需要换行符，请自行添加。</p>
<h1 id="异常">3. 异常</h1>
<p>Python中使用被称为异常的特殊对象来管理程序执行期间发生的错误。每当代码运行时如果遇到了不能处理的错误，Python都会创建一个异常对象，如果程序中没有处理该对象的相关代码，程序将会停止，并显示一个<code>traceback</code>，其中包含异常的相关报告。如果不想程序因为某些异常而终止运行，则需要我们使用<code>try-except</code>代码块自行处理异常。以下是一个处理除零错误<code>ZeroDivisionError</code>的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line"><span class="comment"># 捕捉异常</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    resule = <span class="number">5</span> / <span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    print(<span class="string">"You can't divide by zero!\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不捕捉异常</span></span><br><span class="line">print(<span class="number">5</span> / <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">You can<span class="string">'t divide by zero!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File "division.py", line 29, in &lt;module&gt;</span></span><br><span class="line"><span class="string">    print(5 / 0)</span></span><br><span class="line"><span class="string">ZeroDivisionError: division by zero</span></span><br></pre></td></tr></table></figure>
<p>如果你打算编写一个计算器应用，那么这段代码必不可少。第一个例子表明，即使发生了异常，只要异常被我们捕捉，那么程序便不会终止。如果只想捕捉异常，但暂时又不想处理，可以将上述的<code>print("You can't divide by zero!\n")</code>替换为<code>pass</code>语句。如果想捕获所有的异常，则<code>except</code>后面不指定异常类型。</p>
<h2 id="else代码块">3.1 else代码块</h2>
<p><code>try-except</code>代码块还可以和else语句组合形成<code>try-except-else</code>代码块，该结构表示，如果捕获了异常，这执行<code>except</code>中的程序，没有发生异常则执行<code>else</code>中的程序。以下程序是一个循环统计文件中单词数的例子，文件读取的部分被放到了函数中，该函数检测有没有发生<code>FileNotFoundError</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_words</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="string">"""计算一个文件大致包含多少个单词"""</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> open(filename) <span class="keyword">as</span> f_obj:</span><br><span class="line">            contents = f_obj.read()</span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        msg = <span class="string">"Sorry, the file"</span> + filename + <span class="string">" does not exist."</span></span><br><span class="line">        print(msg)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 计算文件大只包含多少个单词</span></span><br><span class="line">        words = contents.split()</span><br><span class="line">        num_words = len(words)</span><br><span class="line">        print(<span class="string">"The file "</span> + filename + <span class="string">" has about "</span> + str(num_words) + <span class="string">"words."</span>)</span><br><span class="line"></span><br><span class="line">filenames = [<span class="string">"alice.txt"</span>, <span class="string">"siddhartha.txt"</span>, <span class="string">"moby_dick.txt"</span>, <span class="string">"little_women.txt"</span>]</span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">    count_words(filename)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">The file alice.txt has about <span class="number">29461</span> words.</span><br><span class="line">Sorry, the file siddhartha.txt does <span class="keyword">not</span> exist.</span><br><span class="line">The file moby_dick.txt has about <span class="number">215136</span> words.</span><br><span class="line">The file little_women.txt has about <span class="number">189097</span> words.</span><br></pre></td></tr></table></figure>
<p><strong>对<code>else</code>的补充：</strong>其实<code>else</code>不光可以和<code>if</code>，<code>try-except</code>结合，还可以和<code>for</code>循环和<code>while</code>循环结合，比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">10</span>:</span><br><span class="line">    i++</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>这里的<code>else</code>表示当循环结束后执行一些语句，比如提示之类的。</p>
<h2 id="决定报告哪些错误">3.2 决定报告哪些错误</h2>
<p>编写得很好且经过详尽测试的代码不容易出现内部错误，如语法或逻辑错误，但只要程序依赖于外部因素，如用户输入、存在指定的文件、有网络连接等，就有可能出现异常。凭经验可判断改在程序的什么地方包含异常处理块，以及出现错误时该向用户提供多少相关的信息。</p>
<h1 id="存储数据">4. 存储数据</h1>
<p>很多程序要求用户输入某种信息，也有可能程序中某些变量的数据在程序结束后不能丢失（比如机器学习最后训练出来的模型参数），这是就需要将这些信息以文件的形式存下来。存储数据的方式有很多，现在比较简单且通用的是使用<code>json</code>来存储信息。<code>json</code>(JavaScript Object Notation)格式最初是为JavaScript 开发的，但随后成了一种常见格式，并被包括Python在内的众多语言采用。以下是一个经过了重构的存储用户信息的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_stored_username</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="string">"""如果存储了用户名，就获取它"""</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> open(filename) <span class="keyword">as</span> f_obj:</span><br><span class="line">            username = json.load(f_obj)</span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> username</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_new_username</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="string">"""提示用户输入用户名，并存入文件"""</span></span><br><span class="line">    username = input(<span class="string">"What's your name?"</span>)</span><br><span class="line">    <span class="keyword">with</span> open(filename, <span class="string">"w"</span>) <span class="keyword">as</span> f_obj:</span><br><span class="line">        json.dump(username, f_obj)</span><br><span class="line">    <span class="keyword">return</span> username</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet_user</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="string">"""向用户打招呼"""</span></span><br><span class="line">    username = get_stored_username(filename)</span><br><span class="line">    <span class="keyword">if</span> username:</span><br><span class="line">        print(<span class="string">"Welcome back, "</span> + username + <span class="string">"!"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        username = get_new_username(filename)</span><br><span class="line">        print(<span class="string">"We'll remember you when you come back, "</span> + username + <span class="string">"!"</span>)</span><br><span class="line"></span><br><span class="line">filename = <span class="string">"username.json"</span></span><br><span class="line">greet_user(filename)</span><br></pre></td></tr></table></figure>
<p>代码就不运行了，请各位自行推导程序的结果。最后在<code>username.json</code>文件中会存有用户的信息。但要注意一点，<code>json</code>根据数据类型来存储数据，虽然最后都是字符串，但这个过程不需要我们干预，比如要存一个列表，并不需要我们先将其转换为字符串，再存入<code>json</code>，读取数据时也不需要我们先读取为字符串，再转换成列表，我们只需直接存取即可，转换工作由<code>json</code>模块自动完成。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路8.2-对Python类的补充</title>
    <url>/2018/04/11/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF8.2-%E5%AF%B9Python%E7%B1%BB%E7%9A%84%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<blockquote>
<p>《Python编程：从入门到实践》笔记。 本章主要是对上一章Python类的补充。</p>
</blockquote>
<a id="more"></a>
<h1 id="从一个类派生出所有类">1. 从一个类派生出所有类</h1>
<p>上一篇文章说道Python类的定义与继承一般是如下形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span>   <span class="comment"># 或者写成class A():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>其实，对于类<code>A</code>，它并不是算是一个真正意义上的基类，而是和Java类似，Python中所有的类最终都继承自<code>object</code>类（首字母小写，比较特殊），所以对于<code>A</code>的定义可以写成如下形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>只是通常把<code>object</code>给省略了。</p>
<h1 id="访问限制">2. 访问限制</h1>
<p>从上一篇中我们知道，类的属性可以被直接访问，如果需要对访问做一些限制，我们可以通过定义相应的方法。在Python中，对于一般的属性，用C++或Java的话来说，它们都是公有属性，外部可以直接访问，比如像下面的这个<code>name</code>属性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br></pre></td></tr></table></figure>
<p>但如果我们在这个属性前面加两个下划线，将其变成如下形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.__name = name</span><br></pre></td></tr></table></figure>
<p>那么<code>name</code>就变成了一个私有属性，它只能在对象的内部被访问，如果想以如下形式访问则会报错：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    -- snip --</span><br><span class="line">    </span><br><span class="line">a = A(<span class="string">"test"</span>)</span><br><span class="line">print(a.__name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">AttributeError: <span class="string">'A'</span> object has no attribute <span class="string">'__name'</span></span><br></pre></td></tr></table></figure>
<p>那是不是真的就访问不到这个属性了呢？说不清是有幸还是不幸，Python没有所谓的真正的私有属性，Python中类的所有属性都能被访问。Python解释器只是将<code>__name</code>换了个名称，变成了<code>self._A_name</code>，即在前面加了一个单下划线和类名。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    -- snip --</span><br><span class="line">    </span><br><span class="line">a = A(<span class="string">"test"</span>)</span><br><span class="line">print(a._A__name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">test</span><br></pre></td></tr></table></figure>
<p><strong>强烈不建议这样访问属性！</strong>而且，不同版本的Python解释器会将这样的属性改成不同的名字。</p>
<h1 id="使用装饰器decorator">3. 使用装饰器（decorator）</h1>
<p>在上一点中说到了通过方法来访问类的属性，这种方式一般叫做<code>get/set方法</code>，最后在调用时调用的是类的方法，现在我们使用Python内置的<code>@property</code>装饰器来访问类的属性，最后在调用时是调用的属性，实际上它是将类的方法通过装饰器变为属性。以下是通过装饰器和通过<code>get/set方法</code>来访问属性的代码比较：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_name</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="comment"># 可以加上一些限制</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self._name = name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @name.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="comment"># 可以加上一些限制</span></span><br><span class="line">        self._name = name</span><br><span class="line"></span><br><span class="line">t = Teacher(<span class="string">"Miss"</span>)</span><br><span class="line">s = Student(<span class="string">"Boy"</span>)</span><br><span class="line"></span><br><span class="line">print(t.get_name())</span><br><span class="line">print(s.name)</span><br><span class="line">t.set_name(<span class="string">"Miss Lee"</span>)</span><br><span class="line">s.name = <span class="string">"Kevin"</span></span><br></pre></td></tr></table></figure>
<p>从上述代码也可以看出，定义的时候，两者的代码量区别其实不大，但是在调用的时候，明显使用装饰器更方便些。</p>
<h1 id="类中其它类型的属性">4. 类中其它类型的属性</h1>
<p>类中除了普通的属性，以及上述的私有属性，还有前后都有<strong>双下划线</strong>的属性，例如<code>__xxx__</code>，它们是特殊变量，可以被直接访问，不是私有属性，所以一般不要起<code>__name__</code>，<code>__score__</code>这样的属性名，对于方法也是如此，不光有想<code>__init__()</code>这样的方法，还有很多前后都有双下划线的方法，比如<code>__del__()</code>，它是类的析构函数。在以后的文章中还会介绍许多这种方法。</p>
<p>不光有双下划线的属性，还有<strong>单下划线</strong>的比如 <code>_name</code>，前单下划线，它表示的意思是：虽然能被访问，但请将其看做私有属性，不要随便访问。</p>
<h1 id="对于多态的补充">5. 对于多态的补充</h1>
<p>子类可以被看成是父类的类型，但父类不能被看成是子类的类型。比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">a = Animal()</span><br><span class="line">d = Dog()</span><br><span class="line"></span><br><span class="line">print(isinstance(d, Animal))</span><br><span class="line">print(isinstance(a, Dog))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>也就是说，如果我们定义了这样一个函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">animal_run</span><span class="params">(animal)</span>:</span></span><br><span class="line">    animal.run()</span><br></pre></td></tr></table></figure>
<p>它接收<code>Animal</code>及其子类的所有对象，只要该类的<code>run()</code>方法正确编写，Python都能在解释时正确调用相应类的<code>run()</code>方法，即调用方只管调用<code>animal_run()</code>函数，不用管类的<code>run()</code>方法的细节，不管是现有的类还是新扩展出的子类，只要保证<code>run()</code>正确实现了，那么<code>animal_run()</code>就是正确的。这就是著名的<code>“开闭原则”</code>：对扩展开放，对修改封闭。</p>
<h1 id="静态语言与动态语言">6. 静态语言与动态语言</h1>
<p>仍以上面的<code>animal_run()</code>函数为例。对于像Java这样的静态语言，传入的参数必须是<code>Animal</code>及其子类，否则就无法调用<code>run()</code>方法。而对于像Python这样的动态语言，传入的不一定要求是<code>Animal</code>及其子类，只要这个对象有<code>run()</code>方法就行了。这就是动态语言的<code>“鸭子类型”</code>，只要“看起来像鸭子，走起道来像鸭子”，那它就能被看做是鸭子。Python的<code>“file-like object”</code>就是一种“鸭子类型”，对于真正的文件对象，都有一个<code>read()</code>方法，用于返回文件内容。但对于其他对象，只要正确实现了<code>read()</code>方法，即使它不是文件对象，它也能被看做是文件。</p>
<h1 id="多重继承与mixin设计">7. 多重继承与MixIn设计</h1>
<p>前一篇文章中的继承是单继承，但Python和C++一样，支持多重继承；Java只支持单继承，她通过接口类来实现多重继承的效果。首先需要搞清楚多重继承为什么存在。仍然以<code>Animal</code>类为例，动物里有哺乳动物，卵生动物，有能飞的动物和不能飞的动物，这是两种大的分类方式。如果我们要派生出一个能飞的哺乳动物（比如蝙蝠），如果按照单一继承，可以按如下方式：</p>
<p><img src="https://res.cloudinary.com/vpointer/image/upload/v1527828106/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF8.2-%E5%AF%B9Python%E7%B1%BB%E7%9A%84%E8%A1%A5%E5%85%85/MI.png" /></p>
<p>也可以先从<code>Animal</code>继承出<code>Runnable</code>和<code>Flyable</code>两个类，再继承出哺乳类和卵生类（相当于将上图的二三层换了位置），但从这种单继承可以看出，如果分类增多，类的数量将呈指数级增加。故而一般采用多重继承的方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mammalia</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flyable</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fly</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Flying..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bat</span><span class="params">(Mammalia, Flyable)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>这样<code>Bat</code>类将具有<code>Mammalia</code>和<code>Flyable</code>两个父类的所有属性与方法。一般在Java中，以<code>able</code>为结尾类的都作为接口。</p>
<p>在设计类的继承的时候，一般主线都是单一继承的，像上述例子中的从<code>Animal</code>派生出<code>Manmalia</code>，但如果后续的类中要混入一些额外的功能，但这功能又不是这个子类所独有的，比如上述的<code>Flyable</code>，那么就可以通过多重继承，从<code>Manmalia</code>和<code>Runnable</code>派生出<code>Bat</code>类，这就是<code>MixIn设计</code>，Java中采用接口来实现这种设计。</p>
<p>为了更好的看出继承关系，一般将<code>Runnable</code>和<code>Flyable</code>类的名字改为<code>RunnableMixIn</code>和<code>FlyableMixIn</code>，同时，还可以定义出肉食动物<code>CarnivorousMixIn</code>和植食动物<code>HerbivoresMixIn</code>，让子类同时拥有好几个<code>MixIn</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Mammalia, RunnableMixIn, CarnivorousMixIn)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>所以在设计类时，我们应该优先考虑通过多重继承来组合多个<code>MixIn</code>，而不是直接考虑更多层次的继承关系。</p>
<p>最后，本篇较多内容是根据廖雪峰老师的博客再理解而来的，感谢廖雪峰老师！</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路8.1-类</title>
    <url>/2018/04/11/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF8.1-%E7%B1%BB/</url>
    <content><![CDATA[<blockquote>
<p>《Python编程：从入门到实践》笔记。 本章主要介绍一种重要的编程思想：面向对象编程，包括了类与对象等概念及操作。</p>
</blockquote>
<a id="more"></a>
<h1 id="概述">1. 概述</h1>
<p><strong>面向对象编程(Object-oriented programming, OOP)</strong>是最有效的软件编写方法之一。面向对象的思想也是人类自古认识世界的方法，即“分门别类”。而在以往的经验里，笔者印象最深刻的面向对象思想就是中学生物课本上对自然界的分类：界门纲目科属种。这里要明白两个概念：类与对象。类是一个总的抽象概念，是一群相似事物的总括，是一个虚的概念，而这些“事物”便是对象，例如：“狗”这一概念，这就是一个“类”，哪怕是具体到某一个特定的种类，比如哈士奇，这也是个类，只有当真正具体到某一条狗时，比如“你家的哈士奇A”，这才到达了“对象”这一概念，综上：<strong>类是抽象的，对象是实际的</strong>。而从类到对象的过程，就叫做<strong>类的实例化</strong>。</p>
<h1 id="创建和使用类">2. 创建和使用类</h1>
<h2 id="创建一个car类">2.1 创建一个Car类</h2>
<p>在Python中类名一般采用驼峰命名法，即每个单词的首字母大写，而不使用下划线，实例名和模块名都采用小写，用下划线拼接。并且，不论是在写函数，类，还是代码文件，最好都加上一个文档字符串，比如下面的三引号字符串。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>:</span></span><br><span class="line">    <span class="string">"""一次模拟汽车的简单尝试"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, make, model, year)</span>:</span></span><br><span class="line">        <span class="string">"""初始化描述汽车的属性"""</span></span><br><span class="line">        self.make = make</span><br><span class="line">        self.model = model</span><br><span class="line">        self.year = year</span><br><span class="line">        self.odometer_reading = <span class="number">0</span>  <span class="comment"># 里程表</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_descriptive_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回整洁的描述性信息"""</span></span><br><span class="line">        long_name = str(self.year) + <span class="string">" "</span> + self.make + <span class="string">" "</span> + self.model</span><br><span class="line">        <span class="keyword">return</span> long_name.title()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_odometer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""打印一条指出汽车历程的消息"""</span></span><br><span class="line">        print(<span class="string">"This car has "</span> + str(self.odometer_reading) + <span class="string">" miles on it."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_odometer</span><span class="params">(self, mileage)</span>:</span></span><br><span class="line">        <span class="string">"""将里程表读书设置为指定的值，且禁止读数回调"""</span></span><br><span class="line">        <span class="keyword">if</span> mileage &lt;= <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">"Mileage must be bigger than 0!"</span>)</span><br><span class="line">        <span class="keyword">elif</span> mileage &gt;= self.odometer_reading:</span><br><span class="line">            self.odometer_reading = mileage</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"You can't roll back an odometer!"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increment_odometer</span><span class="params">(self, miles)</span>:</span></span><br><span class="line">        <span class="string">"""将里程表读数增加指定的量，且该量必须为正数"""</span></span><br><span class="line">        <span class="keyword">if</span> miles &gt; <span class="number">0</span>:</span><br><span class="line">            self.odometer_reading += miles</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"Mile must be bigger than 0!"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fill_gas_tank</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""将油箱装满"""</span></span><br><span class="line">        print(<span class="string">"The gas tank has been filled!"</span>)</span><br></pre></td></tr></table></figure> 以下有几点需要注意：</p>
<p>①类中的函数称为方法，比如上述定义的三个函数；类中与<code>self</code>相绑定的变量称为属性，比如<code>make</code>，<code>model</code>，<code>year</code>（不是指那三个<strong>形参</strong>，而是与<code>self</code>绑定的<strong>变量</strong>）。</p>
<p>②每一个类必有一个<code>__init()__</code>方法，这个方法被称为构造方法（在C++中被称为构造函数，不过不用太纠结到底是“方法”还是“函数”，一个东西放在了不同地方有了不同的名字而已）。当然它也有默认的版本，即只有一个<code>self</code>参数，并且该函数什么也不做，这也表明，你甚至都不用定义这个方法，到时候Python会自动生成并调用默认构造方法，不过“不定义构造方法”这种情况估计也就只有像笔者这样初学的时候才能遇到 ^_^。</p>
<p>③Python中<code>self</code>参数是类中每个非静态方法必须要有的形参，且必须放在第一个，它是一个指向实例本身（不是类本身！）的一个引用，让实例能够访问类中的属性和方法，我们在调用类的方法时不用手动传入该参数，它会自动被传入。类中的属性在类中所有的方法里都能被访问，这便是通过<code>self</code>参数实现的。如果站在C++的角度理解，<code>self</code>就相当于C++类里的<code>this</code>指针，指向对象自身。</p>
<p>④类中的每个属性都必须有<strong>初始值</strong>，哪怕这个值是0，空字符串或者<code>None</code>。比如本例中的四个属性，前三个属性的值由用户传入，<code>odometer_reading</code>的值被设为了0。</p>
<p>⑤在上述代码的第一行类名<code>Car</code>后面可带可不带小括号，即<code>class Car:</code>这种写法可行，<code>class Car():</code>这种写法也可以。</p>
<h2 id="使用该car类">2.2 使用该Car类</h2>
<p>以下代码创建了一个Car类的对象，并对该对象进行了简单的操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>:</span></span><br><span class="line">    -- snip --     <span class="comment"># 这不是一个Python语法！这里只是表示省略。</span></span><br><span class="line"></span><br><span class="line">my_new_car = Car(<span class="string">"audi"</span>, <span class="string">"a4"</span>, <span class="number">2016</span>)</span><br><span class="line">print(my_new_car.get_descriptive_name())</span><br><span class="line">my_new_car.read_odometer()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接修改属性</span></span><br><span class="line">my_new_car.odometer_reading = <span class="number">-100</span></span><br><span class="line">my_new_car.read_odometer()</span><br><span class="line">my_new_car.odometer_reading += <span class="number">-1</span></span><br><span class="line">my_new_car.read_odometer()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过方法修改属性</span></span><br><span class="line">my_new_car.update_odometer(<span class="number">-100</span>)</span><br><span class="line">my_new_car.read_odometer()</span><br><span class="line">my_new_car.increment_odometer(<span class="number">-1</span>)</span><br><span class="line">my_new_car.read_odometer()</span><br><span class="line"></span><br><span class="line">my_new_car.update_odometer(<span class="number">100</span>)</span><br><span class="line">my_new_car.read_odometer()</span><br><span class="line">my_new_car.increment_odometer(<span class="number">1</span>)</span><br><span class="line">my_new_car.read_odometer()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line"><span class="number">2016</span> Audi A4</span><br><span class="line">This car has <span class="number">0</span> miles on it.</span><br><span class="line">This car has <span class="number">-100</span> miles on it.</span><br><span class="line">This car has <span class="number">-101</span> miles on it.</span><br><span class="line">Mileage must be bigger than <span class="number">0</span>!</span><br><span class="line">This car has <span class="number">-101</span> miles on it.</span><br><span class="line">Mile must be bigger than <span class="number">0</span>!</span><br><span class="line">This car has <span class="number">-101</span> miles on it.</span><br><span class="line">This car has <span class="number">100</span> miles on it.</span><br><span class="line">This car has <span class="number">101</span> miles on it.</span><br></pre></td></tr></table></figure>
<p>从上述代码可以看出，Python和C++，Java一样，也是使用句点表示法来访问属性以及调用方法。从上述代码及结果可以看出，实例的属性可以直接也可以通过方法进行访问和修改。</p>
<p>直接访问对象的属性可以使操作变得简单，但这违反了封闭性原则，并且直接修改属性也不利于规范对属性的操作。比如代码中将里程设置为一个负值，且在增加里程时增量也是一个负值，这显然不符合常理（虽然有时也可以这么做）。而如果将对属性的操作放入方法中，则可以规范这些操作，如上述的<code>read_odometer()</code>，<code>update_odometer()</code>，<code>increment_odometer()</code>等方法。并且这也是面向对象编程所提倡的做法，尽量不要将属性直接对外暴露。但可惜的是，Python中任何种类的属性都能被直接操作。</p>
<h1 id="继承">3. 继承</h1>
<p>编写类时并非总是从零开始，如果要编写的类是现有类的特殊版本，即有相同或相似的属性和方法，则可以从现有类继承（派生）出新的类。被继承的类称为<strong>“父类”</strong>、<strong>“基类”</strong>或<strong>“超类(superclass)”</strong>，新的类称为<strong>“子类“</strong>或<strong>”派生类“</strong>。</p>
<p>但要注意的是，继承关系应只发生在有较强相互关系的类之间，比如从车类派生出电动车类，没有从车类派生出哈士奇这种骚操作。</p>
<p>以下是从<code>Car</code>类派生出<code>ElectricCar</code>类的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>:</span></span><br><span class="line">    -- snip --</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElectricCar</span><span class="params">(Car)</span>:</span></span><br><span class="line">    <span class="string">"""电动汽车的独特之处"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, make, model, year)</span>:</span></span><br><span class="line">        <span class="string">"""初始化父类的属性，再初始化电动汽车特有的属性"""</span></span><br><span class="line">        super().__init__(make, model, year)</span><br><span class="line">        self.battery_size = <span class="number">70</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">describe_battery</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""打印一条描述电池容量的消息"""</span></span><br><span class="line">        print(<span class="string">"This car has a "</span> + str(self.battery_size) + <span class="string">"-kWh battery."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fill_gas_tank</span><span class="params">(self)</span>:</span>   <span class="comment"># 重写了父类的方法</span></span><br><span class="line">        <span class="string">"""电动车没有油箱"""</span></span><br><span class="line">        print(<span class="string">"This car doesn't need a gas tank!"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_audi = Car(<span class="string">"audi"</span>, <span class="string">"a4"</span>, <span class="number">2018</span>)</span><br><span class="line">print(my_audi.get_descriptive_name())</span><br><span class="line">my_audi.fill_gas_tank()</span><br><span class="line">print()     <span class="comment"># 用作空行</span></span><br><span class="line"></span><br><span class="line">my_tesla = ElectricCar(<span class="string">"tesla"</span>, <span class="string">"model s"</span>, <span class="number">2018</span>)</span><br><span class="line">print(my_tesla.get_descriptive_name())</span><br><span class="line">my_tesla.describe_battery()</span><br><span class="line">my_tesla.fill_gas_tank()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line"><span class="number">2018</span> Audi A4</span><br><span class="line">The gas tank has been filled!</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span> Tesla Model S</span><br><span class="line">This car has a <span class="number">70</span>-kWh battery.</span><br><span class="line">This car doesn<span class="string">'t need a gas tank!</span></span><br></pre></td></tr></table></figure>
<p>从以上代码可以总结出几点：</p>
<p>①创建子类的实例时，Python首先需要对父类进行初始化操作，通过<code>super()</code>函数返回父类的引用，然后再调用父类的构造方法，即<code>super().__init__(参数列表)</code>。在Python2中，对父类的初始化需要以如下方式初始化父类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">super(ElectricCar, self).__init__(make, model, year)</span><br></pre></td></tr></table></figure>
<p>在Python3中也可以按上述方式来初始化父类，但也可以在<strong>单继承</strong>时省略<code>super()</code>函数中的参数。</p>
<p>②子类可以访问父类的所有属性，还可以增加新的属性：<code>my_tesla</code>对象访问了父类的<code>make</code>, <code>model</code>, <code>year</code>等属性，并且还增加了<code>battery_size</code>属性。</p>
<p>③子类可以重写父类的方法：<code>ElectricCar</code>类重写了<code>Car</code>类的<code>fill_gas_tank()</code>方法。</p>
<p>这里需要区分两个概念：<strong>重写(Override)</strong>与<strong>重载(Overload)</strong></p>
<p>重写也叫覆盖，主要是用在继承上。当继承关系上的类中有相同的方法，但子类和父类在该方法中的操作不相同时，子类对该方法进行重新编写，覆盖掉从父类继承下来的方法。在调用时，Python会自动判断该对象是否是派生类来调用该方法相应的实现。正是有了重写，面向对象中<strong>多态(Polymorphism)</strong>这一特性才得以实现。</p>
<p>重载主要用于函数(方法)。在像C/C++，Java这样的语言中，可以有多个同名的函数，但参数列表必须不相同，比如参数个数，参数类型不相同。这些语言则根据参数列表来区分到底调用的是同名函数中的哪一个函数。但<strong>重载并不属于多态性！</strong>这些语言在编译源文件的时候，会根据参数列表来对同名函数生成不同的函数名(具体方法就是添加前缀或后缀)，然后将源代码中的这些同名函数都替换成新函数名，所以重载并不属于多态。但是<strong>Python中并没有函数重载这种说法！</strong>因为Python有关键字参数和可变参数这种神器（当然C++也有变长参数，它用三个点表示，不知道Python可变参数的底层实现是不是就和C++的变长参数有关）。</p>
<p>然而这都不重要！明白重写和重载的概念，会用就行了，至于这俩和多态究竟有没有关系并不重要，至今网上对这俩与多态的关系都没有一个准确的说法。笔者以前看C++的书的时候记得专门把重载的底层实现给提了出来（哪本书忘了），但笔者才疏学浅，暂不清楚重写在编译时是个什么情况，说不定也是靠生成新函数名并替换，如果这样的话，那重载也可以算多态了，<strong>不过这只是笔者的猜测！</strong>感兴趣的小伙伴可自行研究这俩在编译时的情况。</p>
<p>之所以把这俩单独提出来，主要是好多人在考研复试或者找工作面试的时候载到了这个概念上。尤其是考研，考研复试更倾向于重写属于多态，重载不属于多态。</p>
<h2 id="将实例用作属性">3.1 将实例用作属性</h2>
<p>使用代码模拟实物时，随着开发的进展，势必一个类的属性和方法将会越来越多，单单一个类的代码就会越来越长。这时可以考虑是否能将其中一部分代码单独提取出来作为一个新的类。比如前面的<code>ElectricCar</code>类里的电池就可以单独提出来作为一个类。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>:</span></span><br><span class="line">    -- snip --</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Battery</span>:</span></span><br><span class="line">    <span class="string">"""一次模拟电动汽车电池的简单尝试"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, battery_size=<span class="number">70</span>)</span>:</span></span><br><span class="line">        <span class="string">"""初始化电池的属性"""</span></span><br><span class="line">        self.battery_size = battery_size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">describe_battery</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""打印一条描述电池容量的信息"""</span></span><br><span class="line">        print(<span class="string">"This car has a "</span> + str(self.battery_size) + <span class="string">"-kWh battery."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_range</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""输出电池的续航里程"""</span></span><br><span class="line">        <span class="keyword">if</span> self.battery_size == <span class="number">70</span>:</span><br><span class="line">            miles = <span class="number">240</span></span><br><span class="line">        <span class="keyword">elif</span> self.battery_size == <span class="number">85</span>:</span><br><span class="line">            miles = <span class="number">270</span></span><br><span class="line"></span><br><span class="line">        message = <span class="string">"This car can go approximately "</span> + str(miles) + <span class="string">" miles on a full charge."</span></span><br><span class="line">        print(message)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElectricCar</span><span class="params">(Car)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, make, model, year)</span>:</span></span><br><span class="line">        super().__init__(make, model, year)</span><br><span class="line">        self.battery = Battery()</span><br><span class="line"></span><br><span class="line">my_tesla = ElectricCar(<span class="string">"tesla"</span>, <span class="string">"model s"</span>, <span class="number">2018</span>)</span><br><span class="line">print(my_tesla.get_descriptive_name())</span><br><span class="line">my_tesla.battery.describe_battery()</span><br><span class="line">my_tesla.battery.get_range()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line"><span class="number">2018</span> Tesla Model S</span><br><span class="line">This car has a <span class="number">70</span>-kWh battery.</span><br><span class="line">This car can go approximately <span class="number">240</span> miles on a full charge.</span><br></pre></td></tr></table></figure>
<p>模拟复杂的实物时，需要解决一些有趣的问题，比如续航里程是电池的属性还是汽车的属性呢？如果只描述一辆车，那将<code>get_range()</code>方法放入<code>Battery()</code>中并无不妥，但如果要描述整个汽车产品线呢？比如这一款车型能跑多远，那也许将该方法放入<code>ElectricCar</code>类则比较合适。但不管怎样，这里强调的是应该站在一个更高的逻辑层面考虑问题。</p>
<h1 id="从模块导入类">4. 从模块导入类</h1>
<p>与上一篇写关于函数的文章相似，类也可以单独形成模块。可以一个类就是一个模块，也可以多个类（一般是相关联的类）放入一个模块。比如将上述的<code>Car</code>类单独放在一个文件中，除去此类的代码，其他代码均删除，最后将该文件命名为<code>car.py</code>（注意这里的文件名是小写的）。然后再在程序中带入该类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> car <span class="keyword">import</span> Car</span><br><span class="line"><span class="comment"># 如果命名有冲突，也可以给Car类起个别名</span></span><br><span class="line"><span class="comment"># from car import Car as C</span></span><br><span class="line"></span><br><span class="line">my_new_car = Car(<span class="string">"audi"</span>, <span class="string">"a4"</span>, <span class="number">2018</span>)</span><br><span class="line">print(my_new_car.get_descriptive_name())</span><br><span class="line"></span><br><span class="line">my_new_car.odometer_reading = <span class="number">23</span></span><br><span class="line">my_new_car.read_odometer()</span><br></pre></td></tr></table></figure>
<p>也可以将多个相关联的类放入同一个文件中，形成一个模块，比如上面的<code>Car</code>类，<code>ElectricCar</code>类和<code>Battery</code>类，将该文件命名为<code>cars.py</code>，最后导入该文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> cars <span class="keyword">import</span> Car, ElectricCar</span><br><span class="line"></span><br><span class="line">my_beetle = Car(<span class="string">"volkswagen"</span>, <span class="string">"beetle"</span>, <span class="number">2018</span>)</span><br><span class="line">my_tesla = ElectricCar(<span class="string">"tesla"</span>, <span class="string">"model s"</span>, <span class="number">2018</span>)</span><br><span class="line">-- snip --     <span class="comment"># 后面的代码和之前的类似，不在赘述</span></span><br></pre></td></tr></table></figure>
<p>也可以将整个模块导入，并使用句点表示法使用模块中的类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cars</span><br><span class="line"></span><br><span class="line">my_car = car.Car(<span class="string">"volkswagen"</span>, <span class="string">"beetle"</span>, <span class="number">2018</span>)</span><br><span class="line">my_tesla = car.ElectricCar(<span class="string">"tesla"</span>, <span class="string">"model s"</span>, <span class="number">2018</span>)</span><br></pre></td></tr></table></figure>
<p>还可以导入模块中的所有类（不推荐此法，容易产生命名冲突！），此时便不需要使用句点表示法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> cars <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">my_beetle = Car(<span class="string">"volkswagen"</span>, <span class="string">"beetle"</span>, <span class="number">2018</span>)</span><br></pre></td></tr></table></figure>
<p>还可以在模块中导入另一个模块，比如，将<code>Car</code>类单独放在一个文件中形参一个模块，命名为<code>car.py</code>，再新建一个模块<code>electric_car.py</code>用于存放<code>Battery</code>类和<code>ElectricCar</code>类，并在该模块中带入<code>Car</code>类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> car <span class="keyword">import</span> Car</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Battery</span>:</span></span><br><span class="line">    -- snip --</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElectricCar</span><span class="params">(Car)</span>:</span></span><br><span class="line">    -- snip --</span><br></pre></td></tr></table></figure>
<p>最后在执行文件的源代码中根据需要导入类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这是书中导入两个类的代码</span></span><br><span class="line"><span class="keyword">from</span> car <span class="keyword">import</span> Car</span><br><span class="line"><span class="keyword">from</span> electric_car <span class="keyword">import</span> ElectricCar     </span><br><span class="line"></span><br><span class="line">my_car = Car(<span class="string">"audi"</span>, <span class="string">"a4"</span>, <span class="number">2018</span>)</span><br><span class="line">my_tesla = ElectricCar(<span class="string">"tesla"</span>, <span class="string">"model s"</span>, <span class="number">2018</span>)</span><br></pre></td></tr></table></figure>
<p>之前读到这的时候觉得能不能像以下这样的方式导入<code>Car</code>类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> electric_car <span class="keyword">import</span> Car, ElectricCar</span><br><span class="line"></span><br><span class="line">my_car = Car(<span class="string">"audi"</span>, <span class="string">"a4"</span>, <span class="number">2018</span>)</span><br><span class="line">my_tesla = ElectricCar(<span class="string">"tesla"</span>, <span class="string">"model s"</span>, <span class="number">2018</span>)</span><br></pre></td></tr></table></figure>
<p>后来亲测，这样做也是可以的。那问题就来了，像书中那样的导入方式是不是发生了代码的覆盖呢？哪种导入的效率更高呢？笔者在这里还有点懵，后续再更新吧。</p>
<p>模块导入的方法还有很多，甚至能直接从GitHub导入模块，上述的导入方式只是皮毛。最后用一个从标准库导入<code>OrderedDict</code>类的示例结束本文。之前版本的Python中普通字典类是不确保键值对之前的顺序的，想要确保顺序就得使用<code>OrderedDict</code>类。但现在从3.6版本起，Python也确保了普通字典里键值对也是有序的了，但是为了兼容性考虑（有可能你的代码还要运行在3.6之前的版本），目前还是建议使用<code>OrderedDict</code>类。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line">favorite_languages = OrderedDict()</span><br><span class="line"></span><br><span class="line">favorite_languages[<span class="string">"jen"</span>] = <span class="string">"python"</span></span><br><span class="line">favorite_languages[<span class="string">"sarah"</span>] = <span class="string">"c"</span></span><br><span class="line">favorite_languages[<span class="string">"edward"</span>] = <span class="string">"ruby"</span></span><br><span class="line">favorite_languages[<span class="string">"phil"</span>] = <span class="string">"python"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, language <span class="keyword">in</span> favorite_languages.items():</span><br><span class="line">    print(name.title() + <span class="string">"'s favorite_language is "</span> + language.title())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">Jen<span class="string">'s favorite_language is Python</span></span><br><span class="line"><span class="string">Sarah'</span>s favorite_language <span class="keyword">is</span> C</span><br><span class="line">Edward<span class="string">'s favorite_language is Ruby</span></span><br><span class="line"><span class="string">Phil'</span>s favorite_language <span class="keyword">is</span> Python</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路7-函数</title>
    <url>/2018/04/10/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF7-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<blockquote>
<p>《Python编程：从入门到实践》笔记。 本章主要介绍Python中函数的操作，包括函数的概念，定义，如何传参等，最后还有小部分模块的概念。</p>
</blockquote>
<a id="more"></a>
<h1 id="定义函数">1. 定义函数</h1>
<h2 id="一般函数">1.1 一般函数</h2>
<p>函数是带名字的代码块，该代码块是完成特定工作的固定代码序列。如果程序中多次出现相同或相似的代码块，则应将这段代码提取出来，编写成函数，然后多次调用。通过编写函数可以避免重复工作，使程序的编写、阅读、测试和修复更容易。<strong>请使用描述性的函数名来命名函数，以大致表明函数的功能，这样即使没有注释也能容易理解。函数名应尽量只有小写字母和下划线。</strong>以下是两个最基本的函数，有参数与无参函数： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义无参函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet_user1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""显示简单的问候语"""</span></span><br><span class="line">    print(<span class="string">"Hello!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义有参函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet_user2</span><span class="params">(username)</span>:</span></span><br><span class="line">    <span class="string">"""显示简单的问候语"""</span></span><br><span class="line">    print(<span class="string">"Hello, "</span> + username.title() + <span class="string">"!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">greet_user1()</span><br><span class="line">greet_user2(<span class="string">"jesse"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">Hello!</span><br><span class="line">Hello, Jesse!</span><br></pre></td></tr></table></figure> 在调用函数前，必须先定义函数！即函数的定义部分必须在调用语句之前。 上述代码中的三引号字符串叫做<strong>文档字符串</strong>，他们既可以被用作代码注释，也可用于自动生成有关程序中函数的文档。</p>
<p><strong>实参和形参</strong> 这两个概念经常被搞混，函数定义中的参数叫做形参，比如上述函数<code>greet_user2(username)</code>中的<code>username</code>就是形参；传递给函数的参数叫做实参，比如在调用<code>greet_user2("jesse")</code>时的<code>"jesse"</code>就是实参。 ## 1.2 空函数 如果想定义一个什么都不做的函数，可以使用<code>pass</code>语句： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_nothing</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure> 如果为了让程序能跑起来，但暂时又不写这个函数，可以使用<code>pass</code>语句。这里<code>pass</code>用作占位符。 # 2. 传递参数 ## 2.1 位置参数（必选参数） 这就是要求实参的顺序和形参的顺序相同。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">describe_pet</span><span class="params">(animal_type, pet_name)</span>:</span></span><br><span class="line">    <span class="string">"""显示宠物的信息"""</span></span><br><span class="line">    print(<span class="string">"\nI have a "</span> + animal_type + <span class="string">"."</span>)</span><br><span class="line">    print(<span class="string">"My "</span> + animal_type + <span class="string">"'s name is "</span> + pet_name.title() + <span class="string">"."</span>)</span><br><span class="line"></span><br><span class="line">describe_pet(<span class="string">"hamster"</span>, <span class="string">"harry"</span>)</span><br><span class="line">describe_pet(<span class="string">"dog"</span>, <span class="string">"willie"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">I have a hamster.</span><br><span class="line">My hamste<span class="string">r's name is Harry.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">I have a dog.</span></span><br><span class="line"><span class="string">My dog'</span>s name <span class="keyword">is</span> Willie.</span><br></pre></td></tr></table></figure> 对于位置参数，应该注意实参的传递顺序，如果顺序不对，结果会出乎意料：有可能报错，如果不报错，函数所要表达的意思可能改变。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">describe_pet(<span class="string">"willie"</span>, <span class="string">"dog"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">I have a willie.           <span class="comment"># 尴尬</span></span><br><span class="line">My willie<span class="string">'s name is Dog.</span></span><br></pre></td></tr></table></figure> ## 2.2 关键字参数（传实参时） 如果函数的形参过多，则很难记住每个位置的参数是用来干什么的，如果用<strong>键值对的方式传递实参</strong>，这个问题就能迎刃而解，这就是关键字参数。在传递参数时，直接将形参与实参关联，这样就不用在意实参的位置，依然以上述代码为例，函数定义不变： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">describe_pet(animal_type=<span class="string">"hamster"</span>, pet_name=<span class="string">"harry"</span>)</span><br><span class="line">describe_pet(pet_name=<span class="string">"harry"</span>, animal_type=<span class="string">"hamster"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">I have a hamster.</span><br><span class="line">My hamste<span class="string">r's name is Harry.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">I have a hamster.</span></span><br><span class="line"><span class="string">My hamster'</span>s name <span class="keyword">is</span> Harry.</span><br></pre></td></tr></table></figure> 请注意，这是一种<strong>传递参数</strong>的方法！在<strong>调用函数</strong>时使用！ ## 2.3 默认参数（定义函数时，形参） 编写函数时可以为每个形参指定默认值，给形参指定了默认值之后，在调用函数时可以省略相应的实参。使用默认值可以简化函数调用，也可清楚地指出函数的典型用法。比如上述<code>describe_pet()</code>函数如果给形参<code>animal_type</code>指定默认值<code>“dog”</code>，则可以看出这个函数主要是用来描述狗这种宠物的。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">describe_pet</span><span class="params">(pet_name, animal_type=<span class="string">"dog"</span>)</span>:</span></span><br><span class="line">    <span class="string">"""显示宠物的信息"""</span></span><br><span class="line">    print(<span class="string">"\nI have a "</span> + animal_type + <span class="string">"."</span>)</span><br><span class="line">    print(<span class="string">"My "</span> + animal_type + <span class="string">"'s name is "</span> + pet_name.title() + <span class="string">"."</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">describe_pet(pet_name=<span class="string">"willie"</span>)</span><br><span class="line">describe_pet(<span class="string">"happy"</span>)</span><br><span class="line">describe_pet(<span class="string">"lili"</span>, <span class="string">"cat"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">I have a dog.</span><br><span class="line">My dog<span class="string">'s name is Willie.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">I have a dog.</span></span><br><span class="line"><span class="string">My dog'</span>s name <span class="keyword">is</span> Happy.</span><br><span class="line"></span><br><span class="line">I have a cat.</span><br><span class="line">My cat<span class="string">'s name is Lili.</span></span><br></pre></td></tr></table></figure> 在函数调用时，如果给形参提供了实参，Python将使用指定的实参；否则将使用形参的默认值。 <strong>注意</strong>：默认参数是在<strong>函数定义</strong>时使用！在定义函数时带有默认值的形参必须在没有默认值的形参后面！</p>
<p>还有一点值得注意：<strong>默认参数必须指向不变对象！</strong>请看以下代码： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_end</span><span class="params">(temp=[])</span>:</span></span><br><span class="line">	<span class="string">"""在传入的列表最后添加“end”"""</span></span><br><span class="line">    temp.append(<span class="string">"end"</span>)</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(add_end([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line">print(add_end([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]))</span><br><span class="line">print(add_end())</span><br><span class="line">print(add_end())</span><br><span class="line">print(add_end())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'end'</span>]</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'end'</span>]</span><br><span class="line">[<span class="string">'end'</span>]</span><br><span class="line">[<span class="string">'end'</span>, <span class="string">'end'</span>]</span><br><span class="line">[<span class="string">'end'</span>, <span class="string">'end'</span>, <span class="string">'end'</span>]</span><br></pre></td></tr></table></figure> 当给这个函数传递了参数时，结果是正确的，而且，在没有传递参数且第一次调用时，返回结果也是正确的，然而，没有传递参数且第二次、第三次调用时，结果则成了问题。这是因为，Python在函数定义的时候，默认参数的值就被计算了出来，形参只要不指向新的值，它就会一直指向这个默认值，但如果这个默认值是个可变对象，就会出现上述情况。 要修正上述例子，可以使用<code>None</code>，<code>str</code>之类的不变对象。如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_end</span><span class="params">(temp=None)</span>:</span></span><br><span class="line">    <span class="string">"""在传入的列表最后添加“end”"""</span></span><br><span class="line">    <span class="keyword">if</span> temp <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        temp = []</span><br><span class="line">    temp.append(<span class="string">"end"</span>)</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line"></span><br><span class="line">print(add_end())</span><br><span class="line">print(add_end())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">[<span class="string">'end'</span>]</span><br><span class="line">[<span class="string">'end'</span>]</span><br></pre></td></tr></table></figure> <strong>补充--设计不变对象的原因</strong>： ①对象一旦创建则不可修改，可以减少因修改数据而产生的错误； ②由于对象不可修改，在多任务环境下不需要加锁，同时读不会出错。所以，我们在设计一个对象时，能设计成不变对象则设计成不变对象。 # 3. 返回值 ## 3.1 返回简单值 函数并非总是直接显示输出，它可以处理一些数据并返回一个或一组值。在Python的函数中，使用<code>return</code>语句来返回值。以下是一个参数可选的带有返回值的函数例子： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_formatted_name</span><span class="params">(first_name, last_name, middel_name=<span class="string">""</span>)</span>:</span></span><br><span class="line">    <span class="string">"""返回标准格式的姓名"""</span></span><br><span class="line">    <span class="keyword">if</span> middel_name:</span><br><span class="line">        full_name = first_name + <span class="string">" "</span> + middel_name + <span class="string">" "</span> + last_name</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        full_name = first_name + <span class="string">" "</span> + last_name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> full_name.title()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">musician = get_formatted_name(<span class="string">"jimi"</span>, <span class="string">"hendrix"</span>)</span><br><span class="line">print(musician)</span><br><span class="line"></span><br><span class="line">musician = get_formatted_name(<span class="string">"john"</span>, <span class="string">"hooker"</span>, <span class="string">"lee"</span>)</span><br><span class="line">print(musician)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">Jimi Hendrix</span><br><span class="line">John Lee Hooker</span><br></pre></td></tr></table></figure> ## 3.2 返回字典 Python函数可以返回任何类型的值，包括列表和字典等复杂的数据结构。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_person</span><span class="params">(first_name, las_name, age=<span class="string">""</span>)</span>:</span></span><br><span class="line">    <span class="string">"""返回一个字典，其中包含一个人的信息"""</span></span><br><span class="line">    person = &#123;<span class="string">"first"</span>: first_name, <span class="string">"last"</span>: las_name&#125;</span><br><span class="line">    <span class="keyword">if</span> age:</span><br><span class="line">        person[<span class="string">"age"</span>] = age</span><br><span class="line">    <span class="keyword">return</span> person</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">musician = build_person(<span class="string">"jimi"</span>, <span class="string">"hendrix"</span>, age=<span class="number">27</span>)</span><br><span class="line">print(musician)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">&#123;<span class="string">'first'</span>: <span class="string">'jimi'</span>, <span class="string">'last'</span>: <span class="string">'hendrix'</span>, <span class="string">'age'</span>: <span class="number">27</span>&#125;</span><br></pre></td></tr></table></figure> ## 3.3 返回多个值 <code>return</code>语句后面用逗号分隔多个值，则可返回多个值： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">return_mult</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"></span><br><span class="line">a, b = return_mult()</span><br><span class="line">print(<span class="string">"a = "</span> + str(a) + <span class="string">"\nb = "</span> + str(b))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br></pre></td></tr></table></figure> 但其实这是个假象，其实函数返回的是一个元组（Tuple），只是最后对元组进行了解包，然后对<code>a</code>，<code>b</code>进行了平行赋值。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">print(return_mult())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure> 如果函数返回多个值，但有些值并不想要，则这些位置的值可以用下划线<code>_</code>进行接收： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">return_mult</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">    </span><br><span class="line">a, _, _ = return_mult()</span><br></pre></td></tr></table></figure></p>
<h1 id="传递列表">4. 传递列表</h1>
<p>将列表传递给函数，函数可以直接访问其内容或对其进行修改。用函数处理列表可以提高效率。 以下代码是一个打印程序，将未打印的设计在打印后转移到另一个列表中，此代码中未使用函数： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码:</span></span><br><span class="line"><span class="comment"># 未打印列表</span></span><br><span class="line">unprinted_designs = [<span class="string">"iphone case"</span>, <span class="string">"robot pendant"</span>, <span class="string">"dodecahedron"</span>]</span><br><span class="line">completed_models = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟打印过程，知道没有未打印的设计为止，并将已打印的设计移动到“完成列表”</span></span><br><span class="line"><span class="keyword">while</span> unprinted_designs:</span><br><span class="line">    current_design = unprinted_designs.pop()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 模拟打印过程</span></span><br><span class="line">    print(<span class="string">"Printing model: "</span> + current_design)</span><br><span class="line">    completed_models.append(current_design)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"\nThe following models have been printed:"</span>)</span><br><span class="line"><span class="keyword">for</span> completed_model <span class="keyword">in</span> completed_models:</span><br><span class="line">    print(completed_model)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">Printing model: dodecahedron</span><br><span class="line">Printing model: robot pendant</span><br><span class="line">Printing model: iphone case</span><br><span class="line"></span><br><span class="line">The following models have been printed:</span><br><span class="line">dodecahedron</span><br><span class="line">robot pendant</span><br><span class="line">iphone case</span><br></pre></td></tr></table></figure> 现在用两个函数来重组这些代码： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 两个函数：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_models</span><span class="params">(unprinted_designs, completed_models)</span>:</span></span><br><span class="line">    <span class="string">"""模拟打印过程，知道没有未打印的设计为止，并将已打印的设计移动到“完成列表”"""</span></span><br><span class="line">    <span class="keyword">while</span> unprinted_designs:</span><br><span class="line">        current_design = unprinted_designs.pop()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 模拟打印过程</span></span><br><span class="line">        print(<span class="string">"Printing model: "</span> + current_design)</span><br><span class="line">        completed_models.append(current_design)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_completed_models</span><span class="params">(completed_models)</span>:</span></span><br><span class="line">    print(<span class="string">"\nThe following models have been printed:"</span>)</span><br><span class="line">    <span class="keyword">for</span> completed_model <span class="keyword">in</span> completed_models:</span><br><span class="line">        print(completed_model)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主程序代码：</span></span><br><span class="line">unprinted_designs = [<span class="string">"iphone case"</span>, <span class="string">"robot pendant"</span>, <span class="string">"dodecahedron"</span>]</span><br><span class="line">completed_models = []</span><br><span class="line"></span><br><span class="line">print_models(unprinted_designs, completed_models)</span><br><span class="line">show_completed_models(completed_models)</span><br></pre></td></tr></table></figure> 从以上代码可以看出，使用了函数后，主程序变为了短短四行。 相比于没有使用函数的代码，使用了函数后代码更易读也更容易维护。 在编写函数时，尽量每个函数只负责一项功能，如果一个函数负责的功能太多，应将其分成多个函数。同时，函数里面还能调用另一个函数；函数里也能再定义函数！</p>
<p><strong>禁止函数修改列表</strong>： 有时候需要禁止函数修改列表，以上述代码为例，<code>print_models()</code>函数在执行完成后清空了未打印列表<code>unprinted_design</code>，但有时我们并不希望这个列表被清空，而是留作备案。为解决此问题，可以向函数传递副本而不是原件，如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不用改变函数定义，在函数调用时使用切片操作：</span></span><br><span class="line">print_models(unprinted_designs[:], completed_models)</span><br></pre></td></tr></table></figure> 如果从C/C++的角度来看（没有研究过Python底层代码，这里仅是猜测），实参<code>unprinted_designs</code>是一个指针，当他传递给函数时，形参得到了这个变量的一个拷贝，形参也指向了内存中的那片区域，所以能直接修改。而当使用切片传递拷贝时，Python先在内存中复制一遍实参<code>unprinted_designs</code>指向的数据，并给这片数据的地址赋给一个临时的变量，然后再将这个临时变量传递给形参。 # 5. 传递任意数量的参数 ## 5.1 结合使用位置参数（必选参数）和任意数量参数（*args） 有时候你并不知道要向函数传递多少个参数，比如制作披萨，你不知道顾客要多少种配料，此时使用带一个星号<code>*</code>的形参，来定义函数： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_pizza</span><span class="params">(*toppings)</span>:</span></span><br><span class="line">    <span class="string">"""打印顾客点的所有配料"""</span></span><br><span class="line">    print(toppings)</span><br><span class="line">    </span><br><span class="line">make_pizza()    <span class="comment"># 不传参数</span></span><br><span class="line">make_pizza(<span class="string">"pepperoni"</span>)</span><br><span class="line">make_pizza(<span class="string">"mushrooms"</span>, <span class="string">"green peppers"</span>, <span class="string">"extra cheese"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">()</span><br><span class="line">(<span class="string">'pepperoni'</span>,)</span><br><span class="line">(<span class="string">'mushrooms'</span>, <span class="string">'green peppers'</span>, <span class="string">'extra cheese'</span>)</span><br></pre></td></tr></table></figure> 从结果可以看出，以可变参数的方式传入值时，Python将值封装成了一个元组，即使是只传入了一个值。</p>
<p><strong>补充</strong>：多个参数都在一个列表里面，如果一个元素一个元素的传递，则代码会很难看，可以使用如下方式传递参数，任以上述<code>make_pizza()</code>函数为例： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">toppings = [<span class="string">"mushrooms"</span>, <span class="string">"green peppers"</span>, <span class="string">"extra cheese"</span>]</span><br><span class="line">make_pizza(*toppings)    <span class="comment"># 这里是在执行函数，而不是在定义函数！</span></span><br></pre></td></tr></table></figure> 在后面的“任意关键字参数”小节中，也可用这种方式传值，只不过得用双星号<code>**</code>。</p>
<p><strong>注意</strong>：如果要让函数接收不同类型的参数，必须将可变参数放在最后，因为Python先匹配位置参数和关键字参数，再将剩余的参数封装到最后一个可变参数中。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_pizza</span><span class="params">(size, *toppings)</span>:</span></span><br><span class="line">    <span class="string">"""概述要制作的披萨"""</span></span><br><span class="line">    print(<span class="string">"\nMaking a "</span> + str(size) + <span class="string">"-inch pizza with the following toppings:"</span>)</span><br><span class="line">    <span class="keyword">for</span> topping <span class="keyword">in</span> toppings:</span><br><span class="line">        print(<span class="string">"- "</span> + topping)</span><br><span class="line"></span><br><span class="line">make_pizza(<span class="number">16</span>, <span class="string">"pepperoni"</span>)</span><br><span class="line">make_pizza(<span class="number">12</span>, <span class="string">"mushrooms"</span>, <span class="string">"green peppers"</span>, <span class="string">"extra cheese"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">Making a <span class="number">16</span>-inch pizza <span class="keyword">with</span> the following toppings:</span><br><span class="line">- pepperoni</span><br><span class="line"></span><br><span class="line">Making a <span class="number">12</span>-inch pizza <span class="keyword">with</span> the following toppings:</span><br><span class="line">- mushrooms</span><br><span class="line">- green peppers</span><br><span class="line">- extra cheese</span><br></pre></td></tr></table></figure> ## 5.2 使用任意数量的关键字参数（**kw） 有时候需要传入任意数量的参数，并且还要知道这些参数是用来干什么的，此时函数需要能够接受任意数量的关键字参数，这里使用双星号<code>**</code>来实现： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_profile</span><span class="params">(first, last, **user_info)</span>:</span></span><br><span class="line">    print(user_info)</span><br><span class="line"></span><br><span class="line">    <span class="string">"""创建一个字典，其中包含我们知道的有关用户的一切"""</span></span><br><span class="line">    profile = &#123;&#125;</span><br><span class="line">    profile[<span class="string">"first_name"</span>] = first</span><br><span class="line">    profile[<span class="string">"last_name"</span>] = last</span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> user_info.items():</span><br><span class="line">        profile[key] = value</span><br><span class="line">    <span class="keyword">return</span> profile</span><br><span class="line"></span><br><span class="line">user_profile = build_profile(<span class="string">"albert"</span>, <span class="string">"einstein"</span>, location=<span class="string">"princeton"</span>, field=<span class="string">"physics"</span>)</span><br><span class="line">print(user_profile)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">&#123;<span class="string">'location'</span>: <span class="string">'princeton'</span>, <span class="string">'field'</span>: <span class="string">'physics'</span>&#125;</span><br><span class="line">&#123;<span class="string">'first_name'</span>: <span class="string">'albert'</span>, <span class="string">'last_name'</span>: <span class="string">'einstein'</span>, <span class="string">'location'</span>: <span class="string">'princeton'</span>, <span class="string">'field'</span>: physics<span class="string">'&#125;</span></span><br></pre></td></tr></table></figure> 从上述结果可以看出，Python将任意关键字参数封装成一个字典。这里也要注意，指示任意关键字参数的形参必须放到最后！</p>
<p><strong>区分---命名关键字参数（也叫命名参数）</strong>： 上述代码可以传递任意数量的关键字参数，但有时需要限制传入的关键字参数，比如上述<code>build_profile()</code>函数除了传入<code>first</code>和<code>last</code>这两个必选参数之外，还必须且只能传入<code>age</code>和<code>country</code>这两个参数（一个不多，一个不少）时，则需要用到命名关键字参数，它使用一个星号分隔必选参数和命名关键字参数，如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line"><span class="comment"># 星号后面的为命名关键字参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_profile</span><span class="params">(first, last, *, age, country=<span class="string">"China"</span>)</span>:</span></span><br><span class="line">    <span class="string">"""创建一个字典，其中包含我们知道的有关用户的一切"""</span></span><br><span class="line">    profile = &#123;&#125;</span><br><span class="line">    profile[<span class="string">"first_name"</span>] = first</span><br><span class="line">    profile[<span class="string">"last_name"</span>] = last</span><br><span class="line">    profile[<span class="string">"age"</span>] = age</span><br><span class="line">    profile[<span class="string">"country"</span>] = country</span><br><span class="line">    <span class="keyword">return</span> profile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(build_profile(<span class="string">"albert"</span>, <span class="string">"einstein"</span>, country=<span class="string">"USA"</span>, age=<span class="number">20</span>))</span><br><span class="line">print(build_profile(<span class="string">"albert"</span>, <span class="string">"einstein"</span>, age=<span class="number">20</span>))</span><br><span class="line">print(build_profile(age=<span class="number">20</span>, country=<span class="string">"USA"</span>, first=<span class="string">"albert"</span>, last=<span class="string">"einstein"</span>))</span><br><span class="line"><span class="comment"># print(build_profile("albert", "einstein"))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line"><span class="comment"># 如果不看最后一个print()，则代码的执行结果如下：</span></span><br><span class="line">&#123;<span class="string">'first_name'</span>: <span class="string">'albert'</span>, <span class="string">'last_name'</span>: <span class="string">'einstein'</span>, <span class="string">'age'</span>: <span class="number">20</span>, <span class="string">'country'</span>: <span class="string">'USA'</span>&#125;</span><br><span class="line">&#123;<span class="string">'first_name'</span>: <span class="string">'albert'</span>, <span class="string">'last_name'</span>: <span class="string">'einstein'</span>, <span class="string">'age'</span>: <span class="number">20</span>, <span class="string">'country'</span>: <span class="string">'China'</span>&#125;</span><br><span class="line">&#123;<span class="string">'first_name'</span>: <span class="string">'albert'</span>, <span class="string">'last_name'</span>: <span class="string">'einstein'</span>, <span class="string">'age'</span>: <span class="number">20</span>, <span class="string">'country'</span>: <span class="string">'USA'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果将最后一个print()的注释去掉，则代码会报错</span></span><br></pre></td></tr></table></figure> 从以上结果可以看出命名关键字参数必须每个都赋值，可以有默认值，有默认值的可以不用再赋值；命名关键字之间可以交换顺序，如果要和前面的必选参数也交换顺序，则必须使用关键字参数的方式传递实参。</p>
<p><strong>为什么有命名关键字参数</strong>： （网上搜的答案，个人暂时认为这种参数可以被位置参数给替换掉）命名参数配合默认参数使用可以简化代码，比如在写类的构造函数时，有10个参数，8个有合理的默认值，那么可以将这8个定义为命名关键字参数，前两个就是必须赋值的位置参数。这样，在后面生成对象时，如果要替换默认值： ①要么按顺序给后面8个参数替换默认值（C++做法）； ②要么用关键字参数的传值方式给这8个关键字不一定按顺序来赋值（Python做法）； ③要么混合①②的做法，不过容易混淆。（也就是全用必选参数，前面一部分按顺序赋值，后面一部分用关键字参数赋值）</p>
<p><strong>一点感想</strong>：但如果是笔者自己写代码，暂时更偏向于全用必选参数，带默认值，即如下定义形式： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a, b, c=<span class="string">"test1"</span>, d=<span class="string">"test2"</span>, e=<span class="string">"test3"</span>, f=<span class="string">"test4"</span>, g=<span class="string">"test5"</span>)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure> 而不是如下形式： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a, b, *, c=<span class="string">"test1"</span>, d=<span class="string">"test2"</span>, e=<span class="string">"test3"</span>, f=<span class="string">"test4"</span>, g=<span class="string">"test5"</span>)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure> 可能笔者才疏学浅，暂时还没领会到这种方式的精髓之处。 不过上述是没有可变参数的情况，如果是以如下形式定义函数： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a, b=<span class="string">"test"</span>, c=<span class="string">"test2"</span>, *args)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure> 在以如下形式调用时则会报错： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">func(<span class="string">"test1"</span>, c=<span class="string">"test3"</span>, b=<span class="string">"test2"</span>, <span class="string">"test4"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">SyntaxError: positional argument follows keyword argument</span><br></pre></td></tr></table></figure> 可以看出，Python在这里将<code>test4</code>解释为了位置参数，但笔者是想将其作为可变参数。所以笔者推测，在以下情况时，使用命名关键字参数比较好： 必选参数数量不少（其中有些参数的默认值不常变动），后面又跟有可变参数，由于必选参数很多，不容易记住位置，如果不用命名参数，按照上述关键字方式调用函数则会出错，所以此时将这些有合理默认值的必选参数变为命名关键字参数，则可以使用关键字参数不按顺序传值。但如果没有可变参数时，笔者还是倾向于使用带默认值的必选参数。</p>
<p><strong>还有一点值得注意</strong>：命名关键字参数可以和可变参数（*args）混用，此时语法如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a, b, *agrs, c, d)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure> 这里<code>c</code>，<code>d</code>为命名关键字参数，并且前面也不用加单个星号进行区分了，但是，如果和可变数量关键字参数（**kw）进行混用，命名关键字不能在可变数量关键字参数之前，即<strong>不存在</strong>如下函数定义形式： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a, b, **kw, c, d)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure> 如果这样定义，Pycharm会标红（其他IDE没用过，不知道提不提示）。</p>
<p><strong>综上所述</strong>：Python中一共有五中参数类型，即必选参数（位置参数），默认参数（带默认值的参数），可变参数（*args），命名关键字参数和关键字参数（数量可变，<strong>kw），这五种可以同时混用，但是必须遵照如下顺序： （从左到右）</strong>必选参数、默认参数、可变参数、命名关键字参数和关键字参数<strong>。以下是这两个参数混用的几个例子： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(a, b, *, c, d, **kw)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    a, b 为必选参数</span></span><br><span class="line"><span class="string">    c, d 为命名关键字参数</span></span><br><span class="line"><span class="string">    kw 为关键字参数，可包含多对</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(a, b=<span class="string">"test"</span>, *args, c, d=<span class="string">"test2"</span>, **kw)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :param a: 必选参数</span></span><br><span class="line"><span class="string">    :param b: 带默认值的必选参数</span></span><br><span class="line"><span class="string">    :param args: 可变参数</span></span><br><span class="line"><span class="string">    :param c: 命名关键字参数</span></span><br><span class="line"><span class="string">    :param d: 带默认值的命名关键字参数</span></span><br><span class="line"><span class="string">    :param kw: 关键字参数，可包含多对 </span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure> </strong>常用的包含任意数量关键字，且不区分参数类型的函数定义方式如下<strong>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure> # 6. 将函数存储在模块(Module)中 在python中，一个<code>.py</code>文件就是一个模块。使用模块的最大好处就是提高了代码的可维护性。其次，代码不用从零开始编写，一个模块编写完成后，可以在其他地方被调用。再次，可以避免函数名和变量名冲突，不同模块可以有相同的函数名和变量名。 ## 6.1 导入整个模块 要让函数是可以导入的，得先创建模块。以上述<code>make_pizza()</code>函数为例，将其余代码删掉，只保留这一个函数，然后再在当前目录中创建一个<code>making_pizzas.py</code>的文件，执行如下代码以导入整个模块： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># making_pizzas.py文件：</span></span><br><span class="line"><span class="keyword">import</span> pizza</span><br><span class="line"></span><br><span class="line">pizza.make_pizza(<span class="number">12</span>, <span class="string">"mushromms"</span>, <span class="string">"green peppers"</span>, <span class="string">"extra cheese"</span>)</span><br><span class="line">pizza.make_pizza(<span class="number">16</span>, <span class="string">"pepperoni"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">Making a <span class="number">12</span>-inch pizza <span class="keyword">with</span> the following toppings:</span><br><span class="line">- mushromms</span><br><span class="line">- green peppers</span><br><span class="line">- extra cheese</span><br><span class="line"></span><br><span class="line">Making a <span class="number">16</span>-inch pizza <span class="keyword">with</span> the following toppings:</span><br><span class="line">- pepperoni</span><br></pre></td></tr></table></figure> 以这种方式导入模块时，按如下方式调用函数： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">module_name.function_name()</span><br></pre></td></tr></table></figure> ## 6.2 导入某模块中特定的函数 语法结构为： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入一个函数</span></span><br><span class="line"><span class="keyword">from</span> module_name <span class="keyword">import</span> function_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入多个函数，逗号分隔</span></span><br><span class="line"><span class="keyword">from</span> module_name <span class="keyword">import</span> func1, func2, func3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以此方式导入模块式，直接以函数名调用函数，前面不用加模块名</span></span><br></pre></td></tr></table></figure> 仍以上述<code>pizza.py</code>为例： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pizza <span class="keyword">import</span> make_pizza</span><br><span class="line"></span><br><span class="line">make_pizza(<span class="number">12</span>, <span class="string">"mushromms"</span>, <span class="string">"green peppers"</span>, <span class="string">"extra cheese"</span>)</span><br><span class="line">make_pizza(<span class="number">16</span>, <span class="string">"pepperoni"</span>)</span><br></pre></td></tr></table></figure> ## 6.3 模块补充 </strong>别名**： 当函数名发生冲突，或者函数名、模块名太长时，可以取一个简短的名称，类似“外号”，以上述代码为例： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 函数取别名</span></span><br><span class="line"><span class="keyword">from</span> pizza <span class="keyword">import</span> make_pizza <span class="keyword">as</span> mp</span><br><span class="line"></span><br><span class="line">mp(<span class="number">12</span>, <span class="string">"mushromms"</span>, <span class="string">"green peppers"</span>, <span class="string">"extra cheese"</span>)</span><br><span class="line">mp(<span class="number">16</span>, <span class="string">"pepperoni"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------- 另一个文件 ------------------------------</span></span><br><span class="line"><span class="comment"># 模块取别名</span></span><br><span class="line"><span class="keyword">import</span> pizza <span class="keyword">as</span> p</span><br><span class="line">p.make_pizza(<span class="number">12</span>, <span class="string">"mushromms"</span>, <span class="string">"green peppers"</span>, <span class="string">"extra cheese"</span>)</span><br><span class="line">p.make_pizza(<span class="number">16</span>, <span class="string">"pepperoni"</span>)</span><br></pre></td></tr></table></figure></p>
<p><strong>导入模块中的所有函数</strong>： 例如导入<code>pizza</code>模块中的所有函数： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pizza <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">make_pizza(<span class="number">12</span>, <span class="string">"mushromms"</span>, <span class="string">"green peppers"</span>, <span class="string">"extra cheese"</span>)</span><br><span class="line">make_pizza(<span class="number">16</span>, <span class="string">"pepperoni"</span>)</span><br></pre></td></tr></table></figure> 然而，使用并非自己编写的大型模块时，最好不要采用这种导入方法，因为如果模块中有函数或变量和你自己写的函数、变量同名，结果将有问题。所以，一般的做法是要么只导入你需要的函数，要么导入整个模块并用句点表示法。</p>
<p><strong>包</strong>： Python中的包就是一个文件夹，但这个文件夹下面必须包含名为<code>__init__.py</code>的文件（前后都是双下划线），包中可以放多个模块，组织结构与Java包类似。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路6-用户输入和while循环</title>
    <url>/2018/04/10/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF6-%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E5%92%8Cwhile%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<blockquote>
<p>《Python编程：从入门到实践》笔记。 本章主要介绍如何进行用户输入，while循环，以及与循环配合使用的break, continue语句。</p>
</blockquote>
<a id="more"></a>
<h1 id="input-函数">1. input() 函数</h1>
<p>在Python中，使用<code>input()</code>函数获取用户输入，这里请注意：<strong><code>input()</code>的返回值为字符串</strong>。如果输入的是数字，并且要用于后续计算，需要进行类型转换。 <code>input()</code>函数可以传入字符串参数作为输入提示，如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">number = input()</span><br><span class="line"><span class="comment"># 判断数据类型的两种方法</span></span><br><span class="line">print(type(number))</span><br><span class="line">print(isinstance(number, str))</span><br><span class="line"></span><br><span class="line">print(int(number) ** <span class="number">2</span>)    <span class="comment"># int()函数将字符串转换成整数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果提示超过一行，可以将提示放在变量中，再将变量传入input()；</span></span><br><span class="line"><span class="comment"># 并且最好在提示后面留一个空格以区分提示和用户输入</span></span><br><span class="line">message = input(<span class="string">"Tell me something, and I will repeat it back to you: "</span>)</span><br><span class="line">print(message)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">True</span></span></span><br><span class="line"><span class="class">15129</span></span><br><span class="line">Tell me something, and I will repeat it back to you: Hello, everyone!</span><br><span class="line">Hello, everyone!</span><br></pre></td></tr></table></figure> <strong>判断奇偶</strong>（作为对前文常见运算的补充）：取模运算<code>%</code>，返回余数 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">number = input(<span class="string">"Enter a number, and I'll tell you if it's even or odd: "</span>)</span><br><span class="line">number = int(number)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> number % <span class="number">2</span>:</span><br><span class="line">    print(<span class="string">"\nThe number "</span> + str(number) + <span class="string">" is even."</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"\nThe number "</span> + str(number) + <span class="string">" is odd."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">Enter a number, <span class="keyword">and</span> I<span class="string">'ll tell you if it'</span>s even <span class="keyword">or</span> odd: <span class="number">123</span></span><br><span class="line"></span><br><span class="line">The number <span class="number">123</span> <span class="keyword">is</span> even.</span><br></pre></td></tr></table></figure> # 2. while 循环简介 <code>for</code>循环用于针对集合中的每个元素的一个代码块，而<code>while</code>循环不断地运行，直到指定的条件不满足为止。比如，让用户选择何时退出： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">prompt = <span class="string">"\nTell me something, and I will repeat it back to you:"</span></span><br><span class="line">prompt += <span class="string">"\nEnter 'quit' to end the program. "</span></span><br><span class="line">message = <span class="string">""</span></span><br><span class="line"><span class="keyword">while</span> message != <span class="string">"quit"</span>:</span><br><span class="line">    message = input(prompt)</span><br><span class="line">    <span class="keyword">if</span> message != <span class="string">"quit"</span>:</span><br><span class="line">        print(message)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">Tell me something, <span class="keyword">and</span> I will repeat it back to you:</span><br><span class="line">Enter <span class="string">'quit'</span> to end the program. Hello everyone!</span><br><span class="line">Hello everyone!</span><br><span class="line"></span><br><span class="line">Tell me something, <span class="keyword">and</span> I will repeat it back to you:</span><br><span class="line">Enter <span class="string">'quit'</span> to end the program. Hello again.</span><br><span class="line">Hello again.</span><br><span class="line"></span><br><span class="line">Tell me something, <span class="keyword">and</span> I will repeat it back to you:</span><br><span class="line">Enter <span class="string">'quit'</span> to end the program. quit</span><br></pre></td></tr></table></figure> ## 2.1 使用标志 在上述代码中我们直接对输入数据进行判断，这样做在简单的程序中可行，但复杂的程序中，如果有多个状态同时决定<code>while</code>循环的继续与否，要是还用上述的方法，则<code>while</code>循环的条件判断将很长很复杂，这时可以定义<strong>一个</strong>变量作为标志来代替多个条件。使用标志来改写上述代码： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">prompt = <span class="string">"\nTell me something, and I will repeat it back to you:"</span></span><br><span class="line">prompt += <span class="string">"\nEnter 'quit' to end the program. "</span></span><br><span class="line"></span><br><span class="line">active = <span class="literal">True</span></span><br><span class="line"><span class="keyword">while</span> active:</span><br><span class="line">    message = input(prompt)</span><br><span class="line">    <span class="keyword">if</span> message != <span class="string">"quit"</span>:</span><br><span class="line">        active = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(message)</span><br></pre></td></tr></table></figure> 在复杂的程序中，如很多事件都会导致程序停止运行的游戏中，标志很有用：在其中的任何一个事件导致活动标志变为<code>False</code>时，主游戏循环将退出。 ## 2.2 使用break退出循环 要立即退出<code>while</code>或者<code>for</code>循环，不在执行循环中余下的代码，也不管条件测试的结果如何，可使用<code>break</code>语句。再将上述使用标志的代码改写为break： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">prompt = <span class="string">"\nTell me something, and I will repeat it back to you:"</span></span><br><span class="line">prompt += <span class="string">"\nEnter 'quit' to end the program. "</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    message = input(prompt)</span><br><span class="line">    <span class="keyword">if</span> message != <span class="string">"quit"</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    print(message)</span><br></pre></td></tr></table></figure> ## 2.3 在循环中使用continue 如果满足某条件时要返回循环开始处，而不是跳出循环，则使用<code>continue</code>语句。以下是打印1到10中的所有奇数的代码： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">10</span>:</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> count % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    print(count)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure> <strong>break与continue的区别</strong>：<code>break</code>跳过循环体内余下的所有代码，并跳出循环；<code>continue</code>跳过循环体内余下的所有代码，回到循环体开始处继续执行，而不是跳出循环体。 值得提醒的是，编写循环时应避免<strong>死循环</strong>，或者叫做<strong>无限循环</strong>，比如<code>while</code>循环忘记了变量自增。 # 3. 使用while循环来处理列表和字典 ## 3.1 在列表之间移动元素 将未验证用户经验证后变为已验证用户： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">unconfirmed_users = [<span class="string">"alice"</span>, <span class="string">"brian"</span>, <span class="string">"candace"</span>]</span><br><span class="line">confirmed_users = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> unconfirmed_users:</span><br><span class="line">    current_user = unconfirmed_users.pop()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"Verifying user: "</span> + current_user.title())</span><br><span class="line">    confirmed_users.append(current_user)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"\nThe following users have been confirmed:"</span>)</span><br><span class="line"><span class="keyword">for</span> confirmed_user <span class="keyword">in</span> confirmed_users:</span><br><span class="line">    print(confirmed_user.title())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">Verifying user: Candace</span><br><span class="line">Verifying user: Brian</span><br><span class="line">Verifying user: Alice</span><br><span class="line"></span><br><span class="line">The following users have been confirmed:</span><br><span class="line">Candace</span><br><span class="line">Brian</span><br><span class="line">Alice</span><br></pre></td></tr></table></figure> ## 3.2 删除包含特定值的所有列表元素 之前的章节中使用<code>remove()</code>函数来删除列表中的值，但只删除了列表中的第一个指定值，以下代码循环删除列表中指定的值： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">pets = [<span class="string">"dog"</span>, <span class="string">"cat"</span>, <span class="string">"dog"</span>, <span class="string">"goldfish"</span>, <span class="string">"cat"</span>, <span class="string">"rabbit"</span>, <span class="string">"cat"</span>]</span><br><span class="line">print(pets)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="string">"cat"</span> <span class="keyword">in</span> pets:</span><br><span class="line">    pets.remove(<span class="string">"cat"</span>)</span><br><span class="line"></span><br><span class="line">print(pets)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">[<span class="string">'dog'</span>, <span class="string">'cat'</span>, <span class="string">'dog'</span>, <span class="string">'goldfish'</span>, <span class="string">'cat'</span>, <span class="string">'rabbit'</span>, <span class="string">'cat'</span>]</span><br><span class="line">[<span class="string">'dog'</span>, <span class="string">'dog'</span>, <span class="string">'goldfish'</span>, <span class="string">'rabbit'</span>]</span><br></pre></td></tr></table></figure> ## 3.3 使用用户输入来填充字典 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">responses = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置一个标志，指出调查是否继续</span></span><br><span class="line">polling_active = <span class="literal">True</span></span><br><span class="line"><span class="keyword">while</span> polling_active:</span><br><span class="line">    <span class="comment"># 提示输入被调查者的名字和回答</span></span><br><span class="line">    name = input(<span class="string">"\nWhat is your name? "</span>)</span><br><span class="line">    response = input(<span class="string">"Which mountain would you like to climb someday? "</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将回答存入字典</span></span><br><span class="line">    responses[name] = response</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 是否还有人要参与调查</span></span><br><span class="line">    repeat = input(<span class="string">"World you like to let another person respond?(yes/ no) "</span>)</span><br><span class="line">    <span class="keyword">if</span> repeat == <span class="string">"no"</span>:</span><br><span class="line">        polling_active = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调查结束，输出结果</span></span><br><span class="line">print(<span class="string">"\n--- Poll Results ---"</span>)</span><br><span class="line"><span class="keyword">for</span> name, response <span class="keyword">in</span> responses.items():</span><br><span class="line">    print(name + <span class="string">" world like to climb "</span> + response + <span class="string">"."</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">What is your name? Eric</span><br><span class="line">Which mountain would you like to climb someday? Denali</span><br><span class="line">World you like to let another person respond?(yes/ no) yes</span><br><span class="line"></span><br><span class="line">What is your name? Lynn</span><br><span class="line">Which mountain would you like to climb someday? Devil's Thumb</span><br><span class="line">World you like to let another person respond?(yes/ no) no</span><br><span class="line"></span><br><span class="line">--- Poll Results ---</span><br><span class="line">Eric world like to climb Denali.</span><br><span class="line">Lynn world like to climb Devil<span class="string">'s Thumb.</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路5-字典</title>
    <url>/2018/04/10/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF5-%E5%AD%97%E5%85%B8/</url>
    <content><![CDATA[<blockquote>
<p>《Python编程：从入门到实践》笔记。 本章主要介绍字典的概念，基本操作以及一些进阶操作。</p>
</blockquote>
<a id="more"></a>
<h1 id="使用字典dict">1. 使用字典（Dict）</h1>
<p>在Python中，字典是一系列键值对。每个键都与一个值相关联，用键来访问值。Python中用花括号<code>{}</code>来表示字典。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">alien = &#123;<span class="string">"color"</span>: <span class="string">"green"</span>, <span class="string">"points"</span>: <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">print(alien)  <span class="comment"># 输出字典</span></span><br><span class="line">print(alien[<span class="string">"color"</span>])   <span class="comment"># 输出键所对应的值</span></span><br><span class="line">print(alien[<span class="string">"points"</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">&#123;<span class="string">'color'</span>: <span class="string">'green'</span>, <span class="string">'points'</span>: <span class="number">5</span>&#125;</span><br><span class="line">green</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure> 字典中可以包含任意数量的键值对，并且Python中字典是一个动态结构，可随时向其中添加键值对。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">alien = &#123;<span class="string">"color"</span>: <span class="string">"green"</span>, <span class="string">"points"</span>: <span class="number">5</span>&#125;</span><br><span class="line">print(alien)</span><br><span class="line"></span><br><span class="line">alien[<span class="string">"x_position"</span>] = <span class="number">0</span></span><br><span class="line">alien[<span class="string">"y_position"</span>] = <span class="number">25</span></span><br><span class="line">print(alien)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">&#123;<span class="string">'color'</span>: <span class="string">'green'</span>, <span class="string">'points'</span>: <span class="number">5</span>&#125;</span><br><span class="line">&#123;<span class="string">'color'</span>: <span class="string">'green'</span>, <span class="string">'points'</span>: <span class="number">5</span>, <span class="string">'x_position'</span>: <span class="number">0</span>, <span class="string">'y_position'</span>: <span class="number">25</span>&#125;</span><br></pre></td></tr></table></figure> 有时候，在空字典中添加键值对是为了方便，而有时候则是必须这么做，比如使用字典来存储用户提供的数据或在编写能自动生成大量键值对的代码时，此时通常要先定义一个空字典。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">alien = &#123;&#125;    <span class="comment"># 定义空字典的语法</span></span><br><span class="line">alien[<span class="string">"x_position"</span>] = <span class="number">0</span></span><br><span class="line">alien[<span class="string">"y_position"</span>] = <span class="number">25</span></span><br><span class="line">print(alien)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">&#123;<span class="string">'x_position'</span>: <span class="number">0</span>, <span class="string">'y_position'</span>: <span class="number">25</span>&#125;</span><br></pre></td></tr></table></figure> 如果要修改字典中的值，只需通过键名访问就行。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">alien = &#123;<span class="string">"color"</span> : <span class="string">"green"</span>&#125;</span><br><span class="line">print(<span class="string">"The alien is "</span> + alien[<span class="string">"color"</span>] + <span class="string">"."</span>)</span><br><span class="line"></span><br><span class="line">alien[<span class="string">"color"</span>] = <span class="string">"yellow"</span></span><br><span class="line">print(<span class="string">"The alien is now "</span> + alien[<span class="string">"color"</span>] + <span class="string">"."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">The alien <span class="keyword">is</span> green.</span><br><span class="line">The alien <span class="keyword">is</span> now yellow.</span><br></pre></td></tr></table></figure> 对于字典中不再需要的信息，可用<code>del</code>语句将相应的键值对删除： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">alien = &#123;<span class="string">"color"</span>: <span class="string">"green"</span>, <span class="string">"points"</span>: <span class="number">5</span>&#125;</span><br><span class="line">print(alien)</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> alien[<span class="string">"color"</span>]</span><br><span class="line">print(alien)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">&#123;<span class="string">'color'</span>: <span class="string">'green'</span>, <span class="string">'points'</span>: <span class="number">5</span>&#125;</span><br><span class="line">&#123;<span class="string">'points'</span>: <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure> 前面的例子都是一个对象的多种信息构成了一个字典（游戏中的外星人信息），字典也可以用来存储众多对象的统一信息： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">favorite_languages = &#123;</span><br><span class="line">    <span class="string">"jen"</span>: <span class="string">"python"</span>,</span><br><span class="line">    <span class="string">"sarah"</span>: <span class="string">"c"</span>,</span><br><span class="line">    <span class="string">"edward"</span>: <span class="string">"ruby"</span>,</span><br><span class="line">    <span class="string">"phil"</span>: <span class="string">"python"</span>,   <span class="comment"># 建议在最后一项后面也加个逗号，便于之后添加元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> # 2. 遍历字典 ## 2.1 遍历所有的键值对 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">user_0 = &#123;</span><br><span class="line">    <span class="string">"username"</span>: <span class="string">"efermi"</span>,</span><br><span class="line">    <span class="string">"first"</span>: <span class="string">"enrico"</span>,</span><br><span class="line">    <span class="string">"last"</span>: <span class="string">"fermi"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> user_0.items():</span><br><span class="line">    print(<span class="string">"Key: "</span> + key)</span><br><span class="line">    print(<span class="string">"Value: "</span> + value + <span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">Key: username</span><br><span class="line">Value: efermi</span><br><span class="line"></span><br><span class="line">Key: first</span><br><span class="line">Value: enrico</span><br><span class="line"></span><br><span class="line">Key: last</span><br><span class="line">Value: fermi</span><br></pre></td></tr></table></figure> 这里有一点需要注意，遍历字典时，键值对的返回顺序不一定与存储顺序相同，Python不关心键值对的存储顺序，而只追踪键与值之间的关联关系。 ## 2.2 遍历字典中的所有键 字典的方法<code>keys()</code>将字典中的所有键<strong>以列表的形式返回</strong>，以下代码遍历字典中的所有键： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">favorite_languages = &#123;</span><br><span class="line">    <span class="string">"jen"</span>: <span class="string">"python"</span>,</span><br><span class="line">    <span class="string">"sarah"</span>: <span class="string">"c"</span>,</span><br><span class="line">    <span class="string">"edward"</span>: <span class="string">"ruby"</span>,</span><br><span class="line">    <span class="string">"phil"</span>: <span class="string">"python"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> favorite_languages.keys():</span><br><span class="line">    print(name.title())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">Jen</span><br><span class="line">Sarah</span><br><span class="line">Edward</span><br><span class="line">Phil</span><br></pre></td></tr></table></figure> 也可以用如下方法遍历字典的所有键： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">favorite_languages = &#123;</span><br><span class="line">    <span class="string">"jen"</span>: <span class="string">"python"</span>,</span><br><span class="line">    <span class="string">"sarah"</span>: <span class="string">"c"</span>,</span><br><span class="line">    <span class="string">"edward"</span>: <span class="string">"ruby"</span>,</span><br><span class="line">    <span class="string">"phil"</span>: <span class="string">"python"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> favorite_languages:</span><br><span class="line">    print(name.title())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">Jen</span><br><span class="line">Sarah</span><br><span class="line">Edward</span><br><span class="line">Phil</span><br></pre></td></tr></table></figure> 但是带有方法<code>keys()</code>的遍历所表达的意思更明确。 还可以用<code>keys()</code>方法确定某关键字是否在字典中： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">favorite_languages = &#123;</span><br><span class="line">    <span class="string">"jen"</span>: <span class="string">"python"</span>,</span><br><span class="line">    <span class="string">"sarah"</span>: <span class="string">"c"</span>,</span><br><span class="line">    <span class="string">"edward"</span>: <span class="string">"ruby"</span>,</span><br><span class="line">    <span class="string">"phil"</span>: <span class="string">"python"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">"erin"</span> <span class="keyword">not</span> <span class="keyword">in</span> favorite_languages.keys():</span><br><span class="line">    print(<span class="string">"Erin, please take our poll!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">Erin, please take our poll!</span><br></pre></td></tr></table></figure> 使用<code>sorted()</code>函数按顺序遍历字典中的所有键： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">favorite_languages = &#123;</span><br><span class="line">    <span class="string">"jen"</span>: <span class="string">"python"</span>,</span><br><span class="line">    <span class="string">"sarah"</span>: <span class="string">"c"</span>,</span><br><span class="line">    <span class="string">"edward"</span>: <span class="string">"ruby"</span>,</span><br><span class="line">    <span class="string">"phil"</span>: <span class="string">"python"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> sorted(favorite_languages.keys()):</span><br><span class="line">    print(name.title() + <span class="string">", thank you for taking the poll."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">Edward, thank you <span class="keyword">for</span> taking the poll.</span><br><span class="line">Jen, thank you <span class="keyword">for</span> taking the poll.</span><br><span class="line">Phil, thank you <span class="keyword">for</span> taking the poll.</span><br><span class="line">Sarah, thank you <span class="keyword">for</span> taking the poll.</span><br></pre></td></tr></table></figure> ## 2.3 遍历字典中的所有值 类似于遍历所有键用<code>keys()</code>方法，遍历所有值则使用<code>values()</code>方法： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">favorite_languages = &#123;</span><br><span class="line">    <span class="string">"jen"</span>: <span class="string">"python"</span>,</span><br><span class="line">    <span class="string">"sarah"</span>: <span class="string">"c"</span>,</span><br><span class="line">    <span class="string">"edward"</span>: <span class="string">"ruby"</span>,</span><br><span class="line">    <span class="string">"phil"</span>: <span class="string">"python"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(<span class="string">"The following languages have been mentioned:"</span>)</span><br><span class="line"><span class="keyword">for</span> language <span class="keyword">in</span> favorite_languages.values():</span><br><span class="line">    print(language.title())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">Python</span><br><span class="line">C</span><br><span class="line">Ruby</span><br><span class="line">Python</span><br></pre></td></tr></table></figure> 从结果可以看出，上述代码并没有考虑去重的问题，如果想要去重，可以调用<code>set()</code>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">favorite_languages = &#123;</span><br><span class="line">    <span class="string">"jen"</span>: <span class="string">"python"</span>,</span><br><span class="line">    <span class="string">"sarah"</span>: <span class="string">"c"</span>,</span><br><span class="line">    <span class="string">"edward"</span>: <span class="string">"ruby"</span>,</span><br><span class="line">    <span class="string">"phil"</span>: <span class="string">"python"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(<span class="string">"The following languages have been mentioned:"</span>)</span><br><span class="line"><span class="keyword">for</span> language <span class="keyword">in</span> set(favorite_languages.values()):</span><br><span class="line">    print(language.title())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">Python</span><br><span class="line">C</span><br><span class="line">Ruby</span><br></pre></td></tr></table></figure> # 3. 嵌套 ## 3.1 字典列表 以前面外星人为例，三个外星人组成一个列表： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">alien_0 = &#123;<span class="string">"color"</span>: <span class="string">"green"</span>, <span class="string">"points"</span>: <span class="number">5</span>&#125;</span><br><span class="line">alien_1 = &#123;<span class="string">"color"</span>: <span class="string">"yellow"</span>, <span class="string">"points"</span>: <span class="number">10</span>&#125;</span><br><span class="line">alien_2 = &#123;<span class="string">"color"</span>: <span class="string">"red"</span>, <span class="string">"points"</span>: <span class="number">15</span>&#125;</span><br><span class="line"></span><br><span class="line">aliens = [alien_0, alien_1, alien_2]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> alien <span class="keyword">in</span> aliens:</span><br><span class="line">    print(alien)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">&#123;<span class="string">'color'</span>: <span class="string">'green'</span>, <span class="string">'points'</span>: <span class="number">5</span>&#125;</span><br><span class="line">&#123;<span class="string">'color'</span>: <span class="string">'yellow'</span>, <span class="string">'points'</span>: <span class="number">10</span>&#125;</span><br><span class="line">&#123;<span class="string">'color'</span>: <span class="string">'red'</span>, <span class="string">'points'</span>: <span class="number">15</span>&#125;</span><br></pre></td></tr></table></figure> ## 3.2 在字典中存储列表 每当需要在字典中将一个键关联到多个值时，都可以在字典中嵌套一个列表： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">pizza = &#123;</span><br><span class="line">    <span class="string">"crust"</span>: <span class="string">"thick"</span>,</span><br><span class="line">    <span class="string">"toppings"</span>: [<span class="string">"mushrooms"</span>, <span class="string">"extra cheese"</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(<span class="string">"You ordered a "</span> + pizza[<span class="string">"crust"</span>] + <span class="string">"-crust pizza"</span> +</span><br><span class="line">      <span class="string">"with the following toppings:"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> topping <span class="keyword">in</span> pizza[<span class="string">"toppings"</span>]:</span><br><span class="line">    print(<span class="string">"\t"</span> + topping)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">You ordered a thick-crust pizzawith the following toppings:</span><br><span class="line">	mushrooms</span><br><span class="line">	extra cheese</span><br></pre></td></tr></table></figure> ## 3.3 在字典中存储字典 涉及到这种情况时，代码都不会简单： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">users = &#123;</span><br><span class="line">    <span class="string">"aeinstein"</span>: &#123;</span><br><span class="line">        <span class="string">"first"</span>: <span class="string">"albert"</span>,</span><br><span class="line">        <span class="string">"last"</span>: <span class="string">"einstein"</span>,</span><br><span class="line">        <span class="string">"location"</span>: <span class="string">"princeton"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"mcurie"</span>: &#123;</span><br><span class="line">        <span class="string">"first"</span>: <span class="string">"marie"</span>,</span><br><span class="line">        <span class="string">"last"</span>: <span class="string">"curie"</span>,</span><br><span class="line">        <span class="string">"location"</span>: <span class="string">"paris"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> username, user_info <span class="keyword">in</span> users.items():</span><br><span class="line">    print(<span class="string">"\nUsername: "</span> + username)</span><br><span class="line">    full_name = user_info[<span class="string">"first"</span>] + <span class="string">" "</span> + user_info[<span class="string">"last"</span>]</span><br><span class="line">    location = user_info[<span class="string">"location"</span>]</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"\tFull name: "</span> + full_name.title())</span><br><span class="line">    print(<span class="string">"\tLocation: "</span> + location.title())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">Username: aeinstein</span><br><span class="line">	Full name: Albert Einstein</span><br><span class="line">	Location: Princeton</span><br><span class="line"></span><br><span class="line">Username: mcurie</span><br><span class="line">	Full name: Marie Curie</span><br><span class="line">	Location: Paris</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路4-if语句</title>
    <url>/2018/04/10/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF4-if%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<blockquote>
<p>《Python编程：从入门到实践》笔记。 本章主要讲述条件语句if, if-else, if-elif, if-elif-else等结构。</p>
</blockquote>
<a id="more"></a>
<h1 id="条件测试">1. 条件测试</h1>
<p>包括了“相等”，“不等”，“大于”，“小于”，“大于等于”，“小于等于”，“存在于”，“与或非”等判断。值得注意的是，Python对大小写敏感： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>car = <span class="string">"Audi"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>car == <span class="string">"audi"</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>car.lower() == <span class="string">"audi"</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>car != <span class="string">"audi"</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>age = <span class="number">19</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>age &lt; <span class="number">21</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>age &lt;= <span class="number">21</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>age &gt;= <span class="number">21</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>age_0 = <span class="number">22</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>age_1 = <span class="number">18</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>age_0 &gt;= <span class="number">21</span> <span class="keyword">and</span> age_1 &gt;= <span class="number">21</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>age_0 &gt;= <span class="number">21</span> <span class="keyword">or</span> age_1 &gt;= <span class="number">21</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>requested_toppings = [<span class="string">'mushrooms'</span>, <span class="string">'onions'</span>, <span class="string">'pineapple'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'mushrooms'</span> <span class="keyword">in</span> requested_toppings</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'mushrooms'</span> <span class="keyword">not</span> <span class="keyword">in</span> requested_toppings</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure> # 2. if 语句 ## 2.1 简单的if语句 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">age = <span class="number">19</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    print(<span class="string">"You are old enough to vote!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">You are old enough to vote!</span><br></pre></td></tr></table></figure></p>
<h2 id="if-else-语句">2.2 if-else 语句</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">age = <span class="number">17</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    print(<span class="string">"You are old enough to vote!"</span>)</span><br><span class="line">    print(<span class="string">"Have you registered to vote yet?"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"Sorry, you are too young to vote."</span>)</span><br><span class="line">    print(<span class="string">"Please register to vote as soon as you turn 18!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">Sorry, you are too young to vote.</span><br><span class="line">Please register to vote <span class="keyword">as</span> soon <span class="keyword">as</span> you turn <span class="number">18</span>!</span><br></pre></td></tr></table></figure>
<h2 id="if-elif-else-结构">2.3 if-elif-else 结构</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">age = <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> age &lt; <span class="number">4</span>:</span><br><span class="line">    price = <span class="number">0</span></span><br><span class="line"><span class="keyword">elif</span> age &lt; <span class="number">18</span>:</span><br><span class="line">    price = <span class="number">5</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    price = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"Your admission cost is $"</span> + str(price) + <span class="string">"."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">Your admission cost <span class="keyword">is</span> $<span class="number">5.</span></span><br></pre></td></tr></table></figure>
<p>还可以根据需要使用任意数量的<code>elif</code>代码块： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">age = <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> age &lt; <span class="number">4</span>:</span><br><span class="line">    price = <span class="number">0</span></span><br><span class="line"><span class="keyword">elif</span> age &lt; <span class="number">18</span>:</span><br><span class="line">    price = <span class="number">5</span></span><br><span class="line"><span class="keyword">elif</span> age &lt; <span class="number">65</span>:</span><br><span class="line">	price = <span class="number">10</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    price = <span class="number">5</span></span><br><span class="line">    </span><br><span class="line">print(<span class="string">"Your admission cost is $"</span> + str(price) + <span class="string">"."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">Your admission cost <span class="keyword">is</span> $<span class="number">5.</span></span><br></pre></td></tr></table></figure> 其次，Python并不要求<code>if-elif</code>结构后面必须有<code>else</code>代码块。<code>else</code>是一条包罗万象的语句，只要不满足前面的条件，其中的代码就会执行，这可能会引入无效甚至恶意的数据。所以如果知道最终要测试的条件，应考虑使用一个elif代码块来代替<code>else</code>代码块，使代码更清晰，如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">age = <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> age &lt; <span class="number">4</span>:</span><br><span class="line">    price = <span class="number">0</span></span><br><span class="line"><span class="keyword">elif</span> age &lt; <span class="number">18</span>:</span><br><span class="line">    price = <span class="number">5</span></span><br><span class="line"><span class="keyword">elif</span> age &lt; <span class="number">65</span>:</span><br><span class="line">	price = <span class="number">10</span></span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">65</span>:</span><br><span class="line">    price = <span class="number">5</span></span><br><span class="line">    </span><br><span class="line">print(<span class="string">"Your admission cost is $"</span> + str(price) + <span class="string">"."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">Your admission cost <span class="keyword">is</span> $<span class="number">5.</span></span><br></pre></td></tr></table></figure> ## 2.4 测试多个条件 <code>if-elif-else</code>结构功能强大，但仅适用于只有一个条件满足的情况，即只要其中一个条件满足，其余条件都会被跳过，这保证了程序的高效性。然而有时必须检查你关心的所有条件，这时则应该使用一系列不包含<code>elif</code>和<code>else</code>代码块的简单<code>if</code>语句： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">requested_toppings = [<span class="string">"mushrooms"</span>, <span class="string">"extra cheese"</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">"mushrooms"</span> <span class="keyword">in</span> requested_toppings:</span><br><span class="line">    print(<span class="string">"Adding mushrooms."</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="string">"pepperoni"</span> <span class="keyword">in</span> requested_toppings:</span><br><span class="line">    print(<span class="string">"Adding pepperoni."</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="string">"extra cheese"</span> <span class="keyword">in</span> requested_toppings:</span><br><span class="line">    print(<span class="string">"Adding extra cheese."</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"\nFinished making your pizza!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">Adding mushrooms.</span><br><span class="line">Adding extra cheese.</span><br><span class="line"></span><br><span class="line">Finished making your pizza!</span><br></pre></td></tr></table></figure> 总之：如果你只想执行一个代码块，就用<code>if-elif-else</code>结构；如果要运行多个代码块，就使用一系列独立的<code>if</code>语句。 # 3. 使用if语句处理列表 <code>if</code>语句常和循环结构配合使用。 ## 3.1 检查特殊元素 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">requested_toppings = [<span class="string">"mushrooms"</span>, <span class="string">"extra cheese"</span>, <span class="string">"green peppers"</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> requested_topping <span class="keyword">in</span> requested_toppings:</span><br><span class="line">    <span class="keyword">if</span> requested_topping == <span class="string">"green peppers"</span>:</span><br><span class="line">        print(<span class="string">"Sorry, we are out of green peppers right now."</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"Adding "</span> + requested_topping + <span class="string">"."</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"\nFinished making your pizza!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">Adding mushrooms.</span><br><span class="line">Adding extra cheese.</span><br><span class="line">Sorry, we are out of green peppers right now.</span><br><span class="line"></span><br><span class="line">Finished making your pizza!</span><br></pre></td></tr></table></figure></p>
<h2 id="确定列表不是空的">3.2 确定列表不是空的</h2>
<p>到目前为止，对于处理的每个列表都做了一个简单的假设，即它们非空，然而实际工程中，在遍历一个列表前需要先判断该列表是否为空： <figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">requested_toppings = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> requested_toppings:</span><br><span class="line">    <span class="keyword">for</span> requested_topping <span class="keyword">in</span> requested_toppings:</span><br><span class="line">        print(<span class="string">"Adding "</span> + requested_topping + <span class="string">"."</span>)</span><br><span class="line">    print(<span class="string">"\nFinished making your pizza!"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"Are you sure you want a plain pizza?"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">Are you sure you want a plain pizza?</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路3-操作列表</title>
    <url>/2018/04/10/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF3-%E6%93%8D%E4%BD%9C%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<blockquote>
<p>《Python编程：从入门到实践》笔记。 本章内容主要是对列表的进一步操作，以及初识元组数据结构。</p>
</blockquote>
<a id="more"></a>
<h1 id="遍历列表">1. 遍历列表</h1>
<p>本章主要是<code>for</code>循环： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">magicians = [<span class="string">'alice'</span>, <span class="string">'david'</span>, <span class="string">'carolina'</span>]</span><br><span class="line"><span class="keyword">for</span> magician <span class="keyword">in</span> magicians:</span><br><span class="line">    print(magician.title() + <span class="string">", that was a great trick"</span>)</span><br><span class="line">    print(<span class="string">"I can't wait to see your next trick, "</span> + magician.title() + <span class="string">".\n"</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Thank you, everyone. That was a great magic show!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line">Alice, that was a great trick!</span><br><span class="line">I can<span class="string">'t wait to see your next trick, Alice.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">David, that was a great trick!</span></span><br><span class="line"><span class="string">I can'</span>t wait to see your next trick, David.</span><br><span class="line"></span><br><span class="line">Carolina, that was a great trick!</span><br><span class="line">I can<span class="string">'t wait to see your next trick, Carolina.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Thank you, everyone. That was a great magic show!</span></span><br></pre></td></tr></table></figure> 这里有两个值得注意的地方，一个是“冒号”：<code>for</code>关键字所在的行最后有一个冒号；一个是缩进问题，Python中的代码块都是以缩进为标准，不像C/C++，Java这样的语言以花括号表示代码块。<code>IndentationError</code>指缩进错误。 # 2. 创建数值列表 这有使用一个重要的生成数列的函数 <code>range()</code> ，以及将数据转换成列表的 <code>list()</code> 函数： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">print(list(range(<span class="number">6</span>)))         <span class="comment"># 结束值（不包含结束值）</span></span><br><span class="line">print(list(range(<span class="number">1</span>, <span class="number">6</span>)))      <span class="comment"># 起始值（包含），结束值（不含）</span></span><br><span class="line">print(list(range(<span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>)))   <span class="comment"># 起始值，结束值，步长；最后一个数小于结束值</span></span><br><span class="line">print(list(range(<span class="number">6</span>, <span class="number">1</span>, <span class="number">-1</span>)))  <span class="comment"># 负数步长，此时起始值要大于结束值</span></span><br><span class="line">print(list(range(<span class="number">1</span>, <span class="number">6</span>, <span class="number">-1</span>)))  <span class="comment"># 负数步长，若起始值小于结束值，则输出空列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure> <code>range()</code>函数也常用语<code>for</code>循环，用于标识循环次数，或者用于生成更复杂的列表： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">squares = []</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">    squares.append(value ** <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">print(squares)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">17</span>, <span class="number">26</span>, <span class="number">37</span>, <span class="number">50</span>, <span class="number">65</span>, <span class="number">82</span>, <span class="number">101</span>]</span><br></pre></td></tr></table></figure> 对于生成列表，还有一种更简洁的写法，即列表解析式，如上述生成列表的代码可以缩短为一行： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">squares = [value ** <span class="number">2</span> <span class="keyword">for</span> value <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line">print(squares)</span><br><span class="line"></span><br><span class="line">squares_2 = [value ** <span class="number">2</span> <span class="keyword">for</span> value <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> value % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">print(squares_2)</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br><span class="line">[<span class="number">4</span>, <span class="number">16</span>, <span class="number">36</span>, <span class="number">64</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure> 列表解析式还可以更复杂，这里就不再赘述了。</p>
<p><strong>对数字列表执行简单的统计计算</strong>： 求一个数字列表的最大、最小值以及所有元素之和： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">digits = list(range(<span class="number">10</span>))</span><br><span class="line">print(min(digits), max(digits), sum(digits))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line"><span class="number">0</span> <span class="number">9</span> <span class="number">45</span></span><br></pre></td></tr></table></figure> # 3. 使用列表的一部分 ## 3.1 切片 切片操作用于取原始列表的一部分： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">players = [<span class="string">'charles'</span>, <span class="string">'martina'</span>, <span class="string">'michael'</span>, <span class="string">'florence'</span>, <span class="string">'eli'</span>]</span><br><span class="line"><span class="comment"># [起始：结束：步长]， 其中，结果列表包含起始索引，但不包含结束索引</span></span><br><span class="line">print(players[<span class="number">0</span>:<span class="number">3</span>])</span><br><span class="line">print(players[:<span class="number">3</span>])   <span class="comment"># 如果从0开始切片，0可以省略</span></span><br><span class="line">print(players[<span class="number">1</span>:<span class="number">3</span>])</span><br><span class="line">print(players[<span class="number">2</span>:])   <span class="comment"># 如果要便利到最后一个元素，结束索引可以省略，此时最后一个元素会被包含</span></span><br><span class="line">print(players[<span class="number">-3</span>:])  </span><br><span class="line">print(players[::<span class="number">2</span>])  <span class="comment"># 设置了步长，但省略了结束索引，列表最后一个元素如果被遍历到，则会被包含</span></span><br><span class="line">print(players[:<span class="number">4</span>:<span class="number">2</span>]) <span class="comment"># 设置了步长和结束索引，索引4的元素也被遍历到了，但不会被包含在结果中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">[<span class="string">'charles'</span>, <span class="string">'martina'</span>, <span class="string">'michael'</span>]</span><br><span class="line">[<span class="string">'charles'</span>, <span class="string">'martina'</span>, <span class="string">'michael'</span>]</span><br><span class="line">[<span class="string">'martina'</span>, <span class="string">'michael'</span>]</span><br><span class="line">[<span class="string">'michael'</span>, <span class="string">'florence'</span>, <span class="string">'eli'</span>]</span><br><span class="line">[<span class="string">'michael'</span>, <span class="string">'florence'</span>, <span class="string">'eli'</span>]</span><br><span class="line">[<span class="string">'charles'</span>, <span class="string">'michael'</span>, <span class="string">'eli'</span>]</span><br><span class="line">[<span class="string">'charles'</span>, <span class="string">'michael'</span>]</span><br></pre></td></tr></table></figure> 切片操作的参数设置和<code>range()</code>函数的参数设置十分相似，起始，结束，步长都可以为负值，这里先总结一条规律：如果步长为正数，则起始位置要在结束位置的左边；若步长为负数，则起始位置要在结束位置的右边。 ## 3.2 复制列表 这里有深浅复制的问题。如果直接将一个变量赋值到另一个变量，那么内存中的数据依然只有一份，而不是两份，这两个变量都指向内存中同一个存放数据的内存区域，如果用C/C++的语言来描述，Python中的变量都相当于指针，这两个变量（指针）指向的是同一片内存，对这两个变量（指针）的操作会相互影响，因为都作用于同一内存块，如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line"><span class="comment"># 浅复制</span></span><br><span class="line">players = [<span class="string">'charles'</span>, <span class="string">'martina'</span>, <span class="string">'michael'</span>, <span class="string">'florence'</span>, <span class="string">'eli'</span>]</span><br><span class="line">print(players)</span><br><span class="line"></span><br><span class="line">names = players</span><br><span class="line">names.append(<span class="string">"test"</span>)</span><br><span class="line">print(players)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">[<span class="string">'charles'</span>, <span class="string">'martina'</span>, <span class="string">'michael'</span>, <span class="string">'florence'</span>, <span class="string">'eli'</span>]</span><br><span class="line">[<span class="string">'charles'</span>, <span class="string">'martina'</span>, <span class="string">'michael'</span>, <span class="string">'florence'</span>, <span class="string">'eli'</span>, <span class="string">'test'</span>]</span><br></pre></td></tr></table></figure> 如果想在内存中将原来的数据复制出一份新的，则需要深复制，切片操作则是实现深复制的一种方法： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line"><span class="comment"># 深复制</span></span><br><span class="line">players = [<span class="string">'charles'</span>, <span class="string">'martina'</span>, <span class="string">'michael'</span>, <span class="string">'florence'</span>, <span class="string">'eli'</span>]</span><br><span class="line">print(players)</span><br><span class="line"></span><br><span class="line">names = players[:]</span><br><span class="line">names.append(<span class="string">"test"</span>)</span><br><span class="line">print(names)</span><br><span class="line">print(players)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">[<span class="string">'charles'</span>, <span class="string">'martina'</span>, <span class="string">'michael'</span>, <span class="string">'florence'</span>, <span class="string">'eli'</span>]</span><br><span class="line">[<span class="string">'charles'</span>, <span class="string">'martina'</span>, <span class="string">'michael'</span>, <span class="string">'florence'</span>, <span class="string">'eli'</span>, <span class="string">'test'</span>]</span><br><span class="line">[<span class="string">'charles'</span>, <span class="string">'martina'</span>, <span class="string">'michael'</span>, <span class="string">'florence'</span>, <span class="string">'eli'</span>]</span><br></pre></td></tr></table></figure> # 4. 元组（tuple） 和列表紧密联系的一个数据结构则是元组。列表非常适合用于存储在程序运行期间可能变化的数据集，列表可以被修改。然而有时你需要创建一系列不可修改的元素，这个时候则需要用到元组。 元组用圆括号来标识，以下是声明一个元组： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">my_tuple = ()    <span class="comment"># 空元组</span></span><br><span class="line">one_tuple = (<span class="number">1</span>,) <span class="comment"># 声明含有一个元素的元组。不是one_tuple = (1)</span></span><br></pre></td></tr></table></figure> 对元组中元素的访问以及对元组的遍历都和对列表的操作一样；不同的是，元组中的元素不能被改变。 虽然元组中的元素不能改变，但是元组变量的值可以改变。从C/C++的角度来看，元组变量是个指针，元组相当于一个<code>const</code>数组，数组虽然不能被改变，但指针可以指向别处。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">test_tuple = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">print(test_tuple)</span><br><span class="line">test_tuple = (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">print(test_tuple)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure> 相比于列表，元组是更简单的数据结构。如果需要存储的一组值在程序的整个生命周期内都不变，则可使用元组。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路2-列表介绍</title>
    <url>/2018/04/09/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF2-%E5%88%97%E8%A1%A8%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<blockquote>
<p>《Python编程：从入门到实践》笔记。 本章主要介绍列表的基础与简单操作。</p>
</blockquote>
<a id="more"></a>
<h1 id="列表list是什么">1. 列表(List)是什么</h1>
<p>列表由一系列按特定顺序排列的元素组成。 类似于C/C++, Java中的数组，但和他们不同的是，Python列表中的元素可以是不同类型。 Python中用中括号<code>[]</code>来表示列表，并用逗号分隔其中的元素。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">bicycles = [<span class="string">'trek'</span>, <span class="string">'cannondale'</span>, <span class="string">'redline'</span>, <span class="string">'specialized'</span>]</span><br><span class="line">print(bicycles)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line"><span class="comment"># python打印了该列表的内部表示</span></span><br><span class="line">[<span class="string">'trek'</span>, <span class="string">'cannondale'</span>, <span class="string">'redline'</span>, <span class="string">'specialized'</span>]</span><br></pre></td></tr></table></figure> ## 1.1 访问与使用列表中的元素 大多数编程语言中，索引都是从0开始的，而不是从1开始的。以下代码是输出上述列表中的<strong>第1个</strong>元素： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">print(bicycles[<span class="number">0</span>])</span><br><span class="line">print(bicycles[<span class="number">0</span>].title())</span><br><span class="line"></span><br><span class="line">message = <span class="string">"My first bicycle was a "</span> + bicycles[<span class="number">0</span>].title() + <span class="string">"."</span></span><br><span class="line">print(message)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">trek</span><br><span class="line">Trek</span><br><span class="line">My first bicycle was a Trek.</span><br></pre></td></tr></table></figure> Python还支持索引为负数，表示从后往前数，“-1”表示<strong>倒数第1个</strong>元素，例如： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">print(bicycles[<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">specialized</span><br></pre></td></tr></table></figure> 但是，不管索引是正数还是负数，都要注意<strong>索引越界问题</strong>！ # 2. 修改、添加和删除元素 ## 2.1修改列表元素 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line"><span class="comment"># 修改第一个元素</span></span><br><span class="line">motorcycles = [<span class="string">'honda'</span>, <span class="string">'yamaha'</span>, <span class="string">'suzuki'</span>]</span><br><span class="line">print(motorcycles)</span><br><span class="line"></span><br><span class="line">motorcycles[<span class="number">0</span>] = <span class="string">"ducati"</span></span><br><span class="line">print(motorcycles)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">[<span class="string">'honda'</span>, <span class="string">'yamaha'</span>, <span class="string">'suzuki'</span>]</span><br><span class="line">[<span class="string">'ducati'</span>, <span class="string">'yamaha'</span>, <span class="string">'suzuki'</span>]</span><br></pre></td></tr></table></figure> ## 2.2 添加元素 <strong>在列表末尾添加元素</strong>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">motorcycles = [<span class="string">'honda'</span>, <span class="string">'yamaha'</span>, <span class="string">'suzuki'</span>]</span><br><span class="line">print(motorcycles)</span><br><span class="line"></span><br><span class="line">motorcycles.append(<span class="string">"ducati"</span>)</span><br><span class="line">print(motorcycles)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">[<span class="string">'honda'</span>, <span class="string">'yamaha'</span>, <span class="string">'suzuki'</span>]</span><br><span class="line">[<span class="string">'honda'</span>, <span class="string">'yamaha'</span>, <span class="string">'suzuki'</span>, <span class="string">'ducati'</span>]</span><br></pre></td></tr></table></figure> 也可以动态建立<code>motorcycles</code>列表： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">motorcycles = []  <span class="comment"># 此句很重要！表示声明一个列表！</span></span><br><span class="line">motorcycles.append(<span class="string">'honda'</span>)</span><br><span class="line">motorcycles.append(<span class="string">'yamaha'</span>)</span><br><span class="line">motorcycles.append(<span class="string">'suzuki'</span>)</span><br><span class="line">print(motorcycles)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">[<span class="string">'honda'</span>, <span class="string">'yamaha'</span>, <span class="string">'suzuki'</span>]</span><br></pre></td></tr></table></figure> <strong>在列表中插入元素</strong>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">motorcycles = [<span class="string">'honda'</span>, <span class="string">'yamaha'</span>, <span class="string">'suzuki'</span>]</span><br><span class="line">motorcycles.insert(<span class="number">0</span>, <span class="string">'ducati'</span>)</span><br><span class="line">print(motorcycles)</span><br><span class="line"></span><br><span class="line">motorcycles.insert(<span class="number">4</span>, <span class="string">'dongfeng'</span>) <span class="comment"># 在最后插入一个元素，相当于motorcycles.append('dongfeng')</span></span><br><span class="line">print(motorcycles)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">[<span class="string">'ducati'</span>, <span class="string">'honda'</span>, <span class="string">'yamaha'</span>, <span class="string">'suzuki'</span>]</span><br><span class="line">[<span class="string">'ducati'</span>, <span class="string">'honda'</span>, <span class="string">'yamaha'</span>, <span class="string">'suzuki'</span>, <span class="string">'dongfeng'</span>]</span><br></pre></td></tr></table></figure> ## 2.3删除元素 <strong>使用 <code>del</code> 语句删除元素</strong>：知道元素在列表中的位置 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">motorcycles = [<span class="string">'honda'</span>, <span class="string">'yamaha'</span>, <span class="string">'suzuki'</span>]</span><br><span class="line">print(motorcycles)</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> motorcycles[<span class="number">0</span>]</span><br><span class="line">print(motorcycles)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">[<span class="string">'honda'</span>, <span class="string">'yamaha'</span>, <span class="string">'suzuki'</span>]</span><br><span class="line">[<span class="string">'yamaha'</span>, <span class="string">'suzuki'</span>]</span><br></pre></td></tr></table></figure> <code>del</code> 可删除任意位置的列表元素，前提是知道其索引</p>
<p><strong>使用 <code>pop()</code> 方法删除元素</strong>：会返回被删除的元素，当对被删除的元素还有后续操作时使用此方法。</p>
<p>默认删除列表最后一个元素，当传入参数（作为索引）时，删除指定位置的元素（但请注意越界问题）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">motorcycles = [<span class="string">'honda'</span>, <span class="string">'yamaha'</span>, <span class="string">'suzuki'</span>]</span><br><span class="line">print(motorcycles)</span><br><span class="line"></span><br><span class="line">last_owned = motorcycles.pop()  <span class="comment"># 默认</span></span><br><span class="line">print(<span class="string">"The last motorcycle I owned was a "</span> + last_owned.title() + <span class="string">"."</span>)</span><br><span class="line">print(motorcycles)</span><br><span class="line"></span><br><span class="line">motorcycles.pop(<span class="number">1</span>)  <span class="comment"># 传入参数</span></span><br><span class="line">print(motorcycles)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">[<span class="string">'honda'</span>, <span class="string">'yamaha'</span>, <span class="string">'suzuki'</span>]</span><br><span class="line">The last motorcycle I owned was a Suzuki.</span><br><span class="line">[<span class="string">'honda'</span>, <span class="string">'yamaha'</span>]</span><br><span class="line">[<span class="string">'honda'</span>]</span><br></pre></td></tr></table></figure>
<p>所以，<code>pop()</code> 方法也可以删除任意位置的元素</p>
<p><strong>根据值删除元素的<code>remove()</code>方法</strong>：当不知道元素索引，但知道元素值时 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">motorcycles = [<span class="string">'honda'</span>, <span class="string">'yamaha'</span>, <span class="string">'suzuki'</span>, <span class="string">'ducati'</span>]</span><br><span class="line">print(motorcycles)</span><br><span class="line"></span><br><span class="line">motorcycles.remove(<span class="string">'ducati'</span>)</span><br><span class="line">print(motorcycles)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">[<span class="string">'honda'</span>, <span class="string">'yamaha'</span>, <span class="string">'suzuki'</span>, <span class="string">'ducati'</span>]</span><br><span class="line">[<span class="string">'honda'</span>, <span class="string">'yamaha'</span>, <span class="string">'suzuki'</span>]</span><br></pre></td></tr></table></figure> 注意，如果列表中有多个相同的值，<code>romve()</code> 方法只删除第一个。 # 3. 组织列表 ## 3.1 排序 <strong><code>sort()</code> 方法对列表永久排序（原地操作）</strong>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">cars = [<span class="string">'bmw'</span>, <span class="string">'audi'</span>, <span class="string">'toyota'</span>, <span class="string">'subaru'</span>]</span><br><span class="line">cars.sort()</span><br><span class="line">print(cars)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">[<span class="string">'audi'</span>, <span class="string">'bmw'</span>, <span class="string">'subaru'</span>, <span class="string">'toyota'</span>]</span><br></pre></td></tr></table></figure> 如果不想修改原列表，则应<strong>使用 <code>sorted()</code> 函数对列表进行临时排序</strong>： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">cars = [<span class="string">'bmw'</span>, <span class="string">'audi'</span>, <span class="string">'toyota'</span>, <span class="string">'subaru'</span>]</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Here is the original list:"</span>)</span><br><span class="line">print(cars)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"\nHere is ths sorted list:"</span>)</span><br><span class="line">print(sorted(cars))</span><br><span class="line"></span><br><span class="line">print(<span class="string">"\nHere is the original list again:"</span>)</span><br><span class="line">print(cars)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">Here <span class="keyword">is</span> the original list:</span><br><span class="line">[<span class="string">'bmw'</span>, <span class="string">'audi'</span>, <span class="string">'toyota'</span>, <span class="string">'subaru'</span>]</span><br><span class="line"></span><br><span class="line">Here <span class="keyword">is</span> ths sorted list:</span><br><span class="line">[<span class="string">'audi'</span>, <span class="string">'bmw'</span>, <span class="string">'subaru'</span>, <span class="string">'toyota'</span>]</span><br><span class="line"></span><br><span class="line">Here <span class="keyword">is</span> the original list again:</span><br><span class="line">[<span class="string">'bmw'</span>, <span class="string">'audi'</span>, <span class="string">'toyota'</span>, <span class="string">'subaru'</span>]</span><br></pre></td></tr></table></figure> 不管是<code>sort()</code> 方法还是 <code>sorted()</code> 函数，如果想反向排序，只需要传入关键字参数<code>reverse=True</code>: <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cars.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">sorted(cars, reverse=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure> 以上两种排序是按<code>ASCII</code>码进行的排序，如果想自定义排序，需要传入自定义比较函数。</p>
<p><strong>反向打印列表</strong>：<code>reverse()</code> 方法，也是原地操作！并且这只是反向打印列表的实现方法之一 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">cars = [<span class="string">'bmw'</span>, <span class="string">'audi'</span>, <span class="string">'toyota'</span>, <span class="string">'subaru'</span>]</span><br><span class="line">print(cars)</span><br><span class="line"></span><br><span class="line">cars.reverse()  <span class="comment"># 注意！并没有排序后再反向！</span></span><br><span class="line">print(cars)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">[<span class="string">'bmw'</span>, <span class="string">'audi'</span>, <span class="string">'toyota'</span>, <span class="string">'subaru'</span>]</span><br><span class="line">[<span class="string">'subaru'</span>, <span class="string">'toyota'</span>, <span class="string">'audi'</span>, <span class="string">'bmw'</span>]</span><br></pre></td></tr></table></figure> ## 3.2 确定列表长度 使用 <code>len()</code> 函数获得列表长度： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码:</span></span><br><span class="line">cars = [<span class="string">'bmw'</span>, <span class="string">'audi'</span>, <span class="string">'toyota'</span>, <span class="string">'subaru'</span>]</span><br><span class="line">print(len(cars))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习之路1-变量和简单数据类型</title>
    <url>/2018/04/08/Python%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF1-%E5%8F%98%E9%87%8F%E5%92%8C%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<blockquote>
<p>《Python编程：从入门到实践》笔记。 本章主要介绍Python的基本数据类型以及对这些数据的简单操作。</p>
</blockquote>
<a id="more"></a>
<h1 id="入门仪式">1. 入门仪式</h1>
<p>作为一个合格的程序员，必须精通各种语言的<code>Hello, World!</code>，以下是学习Python的第一段代码： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"Hello, World!"</span>)</span><br></pre></td></tr></table></figure> # 2. 变量</p>
<p>变量就是数据的别称，和数学上的变量类似。例如上述代码用变量表示： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">message = <span class="string">"Hello, World!"</span></span><br><span class="line">print(message)</span><br></pre></td></tr></table></figure> 变量有一定的命名规则：</p>
<ul>
<li>变量名只能包含字母、数字和下划线，且不能以数字开头</li>
<li>变量名不能包含空格，一般用下划线分隔变量中的单词，也可以用驼峰命名法，但Python提倡用下划线</li>
<li>Python中的关键字和自带函数不能用于变量名</li>
<li>变量名应该简短明了</li>
<li>慎用小写字母 l 和大写字母O，因为这两个字母容易被看成数字1和0</li>
</ul>
<p>同时也请注意，Python解释器不对代码进行拼写检查，应尽量避免命名错误，比如变量名中少写个字母之类的，否则会出现<code>NameError</code>。 # 3. 字符串</p>
<p>字符串就是一系列被引号括起来的字符，在Python中，引号可以是单引号，也可以是双引号，还可以是三引号。单双引增加了Python字符串的灵活性，减少了转义字符的使用，比如字符串中有且只有单引号时，最外层可以用双引号，反之亦然。三引号主要用于字符串是多行的情况，同时它也常用于注释。例子如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"This is a string."</span></span><br><span class="line"><span class="string">'This is also a string.'</span></span><br><span class="line"></span><br><span class="line"><span class="string">'I told my friend, "Python is my favorite language!"'</span></span><br><span class="line"><span class="string">"The language 'Python' is named after Monty Python, not the snake."</span></span><br><span class="line"><span class="string">"One of Python's strengths is its diverse and supportive community."</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">this is line 1;</span></span><br><span class="line"><span class="string">this is line 2.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">this is line 1;</span></span><br><span class="line"><span class="string">this is line 2.</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure> 注意，若字符串中出现了和最外层引号相同的引号时，会出现<code>SyntaxError</code></p>
<p><strong>字符串首字母大写</strong>：字符串中每个单词首字母大写 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">name = <span class="string">"ada lovelace"</span></span><br><span class="line">print(name.title())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">Ada Lovelace</span><br></pre></td></tr></table></figure></p>
<p><strong>字符串全部大写和小写</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">name = <span class="string">"Ada Lovelace"</span></span><br><span class="line">print(name.upper())</span><br><span class="line">print(name.lower())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">ADA LOVELACE</span><br><span class="line">ada lovelace</span><br></pre></td></tr></table></figure>
<p><strong>字符串拼接</strong>：Python中用<code>+</code>号进行字符串拼接</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">first_name = <span class="string">"ada"</span></span><br><span class="line">last_name = <span class="string">"lovelace"</span></span><br><span class="line">full_name = first_name + <span class="string">" "</span> + last_name</span><br><span class="line">print(full_name)</span><br><span class="line">print(<span class="string">"Hello, "</span> + full_name.title() + <span class="string">"!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">ada lovelace</span><br><span class="line">Hello, Ada Lovelace!</span><br></pre></td></tr></table></figure>
<p><strong>删除字符串首尾的空白</strong>：删左空白，删有空白，删两端空白 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp = <span class="string">' python '</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp</span><br><span class="line"><span class="string">' python '</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp.lstrip()</span><br><span class="line"><span class="string">'python '</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp.rstrip()</span><br><span class="line"><span class="string">' python'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp.strip()</span><br><span class="line"><span class="string">'python'</span></span><br></pre></td></tr></table></figure> # 4. 数字</p>
<p>特别注意Python中的默认除法：两个整数相除，如果除不尽，会有小数，而不是只保留整数（如C/C++, Java, Python2） <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#整数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> + <span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> - <span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> * <span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> / <span class="number">2</span></span><br><span class="line"><span class="number">1.5</span> <span class="comment">#不是1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> ** <span class="number">2</span> <span class="comment">#乘方运算</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">2</span> + <span class="number">3</span>) * <span class="number">4</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#浮点数（结果包含的小数位数可能不确定）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0.1</span> + <span class="number">0.1</span></span><br><span class="line"><span class="number">0.2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0.2</span> + <span class="number">0.1</span>  <span class="comment">#和计算机内部数字的表示方法有关</span></span><br><span class="line"><span class="number">0.30000000000000004</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> * <span class="number">0.1</span></span><br><span class="line"><span class="number">0.30000000000000004</span></span><br></pre></td></tr></table></figure></p>
<p><strong>数字与字符串的拼接</strong>：使用<code>str()</code>函数，否则会报<code>TypeError</code> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">age = <span class="number">18</span></span><br><span class="line">message = <span class="string">"Happy "</span> + age + <span class="string">"rd Birthday!"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File line <span class="number">38</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    message = <span class="string">"Happy "</span> + age + <span class="string">"rd Birthday!"</span></span><br><span class="line">TypeError: must be str, <span class="keyword">not</span> int</span><br></pre></td></tr></table></figure></p>
<p>正确语法： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line">age = <span class="number">18</span></span><br><span class="line">message = <span class="string">"Happy "</span> + str(age) + <span class="string">"rd Birthday!"</span></span><br><span class="line">print(message)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">Happy <span class="number">18</span>rd Birthday!</span><br></pre></td></tr></table></figure></p>
<h1 id="注释">5. 注释</h1>
<p>Python中的注释为<code>#</code>号，从<code>#</code>号开始到本行结束的中间这部分均为注释内容，不会被执行。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码：</span></span><br><span class="line"><span class="comment">#Say hello to everyone</span></span><br><span class="line">print(<span class="string">"Hello Python people!"</span>)   <span class="comment"># Test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">Hello Python people!</span><br></pre></td></tr></table></figure></p>
<h1 id="python之禅">6. Python之禅</h1>
<p>在python命令行中运行如下代码，即可查看Python社区所推崇的代码原则： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import this</span><br><span class="line">The Zen of Python, by Tim Peters</span><br><span class="line"></span><br><span class="line">Beautiful is better than ugly.</span><br><span class="line">Explicit is better than implicit.</span><br><span class="line">Simple is better than complex.</span><br><span class="line">Complex is better than complicated.</span><br><span class="line">Flat is better than nested.</span><br><span class="line">Sparse is better than dense.</span><br><span class="line">Readability counts.</span><br><span class="line">Special cases aren<span class="string">'t special enough to break the rules.</span></span><br><span class="line"><span class="string">Although practicality beats purity.</span></span><br><span class="line"><span class="string">Errors should never pass silently.</span></span><br><span class="line"><span class="string">Unless explicitly silenced.</span></span><br><span class="line"><span class="string">In the face of ambiguity, refuse the temptation to guess.</span></span><br><span class="line"><span class="string">There should be one-- and preferably only one --obvious way to do it.</span></span><br><span class="line"><span class="string">Although that way may not be obvious at first unless you'</span>re Dutch.</span><br><span class="line">Now is better than never.</span><br><span class="line">Although never is often better than *right* now.</span><br><span class="line">If the implementation is hard to explain, it<span class="string">'s a bad idea.</span></span><br><span class="line"><span class="string">If the implementation is easy to explain, it may be a good idea.</span></span><br><span class="line"><span class="string">Namespaces are one honking great idea -- let'</span>s <span class="keyword">do</span> more of those!</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python基础</tag>
      </tags>
  </entry>
</search>
